<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Senit_Co</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://senitco.github.io/"/>
  <updated>2018-03-20T04:43:42.590Z</updated>
  <id>https://senitco.github.io/</id>
  
  <author>
    <name>Senit_Co</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回溯(Backtracking)问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/03/08/data-structure-backtracking-1/"/>
    <id>https://senitco.github.io/2018/03/08/data-structure-backtracking-1/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中回溯(Backtracking)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><p>题目描述：<a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="external">LeetCode</a><br>Given a string s, partition s such that every substring of the partition is a palindrome.<br>Return all possible palindrome partitioning of s.<br>For example, given s = “aab”, return<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cut;</div><div class="line">    backtrack(result, cut, s, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cut, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(begin == s.length())</div><div class="line">    &#123;</div><div class="line">        result.push_back(cut);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; s.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(isPalindrome(s, begin, i))</div><div class="line">        &#123;</div><div class="line">            cut.push_back(s.substr(begin, i - begin + <span class="number">1</span>));</div><div class="line">            backtrack(result, cut, s, i + <span class="number">1</span>);</div><div class="line">            cut.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(start &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[start++] != s[end--])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中回溯(Backtracking)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="backtracking" scheme="https://senitco.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>位操作(Bit Manipulation)问题集锦</title>
    <link href="https://senitco.github.io/2018/03/05/data-structure-bit-manipulation/"/>
    <id>https://senitco.github.io/2018/03/05/data-structure-bit-manipulation/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中位操作(Bit Manipulation)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><p>题目描述：<a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="external">LeetCode</a><br>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br>分析：最大次数为两次，使用1位即可表示，即采用一个int型变量存储数组的元素和，在累加过程中除以2取余，每一位的变化过程为0-&gt;1-&gt;0(2/0)，利用异或操作实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        ones = ones ^ nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h3><p>题目描述：<a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="external">LeetCode</a><br>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.<br>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hash表，用到了额外的存储空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        cnt[nums[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : cnt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(t.second == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> t.first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//位操作，对int型数据（32位）分别进行求和除以3取余，所得数字即为所求</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digit(<span class="number">32</span>, <span class="number">0</span>);   <span class="comment">//固定数组仍为常量存储空间</span></div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)</div><div class="line">        &#123;</div><div class="line">            digit[j] += (nums[i] &gt;&gt; j) &amp; <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</div><div class="line">    &#123;</div><div class="line">        result += (digit[i] % <span class="number">3</span>) &lt;&lt; i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">位操作：用两个int数据分别存储数组和的低位和高位，最大次数为3，因此使用两位即可表示，</span></div><div class="line"><span class="comment">所以采用两个int型数据，在累加过程中需要对3取余，因此每一位的变化过程为00(0)-&gt;01(1)</span></div><div class="line"><span class="comment">-&gt;10(2)-&gt;00(3/0)。代码中的表达式可由数字逻辑的真值表求得</span></div><div class="line"><span class="comment">See [here](http://blog.csdn.net/yutianzuijin/article/details/50597413)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        low = (low ^ nums[i]) &amp; ~high;</div><div class="line">        high = (high ^ nums[i]) &amp; ~low;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中位操作(Bit Manipulation)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="bit manipulation" scheme="https://senitco.github.io/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>贪心(Greedy)问题集锦</title>
    <link href="https://senitco.github.io/2018/03/02/data-structure-greedy/"/>
    <id>https://senitco.github.io/2018/03/02/data-structure-greedy/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.592Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中贪心问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a>Gas Station</h3><p>题目描述：<a href="https://leetcode.com/problems/gas-station/description/" target="_blank" rel="external">LeetCode</a><br>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.<br>Note: The solution is guaranteed to be unique.<br>分析：（1）如果gas总储存量不小于总消耗量，那么一定存在一条循环路线<br>（2）如果某一点的累积存储量小于累积消耗量，那么将下一点作为起始点（如果A点不能到达B点，那么A、B之间的任一点都无法到B点，因此直接选取B的下一点作为起始点）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> size = gas.size();</div><div class="line">    <span class="keyword">int</span> sumGas = <span class="number">0</span>, sumCost = <span class="number">0</span>, tank = <span class="number">0</span>, start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">    &#123;</div><div class="line">        sumGas += gas[i];</div><div class="line">        sumCost += cost[i];</div><div class="line">        tank += gas[i] - cost[i];</div><div class="line">        <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)  </div><div class="line">        &#123;</div><div class="line">            start = i + <span class="number">1</span>;</div><div class="line">            tank = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(sumGas &lt; sumCost)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中贪心问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="greedy" scheme="https://senitco.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>二叉树问题集锦（二）</title>
    <link href="https://senitco.github.io/2018/02/27/data-structure-binary-tree-2/"/>
    <id>https://senitco.github.io/2018/02/27/data-structure-binary-tree-2/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二叉树问题的总结归纳。<br><a id="more"></a></p>
<p>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><p>题目描述：Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, minDepth = INT_MAX;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        traverse(root, depth, minDepth);</div><div class="line">        <span class="keyword">return</span> minDepth;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="keyword">int</span>&amp; minDepth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(depth &lt; minDepth)</div><div class="line">                minDepth = depth;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;   </div><div class="line">        traverse(node-&gt;left, depth + <span class="number">1</span>, minDepth);</div><div class="line">        traverse(node-&gt;right, depth + <span class="number">1</span>, minDepth);  </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> l = minDepth(root-&gt;left);</div><div class="line">        <span class="keyword">int</span> r = minDepth(root-&gt;right);</div><div class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span> + l + r;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(l, r);    </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">广度优先遍历（层序遍历），找到的第一个叶节点的深度即是最浅，不需要遍历所有结点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</div><div class="line">        TreeNode *last, *now;</div><div class="line">        <span class="keyword">int</span> level, size;</div><div class="line">        last = now = root;</div><div class="line">        level = <span class="number">1</span>;</div><div class="line">        qu.push(root);</div><div class="line">        <span class="keyword">while</span>(qu.size())</div><div class="line">        &#123;</div><div class="line">            now = qu.front();</div><div class="line">            qu.pop();</div><div class="line">            size = qu.size();</div><div class="line">            <span class="keyword">if</span>(now-&gt;left)   qu.push(now-&gt;left);</div><div class="line">            <span class="keyword">if</span>(now-&gt;right)  qu.push(now-&gt;right);</div><div class="line">            <span class="keyword">if</span>(qu.size() == size)   <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span>(last == now)</div><div class="line">            &#123;</div><div class="line">                level++;</div><div class="line">                <span class="keyword">if</span>(qu.size())</div><div class="line">                    last = qu.back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> level;      </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><p>题目描述：Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example: Given binary tree [3,9,20,null,null,15,7],</span></div><div class="line"><span class="comment">    3</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  9  20</span></div><div class="line"><span class="comment">    /  \</span></div><div class="line"><span class="comment">   15   7</span></div><div class="line"><span class="comment">return its depth = 3.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//队列实现层序遍历（广度优先遍历）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        toVisit.push(root);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> size = toVisit.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            &#123;</div><div class="line">                TreeNode* curr = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                <span class="keyword">if</span>(curr-&gt;left)  toVisit.push(curr-&gt;left);</div><div class="line">                <span class="keyword">if</span>(curr-&gt;right) toVisit.push(curr-&gt;right);</div><div class="line">            &#125;</div><div class="line">            depth++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> depth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, maxDepth = <span class="number">0</span>;</div><div class="line">        traverse(root, depth, maxDepth);</div><div class="line">        <span class="keyword">return</span> maxDepth;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="keyword">int</span>&amp; maxDepth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)</div><div class="line">                maxDepth = depth;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;   </div><div class="line">        traverse(node-&gt;left, depth + <span class="number">1</span>, maxDepth);</div><div class="line">        traverse(node-&gt;right, depth + <span class="number">1</span>, maxDepth);  </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归遍历（深度优先遍历）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><p>题目描述：Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example 1: Given the following tree [3,9,20,null,null,15,7]:</span></div><div class="line"><span class="comment">    3</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  9  20</span></div><div class="line"><span class="comment">    /  \</span></div><div class="line"><span class="comment">   15   7</span></div><div class="line"><span class="comment">Return true.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:</span></div><div class="line"><span class="comment">       1</span></div><div class="line"><span class="comment">      / \</span></div><div class="line"><span class="comment">     2   2</span></div><div class="line"><span class="comment">    / \</span></div><div class="line"><span class="comment">   3   3</span></div><div class="line"><span class="comment">  / \</span></div><div class="line"><span class="comment"> 4   4</span></div><div class="line"><span class="comment">Return false.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">自顶向下：判断每个结点左右子树的深度，如果深度差大于1，则返回false，否则继续考察其子结点是否为平衡树</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">int</span> left = depth(root-&gt;left);</div><div class="line">        <span class="keyword">int</span> right = depth(root-&gt;right);</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> max(depth(node-&gt;left), depth(node-&gt;right)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">自底向上，后序遍历（左-右-中），从叶子结点开始计算每个结点的高度，并判断左右子树的高度差是否大于1，</span></div><div class="line"><span class="comment">若大于1则递归返回1，否则进一步判断其他结点是否为平衡树。（相比于自顶向下，该方法更高效）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> dfsHeight(root) != <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* node)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> left = dfsHeight(node-&gt;left);</div><div class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> right = dfsHeight(node-&gt;right);</div><div class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二叉树问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>二叉树与层序遍历</title>
    <link href="https://senitco.github.io/2018/02/25/data-structure-BiTree-level-order/"/>
    <id>https://senitco.github.io/2018/02/25/data-structure-BiTree-level-order/</id>
    <published>2018-02-24T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.589Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中利用层序遍历(DFS)借助二叉树问题。<br><a id="more"></a></p>
<p>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><p>题目描述：Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example: Given binary tree [3,9,20,null,null,15,7],</span></div><div class="line"><span class="comment">    3</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  9  20</span></div><div class="line"><span class="comment">    /  \</span></div><div class="line"><span class="comment">   15   7</span></div><div class="line"><span class="comment">return its level order traversal as:</span></div><div class="line"><span class="comment">[</span></div><div class="line"><span class="comment">  [3],</span></div><div class="line"><span class="comment">  [9,20],</span></div><div class="line"><span class="comment">  [15,7]</span></div><div class="line"><span class="comment">]</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">借助队列实现广度优先遍历</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> result;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        toVisit.push(root);</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> size = toVisit.size();</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)   <span class="comment">//区分每一层的数据</span></div><div class="line">            &#123;</div><div class="line">                TreeNode* curr = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                <span class="keyword">if</span>(curr-&gt;left)  toVisit.push(curr-&gt;left);</div><div class="line">                <span class="keyword">if</span>(curr-&gt;right) toVisit.push(curr-&gt;right);</div><div class="line">                layer.push_back(curr-&gt;val);</div><div class="line">            &#125;</div><div class="line">            result.push_back(layer);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">深度优先遍历（先序遍历），借助一个变量表示当前的层数，如此遍历顺序不再关键</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        preorderDFS(result, root, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderDFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, TreeNode* node, <span class="keyword">int</span> depth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(result.size() == depth)</div><div class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        result[depth].push_back(node-&gt;val);</div><div class="line">        preorderDFS(result, node-&gt;left, depth + <span class="number">1</span>);</div><div class="line">        preorderDFS(result, node-&gt;right, depth + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h3><p>题目描述：Given a binary tree. Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.<br>Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example, Given the following perfect binary tree,</span></div><div class="line"><span class="comment">         1</span></div><div class="line"><span class="comment">       /  \</span></div><div class="line"><span class="comment">      2    3</span></div><div class="line"><span class="comment">     / \  / \</span></div><div class="line"><span class="comment">    4  5  6  7</span></div><div class="line"><span class="comment">After calling your function, the tree should look like:</span></div><div class="line"><span class="comment">         1 -&gt; NULL</span></div><div class="line"><span class="comment">       /  \</span></div><div class="line"><span class="comment">      2 -&gt; 3 -&gt; NULL</span></div><div class="line"><span class="comment">     / \  / \</span></div><div class="line"><span class="comment">    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//Definition for binary tree with next pointer.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeLinkNode *left, *right, *next;</div><div class="line">    TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">借助队列实现广度优先遍历，但空间复杂度不是常量存储</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeLinkNode*&gt; toVisit;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</div><div class="line">        toVisit.push(root);</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> size = toVisit.size();</div><div class="line">            TreeLinkNode* cur = toVisit.front();</div><div class="line">            <span class="keyword">if</span>(!cur)  <span class="keyword">return</span>;</div><div class="line">            toVisit.pop();</div><div class="line">            toVisit.push(cur-&gt;left);</div><div class="line">            toVisit.push(cur-&gt;right);</div><div class="line">            TreeLinkNode* next;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</div><div class="line">            &#123;</div><div class="line">                </div><div class="line">                next = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                cur-&gt;next = next;</div><div class="line">                toVisit.push(next-&gt;left);</div><div class="line">                toVisit.push(next-&gt;right);</div><div class="line">                cur = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</div><div class="line">        TreeLinkNode *pre = root, *cur = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span>(pre-&gt;left)</div><div class="line">        &#123;</div><div class="line">            cur = pre;</div><div class="line">            <span class="keyword">while</span>(cur)</div><div class="line">            &#123;</div><div class="line">                cur-&gt;left-&gt;next = cur-&gt;right;</div><div class="line">                <span class="keyword">if</span>(cur-&gt;next)</div><div class="line">                    cur-&gt;right-&gt;next = cur-&gt;next-&gt;left;</div><div class="line">                cur = cur-&gt;next;</div><div class="line">            &#125;</div><div class="line">            pre = pre-&gt;left;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h3><p>题目描述：Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space.<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example, Given the following binary tree,</span></div><div class="line"><span class="comment">         1</span></div><div class="line"><span class="comment">       /  \</span></div><div class="line"><span class="comment">      2    3</span></div><div class="line"><span class="comment">     / \    \</span></div><div class="line"><span class="comment">    4   5    7</span></div><div class="line"><span class="comment">After calling your function, the tree should look like:</span></div><div class="line"><span class="comment">         1 -&gt; NULL</span></div><div class="line"><span class="comment">       /  \</span></div><div class="line"><span class="comment">      2 -&gt; 3 -&gt; NULL</span></div><div class="line"><span class="comment">     / \    \</span></div><div class="line"><span class="comment">    4-&gt; 5 -&gt; 7 -&gt; NULL</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//Definition for binary tree with next pointer.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeLinkNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeLinkNode *left, *right, *next;</div><div class="line">    TreeLinkNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), next(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//层序遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</div><div class="line">        TreeLinkNode *head = root;  <span class="comment">//下一层最左边的结点（起始有效结点）</span></div><div class="line">        TreeLinkNode *curr = <span class="literal">NULL</span>;  <span class="comment">//上一层中的当前结点</span></div><div class="line">        TreeLinkNode *prev = <span class="literal">NULL</span>;  <span class="comment">//下一层中前一个结点（用于连接当前结点的左子结点或右子结点作为其下一个结点）</span></div><div class="line">        <span class="keyword">while</span>(head)</div><div class="line">        &#123;</div><div class="line">            curr = head;</div><div class="line">            head = prev = <span class="literal">NULL</span>;</div><div class="line">            <span class="keyword">while</span>(curr)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(curr-&gt;left)      </div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(prev)</div><div class="line">                        prev-&gt;next = curr-&gt;left;    <span class="comment">//给前一个结点的next指针赋值</span></div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        head = curr-&gt;left;  <span class="comment">//如果前一个结点不存在，则给起始结点赋值</span></div><div class="line">                    prev = curr-&gt;left;      <span class="comment">//更新前一个结点</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(curr-&gt;right)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(prev)</div><div class="line">                        prev-&gt;next = curr-&gt;right;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        head = curr-&gt;right;</div><div class="line">                    prev = curr-&gt;right;</div><div class="line">                &#125;</div><div class="line">                curr = curr-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中利用层序遍历(DFS)借助二叉树问题。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
      <category term="level order" scheme="https://senitco.github.io/tags/level-order/"/>
    
  </entry>
  
  <entry>
    <title>二叉树与深度优先遍历（二）</title>
    <link href="https://senitco.github.io/2018/02/24/data-structure-BiTree-dfs-2/"/>
    <id>https://senitco.github.io/2018/02/24/data-structure-BiTree-dfs-2/</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.589Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中利用深度优先遍历(DFS)借助二叉树问题。<br><a id="more"></a></p>
<h3 id="Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted Array to Binary Search Tree"></a>Convert Sorted Array to Binary Search Tree</h3><p>题目描述：Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example: Given the sorted array: [-10,-3,0,5,9],</span></div><div class="line"><span class="comment">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span></div><div class="line"><span class="comment">      0</span></div><div class="line"><span class="comment">     / \</span></div><div class="line"><span class="comment">   -3   9</span></div><div class="line"><span class="comment">   /   /</span></div><div class="line"><span class="comment"> -10  5</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//递归二分，将中点值置于合适的树结点中</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        TreeNode* root = <span class="literal">NULL</span>;</div><div class="line">        partition(root, nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(TreeNode*&amp; node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(left &gt; right)    <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">        node = <span class="keyword">new</span> TreeNode(nums[mid]);</div><div class="line">        partition(node-&gt;left, nums, left, mid - <span class="number">1</span>);</div><div class="line">        partition(node-&gt;right, nums, mid + <span class="number">1</span>, right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Convert Sorted List to Binary Search Tree"></a>Convert Sorted List to Binary Search Tree</h3><p>题目描述：Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example: Given the sorted linked list: [-10,-3,0,5,9],</span></div><div class="line"><span class="comment">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span></div><div class="line"><span class="comment">      0</span></div><div class="line"><span class="comment">     / \</span></div><div class="line"><span class="comment">   -3   9</span></div><div class="line"><span class="comment">   /   /</span></div><div class="line"><span class="comment"> -10  5</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for a binary tree node.</span></div><div class="line"><span class="comment"> * struct TreeNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     TreeNode *left;</span></div><div class="line"><span class="comment"> *     TreeNode *right;</span></div><div class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">同样采用递归二分的思想，由于链表不能随机存取，因此只能通过遍历的方式定位到区间中点，此处采用快慢指针</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        TreeNode* root = <span class="literal">NULL</span>;</div><div class="line">        partition(root, head, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(TreeNode*&amp; tree, ListNode* start, ListNode* end)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        ListNode *slow = start, *fast = start;</div><div class="line">        <span class="keyword">if</span>(start == end)</div><div class="line">            <span class="keyword">return</span>;   </div><div class="line">        <span class="keyword">while</span>(fast != end &amp;&amp; fast-&gt;next != end)</div><div class="line">        &#123;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        tree = <span class="keyword">new</span> TreeNode(slow-&gt;val);</div><div class="line">        partition(tree-&gt;left, start, slow);</div><div class="line">        partition(tree-&gt;right, slow-&gt;next, end);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//采用累计步长定位到区间中点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        TreeNode* root = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(ListNode* node = head; node != <span class="literal">NULL</span>; node = node-&gt;next) size++;</div><div class="line">        partition(root, head, size);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(TreeNode*&amp; tree, ListNode* start, <span class="keyword">int</span> size)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span>;   </div><div class="line">        ListNode *mid = start;</div><div class="line">        <span class="keyword">int</span> half = size &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; half; i++)</div><div class="line">            mid = mid-&gt;next;</div><div class="line">        tree = <span class="keyword">new</span> TreeNode(mid-&gt;val);</div><div class="line">        partition(tree-&gt;left, start, half);</div><div class="line">        partition(tree-&gt;right, mid-&gt;next, size - half - <span class="number">1</span>); <span class="comment">//此处size-half不能直接替换为size/2</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="Construct Binary Tree from Preorder and Inorder Traversal"></a>Construct Binary Tree from Preorder and Inorder Traversal</h3><p>题目描述：Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note: You may assume that duplicates do not exist in the tree.<a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">For example, given preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</div><div class="line">Return the following binary tree:</div><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>  <span class="number">20</span></div><div class="line">    /  \</div><div class="line">   <span class="number">15</span>   <span class="number">7</span></div><div class="line"></div><div class="line"><span class="comment">/**递归法</span></div><div class="line"><span class="comment">对于先序中的第一个元素，找到中序中的对应元素的位置（可借助一个hash表直接存取，无需每次遍历），然后以该位置为中点，</span></div><div class="line"><span class="comment">将中序序列分成两部分递归进行，同时确定两个子序列的先序起点和终点</span></div><div class="line"><span class="comment">*/</span></div><div class="line">class Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TreeNode* buildTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder) &#123;</div><div class="line">        <span class="keyword">if</span>(preorder.empty())    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)</div><div class="line">            mp[inorder[i]] = i;</div><div class="line">        TreeNode* root = recursive(preorder, inorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, mp);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">recursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mp)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(preStart &gt; preEnd || inStart &gt; inEnd)    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preStart]);</div><div class="line">        <span class="keyword">int</span> inRoot = mp[root-&gt;val];</div><div class="line">        <span class="keyword">int</span> numLeft = inRoot - inStart; <span class="comment">//左子序列的长度</span></div><div class="line">        root-&gt;left = recursive(preorder, inorder, preStart + <span class="number">1</span>, preStart + numLeft, inStart, inRoot - <span class="number">1</span>, mp);</div><div class="line">        root-&gt;right = recursive(preorder, inorder, preStart + numLeft + <span class="number">1</span>, preEnd, inRoot + <span class="number">1</span>, inEnd, mp);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**迭代法</span></div><div class="line"><span class="comment">使用两个变量i,j分别表示先序和中序的索引，并将先序中的元素依次压入栈中，进栈的同时依次生成每颗子树的左子结点，</span></div><div class="line"><span class="comment">直至栈顶元素和中序元素一致，说明该结点为某颗子树的根结点，这时应该为该结点插入右子结点，并将该该结点出栈。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(preorder.empty())    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</div><div class="line">        st.push(root);</div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">//使用flag标记是插入左子结点还是右子结点</span></div><div class="line">        TreeNode* t = root;</div><div class="line">        <span class="keyword">while</span>(i &lt; preorder.size())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top()-&gt;val == inorder[j])</div><div class="line">            &#123;</div><div class="line">                t = st.top();</div><div class="line">                st.pop();</div><div class="line">                flag = <span class="number">1</span>;   <span class="comment">//只有在回溯时（栈实现）遇到到子树的根结点才会右转生成右子结点</span></div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    t-&gt;left = <span class="keyword">new</span> TreeNode(preorder[i]);</div><div class="line">                    t = t-&gt;left;</div><div class="line">                    st.push(t);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    flag = <span class="number">0</span>;   <span class="comment">//每次插入右子结点重置flag标志</span></div><div class="line">                    t-&gt;right = <span class="keyword">new</span> TreeNode(preorder[i]);</div><div class="line">                    t = t-&gt;right;</div><div class="line">                    st.push(t);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="Construct Binary Tree from Inorder and Postorder Traversal"></a>Construct Binary Tree from Inorder and Postorder Traversal</h3><p>题目描述：Given inorder and postorder traversal of a tree, construct the binary tree.<br>Note: You may assume that duplicates do not exist in the tree.<a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">For example, given inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>], postorder = [<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</div><div class="line">Return the following binary tree:</div><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>  <span class="number">20</span></div><div class="line">    /  \</div><div class="line">   <span class="number">15</span>   <span class="number">7</span></div><div class="line"></div><div class="line"><span class="comment">/**递归法</span></div><div class="line"><span class="comment">对于后序（左-右-中）中的最后一个元素，找到中序中的对应元素的位置（可借助一个hash表直接存取，无需每次遍历），然后以该位置为中点，</span></div><div class="line"><span class="comment">将中序序列分成两部分递归进行，同时确定两个子序列的后序起点和终点</span></div><div class="line"><span class="comment">*/</span></div><div class="line">class Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    TreeNode* buildTree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder) &#123;</div><div class="line">        <span class="keyword">if</span>(inorder.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; inorder.size(); i++)</div><div class="line">            mp[inorder[i]] = i;</div><div class="line">        TreeNode* root = recursive(inorder, postorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>, mp);</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">recursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; mp)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(inStart &gt; inEnd || postStart &gt; postEnd)  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(postorder[postEnd]);  <span class="comment">//后序序列的最后一个结点</span></div><div class="line">        <span class="keyword">int</span> inRoot = mp[node-&gt;val];</div><div class="line">        <span class="keyword">int</span> numLeft = inRoot - inStart;</div><div class="line">        node-&gt;left = recursive(inorder, postorder, inStart, inRoot - <span class="number">1</span>, postStart, postStart + numLeft - <span class="number">1</span>, mp);</div><div class="line">        node-&gt;right = recursive(inorder, postorder, inRoot + <span class="number">1</span>, inEnd, postStart + numLeft, postEnd - <span class="number">1</span>, mp);</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**迭代法</span></div><div class="line"><span class="comment">使用两个变量i,j分别表示后序和中序的索引，并依次从后往前遍历后序和中序序列。将后序中的元素从后往前压入栈中，进栈的同时依次生成</span></div><div class="line"><span class="comment">每颗子树的右子结点，直至栈顶元素和中序元素一致，说明该结点为某颗子树的根结点，这时应该为该结点插入左子结点，并将该该结点出栈。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(inorder.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</div><div class="line">        <span class="keyword">int</span> size = inorder.size();</div><div class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[size - <span class="number">1</span>]);</div><div class="line">        st.push(root);</div><div class="line">        TreeNode* t = root;</div><div class="line">        <span class="keyword">int</span> i = size - <span class="number">2</span>, j = size - <span class="number">1</span>, flag = <span class="number">0</span>;   <span class="comment">//使用flag标记是插入左子结点还是右子结点</span></div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!st.empty() &amp;&amp; st.top()-&gt;val == inorder[j])</div><div class="line">            &#123;</div><div class="line">                t = st.top();</div><div class="line">                st.pop();</div><div class="line">                flag = <span class="number">1</span>;       <span class="comment">//只有在回溯时（栈实现）遇到到子树的根结点才会左转生成左子结点</span></div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>)</div><div class="line">                &#123;</div><div class="line">                    t-&gt;right = <span class="keyword">new</span> TreeNode(postorder[i]);</div><div class="line">                    t = t-&gt;right;</div><div class="line">                    st.push(t);</div><div class="line">                    i--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    flag = <span class="number">0</span>;       <span class="comment">//每次插入左子结点重置flag标志</span></div><div class="line">                    t-&gt;left = <span class="keyword">new</span> TreeNode(postorder[i]);</div><div class="line">                    t = t-&gt;left;</div><div class="line">                    st.push(t);</div><div class="line">                    i--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中利用深度优先遍历(DFS)借助二叉树问题。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>二叉树与深度优先遍历（一）</title>
    <link href="https://senitco.github.io/2018/02/23/data-structure-BiTree-dfs-1/"/>
    <id>https://senitco.github.io/2018/02/23/data-structure-BiTree-dfs-1/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.589Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中利用深度优先遍历(DFS)借助二叉树问题。<br><a id="more"></a></p>
<p>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h3><p>题目描述：Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers.<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">For example,</div><div class="line">    <span class="number">1</span></div><div class="line">   / \</div><div class="line">  <span class="number">2</span>   <span class="number">3</span></div><div class="line">The root-to-leaf path <span class="number">1</span>-&gt;<span class="number">2</span> represents the number <span class="number">12.</span></div><div class="line">The root-to-leaf path <span class="number">1</span>-&gt;<span class="number">3</span> represents the number <span class="number">13.</span></div><div class="line">Return the sum = <span class="number">12</span> + <span class="number">13</span> = <span class="number">25.</span></div><div class="line"></div><div class="line"><span class="comment">//法一：栈实现</span></div><div class="line"><span class="keyword">int</span> sumNumbers(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    toVisit.push(root);</div><div class="line">    <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        TreeNode* cur = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        <span class="keyword">if</span>(cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;right-&gt;val = cur-&gt;val * <span class="number">10</span> + cur-&gt;right-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(cur-&gt;left)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;left-&gt;val = cur-&gt;val * <span class="number">10</span> + cur-&gt;left-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            sum += cur-&gt;val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//法二：递归实现</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sum(root, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode* node, <span class="keyword">int</span> s)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">            <span class="keyword">return</span> s * <span class="number">10</span> + node-&gt;val;</div><div class="line">        <span class="keyword">return</span> sum(node-&gt;left, s * <span class="number">10</span> + node-&gt;val) + sum(node-&gt;right, s * <span class="number">10</span> + node-&gt;val);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Path-Sum"><a href="#Path-Sum" class="headerlink" title="Path Sum"></a>Path Sum</h3><p>题目描述：Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">For example: Given the below binary tree <span class="keyword">and</span> sum = <span class="number">22</span>,</div><div class="line">              <span class="number">5</span></div><div class="line">             / \</div><div class="line">            <span class="number">4</span>   <span class="number">8</span></div><div class="line">           /   / \</div><div class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line">         /  \      \</div><div class="line">        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>, as there exist a root-to-leaf path <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span> which sum is <span class="number">22.</span></div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历，迭代（借助栈）实现</span></div><div class="line"><span class="keyword">bool</span> hasPathSum(TreeNode* root, <span class="keyword">int</span> sum) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    toVisit.push(root);</div><div class="line">    <span class="keyword">int</span> pathSum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        TreeNode* cur = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        <span class="keyword">if</span>(cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;right-&gt;val += cur-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(cur-&gt;left)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;left-&gt;val += cur-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(cur-&gt;val == sum)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历，递归实现</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h3><p>题目描述：Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">For example: Given the below binary tree <span class="keyword">and</span> sum = <span class="number">22</span>,</div><div class="line">              <span class="number">5</span></div><div class="line">             / \</div><div class="line">            <span class="number">4</span>   <span class="number">8</span></div><div class="line">           /   / \</div><div class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line">         /  \    / \</div><div class="line">        <span class="number">7</span>    <span class="number">2</span>  <span class="number">5</span>   <span class="number">1</span></div><div class="line"><span class="keyword">return</span></div><div class="line">[</div><div class="line">   [<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</div><div class="line">   [<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历 + 回溯法</span></div><div class="line">class Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">        traverse(root, sum, result, path);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span>;</div><div class="line">        path.push_back(node-&gt;val);</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == node-&gt;val)</div><div class="line">            result.push_back(path);</div><div class="line">        traverse(node-&gt;left, sum - node-&gt;val, result, path);</div><div class="line">        traverse(node-&gt;right, sum - node-&gt;val, result, path);</div><div class="line">        path.pop_back();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//与上面等价</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span>;</div><div class="line">        path.push_back(node-&gt;val);</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == node-&gt;val)</div><div class="line">        &#123;</div><div class="line">            result.push_back(path);</div><div class="line">            path.pop_back();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        traverse(node-&gt;left, sum - node-&gt;val, result, path);</div><div class="line">        traverse(node-&gt;right, sum - node-&gt;val, result, path);</div><div class="line">        path.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Flatten-Binary-Tree-to-Linked-List"><a href="#Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Flatten Binary Tree to Linked List"></a>Flatten Binary Tree to Linked List</h3><p>题目描述：Given a binary tree, flatten it to a linked list in-place.<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Given a binary tree, flatten it to a linked list in-place.</span></div><div class="line"><span class="comment">For example, Given</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">         1</span></div><div class="line"><span class="comment">        / \</span></div><div class="line"><span class="comment">       2   5</span></div><div class="line"><span class="comment">      / \   \</span></div><div class="line"><span class="comment">     3   4   6</span></div><div class="line"><span class="comment">The flattened tree should look like:</span></div><div class="line"><span class="comment">   1</span></div><div class="line"><span class="comment">    \</span></div><div class="line"><span class="comment">     2</span></div><div class="line"><span class="comment">      \</span></div><div class="line"><span class="comment">       3</span></div><div class="line"><span class="comment">        \</span></div><div class="line"><span class="comment">         4</span></div><div class="line"><span class="comment">          \</span></div><div class="line"><span class="comment">           5</span></div><div class="line"><span class="comment">            \</span></div><div class="line"><span class="comment">             6</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法：对任意一个结点curr，其左子树（如果存在）按先序遍历的最后一个结点的右子结点为curr的右子结点，</span></div><div class="line"><span class="comment">curr的右子结点为curr的左子结点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    TreeNode* curr = root;</div><div class="line">    <span class="keyword">while</span>(curr)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(curr-&gt;left)</div><div class="line">        &#123;</div><div class="line">            TreeNode* prev = curr-&gt;left;</div><div class="line">            <span class="keyword">while</span>(prev-&gt;right)</div><div class="line">                prev = prev-&gt;right; <span class="comment">//遍历到左子树的最后一个结点，用于连接curr的右子树</span></div><div class="line">            prev-&gt;right = curr-&gt;right;</div><div class="line">            curr-&gt;right = curr-&gt;left;   <span class="comment">//用当前结点的左子树替换右子树</span></div><div class="line">            curr-&gt;left = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        curr = curr-&gt;right; <span class="comment">//往右移动结点</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归法（先序遍历的逆转版本：右-左-中）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        TreeNode* prev = <span class="literal">NULL</span>;</div><div class="line">        reversePreorder(root, prev);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//prev指针必须得传引用，保持更新，或者定义成一个成员变量</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reversePreorder</span><span class="params">(TreeNode* node, TreeNode*&amp; prev)</span>   </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span>;</div><div class="line">        reversePreorder(node-&gt;right, prev);</div><div class="line">        reversePreorder(node-&gt;left, prev);</div><div class="line">        node-&gt;right = prev;</div><div class="line">        node-&gt;left = <span class="literal">NULL</span>;</div><div class="line">        prev = node;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h3><p>题目描述：Given a binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/" target="_blank" rel="external">LeetCode</a><br>分析：要求二叉树中任意两个结点之间最大路径和，而不是从根结点出发到某一子结点的最大路径和。可采用深度优先遍历求解，只不过递归函数的返回值不是要求的最大和（最大和通过一个全局变量或者引用参数来同步更新），而是结点自身为根结点时到其子结点的最大路径，该值用于提供给其父结点计算最长路径（当其父节点为根结点时，下面的子结点只能是单向的）。简单来说，一个结点的最大路径和是其左子树路径和 + 右子树路径和 + 当前节点值，而返回值则是当前结点值加上左子树路径和与右子树路径和的较大值。考虑负数的影响，加入与0的比较。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> maxVal = INT_MIN;</div><div class="line">    maxPathDown(maxVal, root);</div><div class="line">    <span class="keyword">return</span> maxVal;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(<span class="keyword">int</span>&amp; maxVal, TreeNode* node)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> left = max(<span class="number">0</span>, maxPathDown(maxVal, node-&gt;left));     <span class="comment">//与0比较考虑了负数的影响</span></div><div class="line">    <span class="keyword">int</span> right = max(<span class="number">0</span>, maxPathDown(maxVal, node-&gt;right));</div><div class="line">    maxVal = max(maxVal, left + right + node-&gt;val);</div><div class="line">    <span class="keyword">return</span> max(left, right) + node-&gt;val;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中利用深度优先遍历(DFS)借助二叉树问题。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>深度优先遍历与广度优先遍历（二）</title>
    <link href="https://senitco.github.io/2018/02/20/data-structure-dfs-bfs-2/"/>
    <id>https://senitco.github.io/2018/02/20/data-structure-dfs-bfs-2/</id>
    <published>2018-02-19T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.591Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中深度优先遍历(DFS)与广度优先遍历(BFS)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h3><p>题目描述：<a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="external">LeetCode</a><br>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest<br>transformation sequence from beginWord to endWord, such that:<br>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</p>
<p>For example, Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于求取最小长度(深度)，一般采用广度优先遍历</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = wordList.size();</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">2</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(size, <span class="literal">false</span>);</div><div class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; toVisit;</div><div class="line">        findNextWord(beginWord, wordList, toVisit, visited);</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> num = toVisit.size();   </div><div class="line">            <span class="comment">//此处的for循环是为了分层，统计层数(深度)，如果只是遍历所有元素，可不需要</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">string</span> word = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                <span class="keyword">if</span>(word == endWord)</div><div class="line">                    <span class="keyword">return</span> depth;</div><div class="line">                findNextWord(word, wordList, toVisit, visited);</div><div class="line">            &#125;</div><div class="line">            depth++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findNextWord</span><span class="params">(<span class="built_in">string</span>&amp; word, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList, <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt;&amp; toVisit, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span></div><div class="line"><span class="function">    </span>&#123;      </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordList.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; numOfDiffLetter(word, wordList[i]) == <span class="number">1</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(wordList[i]);</div><div class="line">                visited[i] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfDiffLetter</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="built_in">string</span>&amp; word2)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(word1[i] != word2[i])</div><div class="line">                cnt++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Word-Ladder-II"><a href="#Word-Ladder-II" class="headerlink" title="Word Ladder II"></a>Word Ladder II</h3><p>题目描述：<a href="https://leetcode.com/problems/word-ladder-ii/description/" target="_blank" rel="external">LeetCode</a><br>Given two words (beginWord and endWord), and a dictionary’s word list, find all shortest transformation sequence(s)<br>from beginWord to endWord, such that:<br>Only one letter can be changed at a time<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>For example, Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>Return<br>  [<br>    [“hit”,”hot”,”dot”,”dog”,”cog”],<br>    [“hit”,”hot”,”lot”,”log”,”cog”]<br>  ]<br>Note:<br>Return an empty list if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">直接采用广度优先遍历，不需要回溯。tricky: 对路径进行BFS，而不是对单词</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; pathList; <span class="comment">//队列中存储的为单词变换的路径</span></div><div class="line">        pathList.push(&#123;beginWord&#125;);</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordList.begin(), wordList.end());</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</div><div class="line">        <span class="keyword">if</span>(wordSet.find(endWord) == wordSet.end())  <span class="comment">//endWord必在单词列表中</span></div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        <span class="comment">//wordSet.insert(endWord);</span></div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, minDepth = INT_MAX;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (!pathList.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = pathList.front();</div><div class="line">            pathList.pop();</div><div class="line">            <span class="keyword">if</span> (path.size() &gt; depth)    <span class="comment">//用于更新深度（层数）</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (path.size() &gt; minDepth) <span class="comment">//如果已取得最小深度，且遍历完该层，则返回</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">for</span>(<span class="built_in">string</span> s : visited) <span class="comment">//将集合中已访问的元素剔除</span></div><div class="line">                    wordSet.erase(s);</div><div class="line">                depth = path.size();</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">string</span> word = path.back();</div><div class="line">            <span class="comment">//遍历单词列表中的所有的元素并且和目标单词逐字符比较的方式会造成算法效率较低</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = wordSet.begin(); iter != wordSet.end();)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (numOfDiffLetter(word, *iter) == <span class="number">1</span>)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; newPath = path;</div><div class="line">                    newPath.push_back(*iter);</div><div class="line">                    <span class="keyword">if</span> (*iter == endWord)</div><div class="line">                    &#123;</div><div class="line">                        result.push_back(newPath);  <span class="comment">//将满足条件的路径存储到最终结果中</span></div><div class="line">                        minDepth = depth;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                    &#123;</div><div class="line">                        pathList.push(newPath); <span class="comment">//将可能的路径存储到队列中</span></div><div class="line">                        visited.insert(*iter);  <span class="comment">//记录已访问（在路径）中的单词</span></div><div class="line">                    &#125;          </div><div class="line">                &#125;</div><div class="line">                iter++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>: </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfDiffLetter</span><span class="params">(<span class="built_in">string</span>&amp; word1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word2)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(word1[i] != word2[i])</div><div class="line">                cnt++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">广度优先遍历 + 回溯：BFS构造可能的路径，Backtrack搜索满足条件的路径</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet(wordList.begin(), wordList.end());</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; toVisit(&#123;beginWord&#125;), temp;</div><div class="line">        <span class="keyword">if</span> (wordSet.find(endWord) == wordSet.end())</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        wordSet.erase(endWord);</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; children; <span class="comment">//存储每个单词的子结点</span></div><div class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> len = beginWord.length();</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (!toVisit.empty() &amp;&amp; !found)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">string</span> word : toVisit) <span class="comment">//在单词集合（列表）中剔除父结点（上一层的单词结点）</span></div><div class="line">                wordSet.erase(word);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span> word : toVisit)   <span class="comment">//搜索满足条件的子结点</span></div><div class="line">            &#123;</div><div class="line">                <span class="built_in">string</span> cur = word;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">char</span> ch = cur[j];</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++)</div><div class="line">                    &#123;</div><div class="line">                        cur[j] = k;</div><div class="line">                        <span class="keyword">if</span> (cur == endWord)</div><div class="line">                        &#123;</div><div class="line">                            found = <span class="literal">true</span>;</div><div class="line">                            children[word].push_back(endWord);</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (wordSet.count(cur) &amp;&amp; !found)</div><div class="line">                        &#123;</div><div class="line">                            children[word].push_back(cur);</div><div class="line">                            temp.insert(cur);  </div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    cur[j] = ch;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            swap(toVisit, temp);</div><div class="line">            temp.clear();         </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (found)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path(&#123; beginWord &#125;);</div><div class="line">            backtrack(beginWord, endWord, children, path, result);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//在所有可能的路径中递归回溯，搜索满足条件的路径</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">string</span>&amp; word, <span class="built_in">string</span>&amp; endWord, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; children, </span></span></div><div class="line"><span class="function"><span class="params">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (word == endWord)</div><div class="line">        &#123;</div><div class="line">            result.push_back(path);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (children.find(word) == children.end())</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> child : children[word])</div><div class="line">        &#123;</div><div class="line">            path.push_back(child);</div><div class="line">            backtrack(child, endWord, children, path, result);</div><div class="line">            path.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">双向广度优先遍历 + 回溯，算法效率较高</span></div><div class="line"><span class="comment">See http://zxi.mytechroad.com/blog/searching/leetcode-126-word-ladder-ii/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; findLadders(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict(wordList.begin(), wordList.end());</div><div class="line">        <span class="keyword">if</span> (!dict.count(endWord)) <span class="keyword">return</span> ans;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> l = beginWord.length();</div><div class="line">        </div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q1&#123;beginWord&#125;;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q2&#123;endWord&#125;;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; children;</div><div class="line"> </div><div class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">bool</span> backward = <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> (!q1.empty() &amp;&amp; !q2.empty() &amp;&amp; !found) &#123;            </div><div class="line">            <span class="comment">// Always expend the smaller queue first</span></div><div class="line">            <span class="keyword">if</span> (q1.size() &gt; q2.size()) &#123;</div><div class="line">                <span class="built_in">std</span>::swap(q1, q2);</div><div class="line">                backward = !backward;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; w : q1)</div><div class="line">                dict.erase(w);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; w : q2)</div><div class="line">                dict.erase(w);</div><div class="line">                        </div><div class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; q;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; word : q1) &#123;</div><div class="line">                <span class="built_in">string</span> curr = word;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</div><div class="line">                    <span class="keyword">char</span> ch = curr[i];</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</div><div class="line">                        curr[i] = j;</div><div class="line">                        </div><div class="line">                        <span class="keyword">const</span> <span class="built_in">string</span>* parent = &amp;word;</div><div class="line">                        <span class="keyword">const</span> <span class="built_in">string</span>* child = &amp;curr;</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (backward)</div><div class="line">                            <span class="built_in">std</span>::swap(parent, child);</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (q2.count(curr)) &#123;</div><div class="line">                            found = <span class="literal">true</span>;</div><div class="line">                            children[*parent].push_back(*child);</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dict.count(curr) &amp;&amp; !found) &#123;</div><div class="line">                            q.insert(curr);</div><div class="line">                            children[*parent].push_back(*child);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    curr[i] = ch;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="built_in">std</span>::swap(q, q1);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (found) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path&#123;beginWord&#125;;</div><div class="line">            getPaths(beginWord, endWord, children, path, ans);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPaths</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; word, </span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="built_in">string</span>&amp; endWord,                   </span></span></div><div class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; children, </span></span></div><div class="line"><span class="function"><span class="params">                  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; path, </span></span></div><div class="line"><span class="function"><span class="params">                  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; ans)</span> </span>&#123;        </div><div class="line">        <span class="keyword">if</span> (word == endWord) &#123;</div><div class="line">            ans.push_back(path);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> it = children.find(word);</div><div class="line">        <span class="keyword">if</span> (it == children.cend()) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; child : it-&gt;second) &#123;</div><div class="line">            path.push_back(child);</div><div class="line">            getPaths(child, endWord, children, path, ans);</div><div class="line">            path.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中深度优先遍历(DFS)与广度优先遍历(BFS)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>深度优先遍历与广度优先遍历（一）</title>
    <link href="https://senitco.github.io/2018/02/18/data-structure-dfs-bfs-1/"/>
    <id>https://senitco.github.io/2018/02/18/data-structure-dfs-bfs-1/</id>
    <published>2018-02-17T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.591Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中深度优先遍历(DFS)与广度优先遍历(BFS)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><p>题目描述：<a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="external">LeetCode</a><br>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.<br>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.<br>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">As an example, consider the serialized graph &#123;0,1,2#1,2#2,2&#125;.</span></div><div class="line"><span class="comment">The graph has a total of three nodes, and therefore contains three parts as separated by #.</span></div><div class="line"><span class="comment">First node is labeled as 0. Connect node 0 to both nodes 1 and 2.</span></div><div class="line"><span class="comment">Second node is labeled as 1. Connect node 1 to node 2.</span></div><div class="line"><span class="comment">Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.</span></div><div class="line"><span class="comment">Visually, the graph looks like the following:</span></div><div class="line"><span class="comment">       1</span></div><div class="line"><span class="comment">      / \</span></div><div class="line"><span class="comment">     /   \</span></div><div class="line"><span class="comment">    0 --- 2</span></div><div class="line"><span class="comment">         / \</span></div><div class="line"><span class="comment">         \_/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//Definition for undirected graph.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UndirectedGraphNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> label;</div><div class="line">    <span class="built_in">vector</span>&lt;UndirectedGraphNode *&gt; neighbors;</div><div class="line">    UndirectedGraphNode(<span class="keyword">int</span> x) : label(x) &#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**广度优先遍历</span></div><div class="line"><span class="comment">创建一个hash表，用于将原图中的所有节点和新拷贝的节点一一对应，然后采用广度优先遍历的方法依次访问原图节点，</span></div><div class="line"><span class="comment">拷贝创建对应的新节点，并处理邻接关系</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</div><div class="line">        UndirectedGraphNode* copy = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</div><div class="line">        mp[node] = copy;</div><div class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; toVisit;</div><div class="line">        toVisit.push(node);</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            UndirectedGraphNode* cur = toVisit.front();</div><div class="line">            toVisit.pop();</div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode* neigh : cur-&gt;neighbors)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(mp.find(neigh) == mp.end())  <span class="comment">//如果原图节点的对应结点不存在则创建</span></div><div class="line">                &#123;</div><div class="line">                    UndirectedGraphNode* copy_neigh = <span class="keyword">new</span> UndirectedGraphNode(neigh-&gt;label);</div><div class="line">                    mp[neigh] = copy_neigh;</div><div class="line">                    toVisit.push(neigh);</div><div class="line">                &#125;</div><div class="line">                mp[cur]-&gt;neighbors.push_back(mp[neigh]);    <span class="comment">//存储新节点的相邻结点</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> copy;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历（递归法）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">if</span>(mp.find(node) == mp.end())</div><div class="line">        &#123;</div><div class="line">            mp[node] = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);     </div><div class="line">            <span class="keyword">for</span>(UndirectedGraphNode* neigh : node-&gt;neighbors)</div><div class="line">            &#123;</div><div class="line">                mp[node]-&gt;neighbors.push_back(cloneGraph(neigh));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mp[node];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Surrounded-Regions"><a href="#Surrounded-Regions" class="headerlink" title="Surrounded Regions"></a>Surrounded Regions</h3><p>题目描述：<a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="external">LeetCode</a><br>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.<br>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.<br>For example,<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:<br>X X X X<br>X X X X<br>X X X X<br>X O X X<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//广度优先遍历(BFS)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(board.empty())    <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> height = board.size(), width = board[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) <span class="comment">//从左右边界开始搜索</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>)</div><div class="line">                bfs(board, i, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(board[i][width - <span class="number">1</span>] == <span class="string">'O'</span>)</div><div class="line">                bfs(board, i, width - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)  <span class="comment">//从上下边界开始搜索</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">'O'</span>)</div><div class="line">                bfs(board, <span class="number">0</span>, j);</div><div class="line">            <span class="keyword">if</span>(board[height - <span class="number">1</span>][j] == <span class="string">'O'</span>)</div><div class="line">                bfs(board, height - <span class="number">1</span>, j);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</div><div class="line">                    board[i][j] = <span class="string">'X'</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'B'</span>)</div><div class="line">                    board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> height = board.size(), width = board[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; toVisit;</div><div class="line">        board[i][j] = <span class="string">'B'</span>;</div><div class="line">        toVisit.push(make_pair(i, j));</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = toVisit.front();</div><div class="line">            toVisit.pop();</div><div class="line">            <span class="keyword">if</span>(cur.first &gt; <span class="number">0</span> &amp;&amp; board[cur.first - <span class="number">1</span>][cur.second] == <span class="string">'O'</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(make_pair(cur.first - <span class="number">1</span>, cur.second));</div><div class="line">                board[cur.first - <span class="number">1</span>][cur.second] = <span class="string">'B'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cur.first &lt; height - <span class="number">1</span> &amp;&amp; board[cur.first + <span class="number">1</span>][cur.second] == <span class="string">'O'</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(make_pair(cur.first + <span class="number">1</span>, cur.second));</div><div class="line">                board[cur.first + <span class="number">1</span>][cur.second] = <span class="string">'B'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cur.second &gt; <span class="number">0</span> &amp;&amp; board[cur.first][cur.second - <span class="number">1</span>] == <span class="string">'O'</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(make_pair(cur.first, cur.second - <span class="number">1</span>));</div><div class="line">                board[cur.first][cur.second - <span class="number">1</span>] = <span class="string">'B'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(cur.second &lt; width - <span class="number">1</span> &amp;&amp; board[cur.first][cur.second + <span class="number">1</span>] == <span class="string">'O'</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(make_pair(cur.first, cur.second + <span class="number">1</span>));</div><div class="line">                board[cur.first][cur.second + <span class="number">1</span>] = <span class="string">'B'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历(DFS)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(board.empty())    <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> height = board.size(), width = board[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>)</div><div class="line">                dfs(board, i, <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(board[i][width - <span class="number">1</span>] == <span class="string">'O'</span>)</div><div class="line">                dfs(board, i, width - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][j] == <span class="string">'O'</span>)</div><div class="line">                dfs(board, <span class="number">0</span>, j);</div><div class="line">            <span class="keyword">if</span>(board[height - <span class="number">1</span>][j] == <span class="string">'O'</span>)</div><div class="line">                dfs(board, height - <span class="number">1</span>, j);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</div><div class="line">                    board[i][j] = <span class="string">'X'</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'B'</span>)</div><div class="line">                    board[i][j] = <span class="string">'O'</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">int</span> height = board.size(), width = board[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; height &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; width &amp;&amp; board[i][j] == <span class="string">'O'</span>)</div><div class="line">        &#123;</div><div class="line">            board[i][j] = <span class="string">'B'</span>;</div><div class="line">            dfs(board, i - <span class="number">1</span>, j);</div><div class="line">            dfs(board, i + <span class="number">1</span>, j);</div><div class="line">            dfs(board, i, j - <span class="number">1</span>);</div><div class="line">            dfs(board, i, j + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中深度优先遍历(DFS)与广度优先遍历(BFS)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>动态规划(Dynamic Programming)问题集锦（三）</title>
    <link href="https://senitco.github.io/2018/02/09/data-structure-dynamic-programming-3/"/>
    <id>https://senitco.github.io/2018/02/09/data-structure-dynamic-programming-3/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.592Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中动态规划问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Distinct-Subsequences"><a href="#Distinct-Subsequences" class="headerlink" title="Distinct Subsequences"></a>Distinct Subsequences</h3><p>题目描述：Given a string S and a string T, count the number of distinct subsequences of S which equals T.A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).<br>Here is an example: S = “rabbbit”, T = “rabbit”, Return 3.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">An example:</span></div><div class="line"><span class="comment">S: [acdabefbc] and T: [ab]</span></div><div class="line"><span class="comment">first we check with a:</span></div><div class="line"><span class="comment">           *  *</span></div><div class="line"><span class="comment">      S = [acdabefbc]</span></div><div class="line"><span class="comment">mem[1] = [0111222222]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">then we check with ab:</span></div><div class="line"><span class="comment">               *  * </span></div><div class="line"><span class="comment">      S = [acdabefbc]</span></div><div class="line"><span class="comment">mem[1] = [0111222222]</span></div><div class="line"><span class="comment">mem[2] = [0000022244]</span></div><div class="line"><span class="comment">And the result is 4, as the distinct subsequences are:</span></div><div class="line"><span class="comment">      S = [a   b    ]</span></div><div class="line"><span class="comment">      S = [a      b ]</span></div><div class="line"><span class="comment">      S = [   ab    ]</span></div><div class="line"><span class="comment">      S = [   a   b ]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">dp[i][j]表示s[0...j-1]中包含t[0...i-1]的序列数，递推式满足：</span></div><div class="line"><span class="comment">如果t[i - 1] == s[j - 1]，则dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 1];</span></div><div class="line"><span class="comment">否则dp[i][j] = dp[i][j - 1];</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> lenS = s.length(), lenT = t.length();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(lenT + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lenS + <span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenS + <span class="number">1</span>; j++)</div><div class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lenT + <span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lenS + <span class="number">1</span>; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(t[i - <span class="number">1</span>] == s[j - <span class="number">1</span>])</div><div class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[lenT][lenS];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中动态规划问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>动态规划(Dynamic Programming)问题集锦（二）</title>
    <link href="https://senitco.github.io/2018/02/06/data-structure-dynamic-programming-2/"/>
    <id>https://senitco.github.io/2018/02/06/data-structure-dynamic-programming-2/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.592Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中动态规划问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><p>题目描述：Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<br>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6.<a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> maxSoFar = nums[<span class="number">0</span>], maxEndingHere = nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        maxEndingHere = max(maxEndingHere + nums[i], nums[i]);</div><div class="line">        maxSoFar = max(maxSoFar, maxEndingHere);    </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSoFar;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><p>题目描述：Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Example 1: Input: [7, 1, 5, 3, 6, 4], Output: 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)<br>Example 2: Input: [7, 6, 4, 3, 1], Output: 0<br>In this case, no transaction is done, i.e. max profit = 0.<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="external">LeetCode</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//minVal表示已遍历元素中的最小值，profit表示当前收益的最大值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> minVal = INT_MAX, profit = <span class="number">0</span>, size = prices.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">    &#123;</div><div class="line">        minVal = min(prices[i], minVal);</div><div class="line">        profit = max(profit, prices[i] - minVal);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">转化为最大子数列问题（Kadane算法），从动态规划的角度考虑：</span></div><div class="line"><span class="comment">maxEndingHere[i] = max(0, maxEndingHere[i - 1] + prices[i] - prices[i - 1]),</span></div><div class="line"><span class="comment">maxEndingHere[i - 1]表示第i-1天售出股票的最大利润，maxEndingHere[i]表示第i天售出股票的最大利润，</span></div><div class="line"><span class="comment">因此需要加上前后两天的股票差价，maxSoFor表示到目前为止的最大利益（不一定在当天售出）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> maxEndingHere = <span class="number">0</span>, maxSoFar = <span class="number">0</span>, size = prices.size();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</div><div class="line">    &#123;</div><div class="line">        maxEndingHere = max(<span class="number">0</span>, maxEndingHere += prices[i] - prices[i - <span class="number">1</span>]);</div><div class="line">        maxSoFar = max(maxEndingHere, maxSoFar);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxSoFar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a>Best Time to Buy and Sell Stock II</h3><p>题目描述：Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like(ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//累加相邻极小值点与极大值点之间的差值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> minVal = INT_MAX, maxPro = <span class="number">0</span>, sumPro = <span class="number">0</span>, size = prices.size();</div><div class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++)</div><div class="line">    &#123;</div><div class="line">        minVal = min(minVal, prices[i]);</div><div class="line">        <span class="keyword">if</span>(maxPro &lt; prices[i] - minVal)</div><div class="line">            maxPro = prices[i] - minVal;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            sumPro += maxPro;   <span class="comment">//maxPro没有更新，说明前一个点为极值点，累加收益值，并更新最小值和单次最大收益</span></div><div class="line">            minVal = prices[i];</div><div class="line">            maxPro = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(minVal != prices[size - <span class="number">1</span>])  <span class="comment">//考虑最后一个点为极大值的情况</span></div><div class="line">        sumPro += maxPro;</div><div class="line">    <span class="keyword">return</span> sumPro;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//累加递增的股票差值</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(prices[i - <span class="number">1</span>] &lt; prices[i])</div><div class="line">            profit += prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> profit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><p>题目描述：Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions.<br>Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**DP算法：可扩展到最多交易k次</span></div><div class="line"><span class="comment">定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优。</span></div><div class="line"><span class="comment">定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优。递推式为：</span></div><div class="line"><span class="comment">diff = prices[i] - prices[i - 1]</span></div><div class="line"><span class="comment">local[i][j] = max(global[i - 1][j - 1] + max(diff, 0), local[i - 1][j] + diff)</span></div><div class="line"><span class="comment">global[i][j] = max(local[i][j], global[i - 1][j])</span></div><div class="line"><span class="comment">其中局部最优值是比较前一天并少交易一次的全局最优加上大于0的差值，和前一天的局部最优加上差值中取较大值，</span></div><div class="line"><span class="comment">而全局最优比较局部最优和前一天的全局最优。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.empty())  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = prices.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; local(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>)), global(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">3</span>; j++)</div><div class="line">        &#123;</div><div class="line">            local[i][j] = max(global[i - <span class="number">1</span>][j - <span class="number">1</span>] + max(diff, <span class="number">0</span>), local[i - <span class="number">1</span>][j] + diff); </div><div class="line">            global[i][j] = max(global[i - <span class="number">1</span>][j], local[i][j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> global[n - <span class="number">1</span>][<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">用一维数组来代替二维数组，可以极大地减少空间，由于覆盖的顺序关系，遍历j需要从2到1，</span></div><div class="line"><span class="comment">这样可以取到正确的g[j-1]值，而非已经被覆盖过的值</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(prices.empty())  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> n = prices.size();</div><div class="line">    <span class="keyword">int</span> local[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;, global[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--)</div><div class="line">        &#123;</div><div class="line">            local[j] = max(global[j - <span class="number">1</span>] + max(<span class="number">0</span>, diff), local[j] + diff);</div><div class="line">            global[j] = max(global[j], local[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> global[<span class="number">2</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">lowestBuyPrice1始终为输入数组中的最低价，maxProfit1记录到目前为止最高价与最低价的差价（最高价需在最低价后面），</span></div><div class="line"><span class="comment">lowestBuyPrice2为相对最小值，maxProfit2则为最多买卖两次的累积最大收益</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> maxProfit1 = <span class="number">0</span>, maxProfit2 = <span class="number">0</span>, lowestBuyPrice1 = INT_MAX, lowestBuyPrice2 = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p : prices)</div><div class="line">    &#123;</div><div class="line">        maxProfit2 = max(maxProfit2, p - lowestBuyPrice2);</div><div class="line">        lowestBuyPrice2 = min(lowestBuyPrice2, p - maxProfit1);</div><div class="line">        maxProfit1 = max(maxProfit1, p - lowestBuyPrice1);</div><div class="line">        lowestBuyPrice1 = min(lowestBuyPrice1, p);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxProfit2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>问题描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.<br>Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.<a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example, given the following triangle</span></div><div class="line"><span class="comment">[</span></div><div class="line"><span class="comment">     [2],</span></div><div class="line"><span class="comment">    [3,4],</span></div><div class="line"><span class="comment">   [6,5,7],</span></div><div class="line"><span class="comment">  [4,1,8,3]</span></div><div class="line"><span class="comment">]</span></div><div class="line"><span class="comment">The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</span></div><div class="line"><span class="comment">DP算法：从下往上遍历，对当前的某一行取值，选择其下一行相邻的两个累加路径和中较小的一个，进行求和并将结果作为当前行当前位置的最短路径和。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(triangle.empty())    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> size = triangle.size(), minSum = <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathSum(triangle[size - <span class="number">1</span>].begin(), triangle[size - <span class="number">1</span>].end());</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)</div><div class="line">        &#123;</div><div class="line">            pathSum[j] = triangle[i][j] + min(pathSum[j], pathSum[j + <span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pathSum[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中动态规划问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
      <category term="buy-and-sell" scheme="https://senitco.github.io/tags/buy-and-sell/"/>
    
  </entry>
  
  <entry>
    <title>动态规划(Dynamic Programming)问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/02/04/data-structure-dynamic-programming-1/"/>
    <id>https://senitco.github.io/2018/02/04/data-structure-dynamic-programming-1/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.591Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中动态规划问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><p>题目描述：<a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="external">LeetCode</a><br>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words,<br>determine if s can be segmented into a space-separated sequence of one or more dictionary<br>words. You may assume the dictionary does not contain duplicate words.<br>For example, given s = “leetcode”, dict = [“leet”, “code”].<br>Return true because “leetcode” can be segmented as “leet code”.<br>分析：DP解法：定义一个数组dp[]，dp[i]为true表示一个有效的单词或单词序列和字符串s的前i个字符匹配<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; wordSet;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordDict)</div><div class="line">        wordSet.insert(word);   <span class="comment">//将所有元素移至hashset中，这样在一轮搜索过程中时间复杂度为O(1)</span></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(s.length() + <span class="number">1</span>, <span class="literal">false</span>);</div><div class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//反向遍历可能会更快</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(dp[j])   <span class="comment">//dp[j]为true且子串s.substr(j, i-j)在word集合中，则dp[i]为true</span></div><div class="line">            &#123;</div><div class="line">                <span class="built_in">string</span> str = s.substr(j, i - j);</div><div class="line">                <span class="keyword">if</span>(wordSet.find(str) != wordSet.end())</div><div class="line">                &#123;</div><div class="line">                    dp[i] = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[s.length()];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Malloc-Candy"><a href="#Malloc-Candy" class="headerlink" title="Malloc Candy"></a>Malloc Candy</h3><p>题目描述：<a href="https://leetcode.com/problems/candy/description/" target="_blank" rel="external">LeetCode</a><br>There are N children standing in a line. Each child is assigned a rating value.<br>You are giving candies to these children subjected to the following requirements:<br>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?<br>分析：分别前向、后向遍历一次，更新每个人应该分配的最小数量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mallocCandy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> size = ratings.size();</div><div class="line">    <span class="keyword">if</span>(size &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> size;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(size, <span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])</div><div class="line">            nums[i] = nums[i - <span class="number">1</span>] + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(ratings[i - <span class="number">1</span>] &gt; ratings[i])</div><div class="line">            nums[i - <span class="number">1</span>] = max(nums[i - <span class="number">1</span>], nums[i] + <span class="number">1</span>);</div><div class="line">        result += nums[i];  <span class="comment">//在第二次遍历(反向)时直接累加，避免再循环一次</span></div><div class="line">    &#125;</div><div class="line">    result += nums[<span class="number">0</span>];</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Palindrome-Partitioning-II"><a href="#Palindrome-Partitioning-II" class="headerlink" title="Palindrome Partitioning II"></a>Palindrome Partitioning II</h3><p>题目描述：<a href="https://leetcode.com/problems/palindrome-partitioning-ii/description/" target="_blank" rel="external">LeetCode</a><br>Given a string s, partition s such that every substring of the partition is a palindrome.<br>Return the minimum cuts needed for a palindrome partitioning of s.<br>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//法一</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = s.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cut(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</div><div class="line">        cut[i] = i - <span class="number">1</span>;     <span class="comment">//初始化dp值</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i - j &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; n &amp;&amp; s[i - j] == s[i + j]; j++)</div><div class="line">            cut[i + j + <span class="number">1</span>] = min(cut[i + j + <span class="number">1</span>], cut[i - j] + <span class="number">1</span>);   <span class="comment">//奇数长度的回文序列</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i - j + <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; i + j &lt; n &amp;&amp; s[i - j + <span class="number">1</span>] == s[i + j]; j++)</div><div class="line">            cut[i + j + <span class="number">1</span>] = min(cut[i + j + <span class="number">1</span>], cut[i - j + <span class="number">1</span>] + <span class="number">1</span>);   <span class="comment">//偶数长度的回文序列</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cut[n];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//法二：dp[i + 1]记录长度为i的序列的最小分割次数，isPal[i][j]表示s[i...j]是否为回文序列</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> n = s.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</div><div class="line">        dp[i] = i - <span class="number">1</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPal(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; n; right++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt;= right; left++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[left] == s[right] &amp;&amp; (right - left &lt; <span class="number">2</span> || isPal[left + <span class="number">1</span>][right - <span class="number">1</span>]))</div><div class="line">            &#123;</div><div class="line">                isPal[left][right] = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">if</span>(left == <span class="number">0</span>)</div><div class="line">                    dp[right + <span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    dp[right + <span class="number">1</span>] = min(dp[right + <span class="number">1</span>], dp[left] + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中动态规划问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>二叉树问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/02/03/data-structure-binary-tree/"/>
    <id>https://senitco.github.io/2018/02/03/data-structure-binary-tree/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中经典二叉树问题的总结归纳。<br><a id="more"></a><br>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="二叉树先序遍历"><a href="#二叉树先序遍历" class="headerlink" title="二叉树先序遍历"></a>二叉树先序遍历</h3><p>问题描述：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="external">LeetCode</a><br>分析：二叉树的遍历可通过递归法和迭代法求解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    traverse(root, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node)   <span class="keyword">return</span>;</div><div class="line">    result.push_back(node-&gt;val);</div><div class="line">    traverse(node-&gt;left, result);</div><div class="line">    traverse(node-&gt;right, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代法（一）</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(root)</div><div class="line">        &#123;</div><div class="line">            result.push_back(root-&gt;val);</div><div class="line">            toVisit.push(root); <span class="comment">//此处是进栈的时候访问结点元素值</span></div><div class="line">            root = root-&gt;left;</div><div class="line">        &#125;</div><div class="line">        root = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        root = root-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代法（二）</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> result;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    toVisit.push(root);</div><div class="line">    <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        root = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        result.push_back(root-&gt;val);    </div><div class="line">        <span class="keyword">if</span>(root-&gt;right)  <span class="comment">//注意此处要先将右子结点压入栈中，因为是出栈的时候访问结点元素值</span></div><div class="line">            toVisit.push(root-&gt;right); </div><div class="line">        <span class="keyword">if</span>(root-&gt;left)</div><div class="line">            toVisit.push(root-&gt;left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h3><p>问题描述：<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    traverse(root, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span>;</div><div class="line">    traverse(node-&gt;left, result);</div><div class="line">    result.push_back(node-&gt;val);</div><div class="line">    traverse(node-&gt;right, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代法</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodes;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(root) </div><div class="line">        &#123; </div><div class="line">            toVisit.push(root); </div><div class="line">            root = root-&gt;left; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(toVisit.empty()) <span class="keyword">break</span>;</div><div class="line">        root = toVisit.top(); </div><div class="line">        toVisit.pop();</div><div class="line">        nodes.push_back(root-&gt;val); <span class="comment">//和先序遍历不同，此处是出栈访问结点元素值</span></div><div class="line">        root = root-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nodes;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//和上述迭代法思路一致，只是将while循环替换成if条件语句</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodes;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    TreeNode* curNode = root;</div><div class="line">    <span class="keyword">while</span> (curNode || !toVisit.empty()) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (curNode) </div><div class="line">        &#123;</div><div class="line">            toVisit.push(curNode);</div><div class="line">            curNode = curNode -&gt; left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            curNode = toVisit.top();</div><div class="line">            toVisit.pop();</div><div class="line">            nodes.push_back(curNode -&gt; val);    </div><div class="line">            curNode = curNode -&gt; right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nodes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h3><p>问题描述：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    traverse(root, result);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node)    <span class="keyword">return</span>;</div><div class="line">    traverse(node-&gt;left, result);</div><div class="line">    traverse(node-&gt;right, result);</div><div class="line">    result.push_back(node-&gt;val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法：后序遍历是左-右-根，将其转换为根-右-左（实现方法和先序遍历根-左-右类似，只是左右互换），</span></div><div class="line"><span class="comment">最后将数组逆转即可</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(root)</div><div class="line">        &#123;</div><div class="line">            result.push_back(root-&gt;val);</div><div class="line">            toVisit.push(root);</div><div class="line">            root = root-&gt;right; <span class="comment">//相对先序遍历，左右子结点顺序互换</span></div><div class="line">        &#125;</div><div class="line">        root = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        root = root-&gt;left;</div><div class="line">    &#125;</div><div class="line">    reverse(result.begin(), result.end());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对应先序遍历的迭代法（二）</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> result;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    toVisit.push(root);</div><div class="line">    <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        root = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        result.push_back(root-&gt;val);</div><div class="line">        <span class="keyword">if</span>(root-&gt;left)          <span class="comment">//注意此处要先将左子结点压入栈中</span></div><div class="line">            toVisit.push(root-&gt;left);</div><div class="line">        <span class="keyword">if</span>(root-&gt;right)</div><div class="line">            toVisit.push(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">    reverse(result.begin(), result.end());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="还原二叉搜索树"><a href="#还原二叉搜索树" class="headerlink" title="还原二叉搜索树"></a>还原二叉搜索树</h3><p>问题描述：给定一颗二叉搜索树，其中两个结点互换，将其还原成一颗完整的二叉搜索树。<a href="https://leetcode.com/problems/recover-binary-search-tree/description/" target="_blank" rel="external">LeetCode</a><br>分析：对二叉搜索树进行中序遍历，即可得到一个有序的序列。对于异常点，存在前一个元素大于后一个元素，但两个异常点略有差异（第一个异常点，其值大于后一个元素；第二个异常点，其值小于前一个元素）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归法中序遍历</span></div><div class="line"></div><div class="line">TreeNode *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>; <span class="comment">//如果不定义为全局变量（或类的成员变量），而是作为形参，则应该传指针变量的引用</span></div><div class="line">TreeNode *prev = <span class="keyword">new</span> TreeNode(INT_MIN);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    inorderTraverse(root);</div><div class="line">    <span class="keyword">int</span> temp = first-&gt;val;</div><div class="line">    first-&gt;val = second-&gt;val;</div><div class="line">    second-&gt;val = temp;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraverse</span><span class="params">(TreeNode* root)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</div><div class="line">    inorderTraverse(root-&gt;left);</div><div class="line">    <span class="keyword">if</span>(first == <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">        first = prev;</div><div class="line">    <span class="keyword">if</span>(first != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">        second = root;</div><div class="line">    prev = root;</div><div class="line">    inorderTraverse(root-&gt;right);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代法中序遍历</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    TreeNode *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>;</div><div class="line">    TreeNode *prev = <span class="keyword">new</span> TreeNode(INT_MIN);</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(root)</div><div class="line">        &#123;</div><div class="line">            toVisit.push(root);</div><div class="line">            root = root-&gt;left;</div><div class="line">        &#125;</div><div class="line">        root = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        <span class="keyword">if</span>(first == <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">            first = prev;</div><div class="line">        <span class="keyword">if</span>(first != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">            second = root;</div><div class="line">        prev = root;</div><div class="line">        root = root-&gt;right;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> temp = first-&gt;val;</div><div class="line">    first-&gt;val = second-&gt;val;</div><div class="line">    second-&gt;val = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="计算二叉树根结点到叶子结点的数字和"><a href="#计算二叉树根结点到叶子结点的数字和" class="headerlink" title="计算二叉树根结点到叶子结点的数字和"></a>计算二叉树根结点到叶子结点的数字和</h3><p>问题描述：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="external">LeetCode</a><br>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.Find the total sum of all root-to-leaf numbers.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example,</span></div><div class="line"><span class="comment">    1</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  2   3</span></div><div class="line"><span class="comment">The root-to-leaf path 1-&gt;2 represents the number 12.</span></div><div class="line"><span class="comment">The root-to-leaf path 1-&gt;3 represents the number 13.</span></div><div class="line"><span class="comment">Return the sum = 12 + 13 = 25.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> sum(root, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode* node, <span class="keyword">int</span> s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">        <span class="keyword">return</span> s * <span class="number">10</span> + node-&gt;val;</div><div class="line">    <span class="keyword">return</span> sum(node-&gt;left, s * <span class="number">10</span> + node-&gt;val) + sum(node-&gt;right, s * <span class="number">10</span> + node-&gt;val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代法</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">    toVisit.push(root);</div><div class="line">    <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">    &#123;</div><div class="line">        TreeNode* cur = toVisit.top();</div><div class="line">        toVisit.pop();</div><div class="line">        <span class="keyword">if</span>(cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;right-&gt;val = cur-&gt;val * <span class="number">10</span> + cur-&gt;right-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(cur-&gt;left)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;left-&gt;val = cur-&gt;val * <span class="number">10</span> + cur-&gt;left-&gt;val;</div><div class="line">            toVisit.push(cur-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</div><div class="line">        &#123;</div><div class="line">            sum += cur-&gt;val;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="线索二叉树的构建与遍历"><a href="#线索二叉树的构建与遍历" class="headerlink" title="线索二叉树的构建与遍历"></a>线索二叉树的构建与遍历</h3><p>线索二叉树：将二叉链表中的空指针分别指向对应的前驱或后继结点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;Link, Thread&#125; PointerTag;    <span class="comment">//Link表示指向孩子结点，Thread表示指向前驱后后继线索</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    TElemType data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></div><div class="line">    PointerTag LTag, RTag;</div><div class="line">&#125;BiThrNode, *BiThrTree;</div><div class="line"></div><div class="line">BiThrTree pre;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">中序遍历建立中序线索化树链表，并增加一个头结点，令其左子域指向二叉树的根结点，</span></div><div class="line"><span class="comment">右子域指向中序遍历访问的最后一个结点。反之，令中序遍历中第一个结点的左子域</span></div><div class="line"><span class="comment">和最后一个结点的右子域均指向头结点，这样既可以从前往后遍历，也可以从最后一个</span></div><div class="line"><span class="comment">结点顺前驱进行遍历</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Status <span class="title">InorderThreading</span><span class="params">(BiThrTree&amp; Thrt, BiThrTree T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!Thrt = (BiThrTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode)))</div><div class="line">        <span class="built_in">exit</span>(OVERFLOW);</div><div class="line">    Thrt-&gt;LTag = Link;</div><div class="line">    Thrt-&gt;RTag = Thread;</div><div class="line">    Thrt-&gt;rchild = Thrt;    <span class="comment">//右指针回指</span></div><div class="line">    <span class="keyword">if</span>(!T)    </div><div class="line">        Thrt-&gt;lchild = Thrt; <span class="comment">//若二叉树空，则左指针回指</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        Thrt-&gt;lchild = T;</div><div class="line">        pre = Thrt;</div><div class="line">        InThreading(T);</div><div class="line">        pre-&gt;rchild = Thrt;    <span class="comment">//最后一个结点线索化</span></div><div class="line">        pre-&gt;RTag = Thread；</div><div class="line">        Thrt-&gt;rchild = pre;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(p)</div><div class="line">    &#123;</div><div class="line">        InThreading(p-&gt;lchild);</div><div class="line">        <span class="keyword">if</span>(!p-&gt;lchild)</div><div class="line">        &#123;</div><div class="line">            p-&gt;LTag = Thread;    <span class="comment">//前驱线索</span></div><div class="line">            p-&gt;lchild = pre;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)</div><div class="line">        &#123;</div><div class="line">            pre-&gt;RTag = Thread;    <span class="comment">//后继线索</span></div><div class="line">            pre-&gt;rchild = p;</div><div class="line">        &#125;</div><div class="line">        pre = p;    <span class="comment">//保持pre指向p的前驱</span></div><div class="line">        InThreading(p-&gt;rchild);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**中序遍历线索二叉树**/</span></div><div class="line"><span class="function">Status <span class="title">InorderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    BiThrTree p;</div><div class="line">    p = T-&gt;lchild;</div><div class="line">    <span class="keyword">while</span>(p != T)    <span class="comment">//空树或遍历结束时，p == T</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(p-&gt;LTag == Link)</div><div class="line">            p = p-&gt;lchild;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</div><div class="line">        <span class="keyword">while</span>(p-&gt;RTag == Thread &amp;&amp; p-&gt;rchild != T)</div><div class="line">        &#123;</div><div class="line">            p = p-&gt;rchild;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, p-&gt;data);</div><div class="line">        &#125;</div><div class="line">        p = p-&gt;rchild;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中经典二叉树问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="preorder" scheme="https://senitco.github.io/tags/preorder/"/>
    
      <category term="inorder" scheme="https://senitco.github.io/tags/inorder/"/>
    
      <category term="postorder" scheme="https://senitco.github.io/tags/postorder/"/>
    
  </entry>
  
  <entry>
    <title>链表问题集锦（二）</title>
    <link href="https://senitco.github.io/2018/02/02/data-structure-linkedlist-2/"/>
    <id>https://senitco.github.io/2018/02/02/data-structure-linkedlist-2/</id>
    <published>2018-02-01T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.593Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中经典链表问题总结归纳，接上一篇<a href="https://senitco.github.io/2018/02/01/data-structure-linkedlist/">链表问题集锦（一）</a><br><a id="more"></a></p>
<h3 id="单链表逆转"><a href="#单链表逆转" class="headerlink" title="单链表逆转"></a>单链表逆转</h3><p>题目描述：给定一个单链表，将其逆转。<a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="external">LeetCode</a><br>分析：迭代法求解，借助三个指针start、head、next，start指向逆转后（已重排）的第一个结点，head指向未重排的第一个结点，next指向head的下一个结点，每次将未重排的第一个结点插入到已重排序列的首部。也可利用递归法实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode *start = <span class="literal">NULL</span>, next;</div><div class="line">    <span class="keyword">while</span>(head)</div><div class="line">    &#123;</div><div class="line">        next = head-&gt;next;</div><div class="line">        head-&gt;next = start;</div><div class="line">        start = head;</div><div class="line">        head = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//增加一个头结点的迭代版本</span></div><div class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    start-&gt;next = head;</div><div class="line">    ListNode *first = head;</div><div class="line">    ListNode *second = first-&gt;next;</div><div class="line">    <span class="keyword">while</span>(second)</div><div class="line">    &#123;</div><div class="line">        first-&gt;next = second-&gt;next;</div><div class="line">        second-&gt;next = start-&gt;next;</div><div class="line">        start-&gt;next = second;</div><div class="line">        second = first-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> recursive(head, <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode* <span class="title">recursive</span><span class="params">(ListNode* head, ListNode* start)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head)   <span class="keyword">return</span> start;</div><div class="line">    ListNode* next = head-&gt;next;</div><div class="line">    head-&gt;next = start;</div><div class="line">    <span class="keyword">return</span> recursive(next, head);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//直接递归</span></div><div class="line"><span class="function">Node* <span class="title">reverseByRecursion</span><span class="params">(Node *head)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//第一个条件是判断异常，第二个条件是结束判断</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    Node *newHead = reverseByRecursion(head-&gt;next);</div><div class="line">    head-&gt;next-&gt;next = head;</div><div class="line">    head-&gt;next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">return</span> newHead;    <span class="comment">//返回新链表的头指针</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="将单链表中的某一段逆转"><a href="#将单链表中的某一段逆转" class="headerlink" title="将单链表中的某一段逆转"></a>将单链表中的某一段逆转</h3><p>问题描述：将单链表中第m到第n个结点之间的序列逆转。<a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="external">LeetCode</a><br>分析：思路和逆转整个链表一样，借助三个指针，pre指向链表中的第 m-1 个元素，begin指向第一个未逆转的元素，then指向begin的下一个元素，即即将插入到pre后面的元素，then = begin-&gt;next，依次将begin后面的元素插入到pre后面，并保证所有元素能连接成串。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);  </div><div class="line">    start-&gt;next = head;</div><div class="line">    ListNode *pre = start;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</div><div class="line">        pre = pre-&gt;next;</div><div class="line">    ListNode* begin = pre-&gt;next;</div><div class="line">    ListNode* then = begin-&gt;next;</div><div class="line">   </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++)</div><div class="line">    &#123;</div><div class="line">        begin-&gt;next = then-&gt;next;</div><div class="line">        then-&gt;next = pre-&gt;next;</div><div class="line">        pre-&gt;next = then;</div><div class="line">        then = begin-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode* cur, *nex, *tmp;</div><div class="line">    start-&gt;next = head;</div><div class="line">    cur = start;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; i &lt; m - <span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">    nex = cur-&gt;next;</div><div class="line">    <span class="keyword">for</span>(; i &lt; n - <span class="number">1</span> &amp;&amp; nex-&gt;next; i++)  <span class="comment">//i初值为 m-1，后续插入操作次数为 n-m</span></div><div class="line">    &#123;</div><div class="line">        tmp = cur-&gt;next;                <span class="comment">//暂时存储cur后面的元素</span></div><div class="line">        cur-&gt;next = nex-&gt;next;          <span class="comment">//将nex后面的元素插入到cur后</span></div><div class="line">        nex-&gt;next = nex-&gt;next-&gt;next;    <span class="comment">//取出nex的下一个元素后，nex的下一个元素变成更后面的元素</span></div><div class="line">        cur-&gt;next-&gt;next = tmp;          <span class="comment">//将插入到cur的元素与之前暂存的元素链接起来</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="将单链表进行分组逆转"><a href="#将单链表进行分组逆转" class="headerlink" title="将单链表进行分组逆转"></a>将单链表进行分组逆转</h3><p>问题描述：将单链表按顺序分成N组，每组K个元素，最后一组可能少于K个，分别将每组元素逆转，并链接成一个完整的序列。例如一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，如果k=2，则逆转后的序列为2-&gt;1-&gt;4-&gt;3-&gt;5；如果k=3，则逆转序列为3-&gt;2-&gt;1-&gt;4-&gt;5。<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="external">LeetCode</a><br>分析：分别对每组结点进行逆转，可用迭代法和递归法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**迭代法：</span></div><div class="line"><span class="comment">-1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span></div><div class="line"><span class="comment"> |    |    |     </span></div><div class="line"><span class="comment">pre  cur  nex  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">-1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 -&gt; 5</span></div><div class="line"><span class="comment"> |         |    |     </span></div><div class="line"><span class="comment">pre       cur  nex  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">-1 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; 4 -&gt; 5</span></div><div class="line"><span class="comment"> |              |    |    </span></div><div class="line"><span class="comment">pre            cur  nex </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">三个重要指针，头指针pre，始终指向已重新排列的第一个元素；当前指针cur，指向已排序的最后一个元素；</span></div><div class="line"><span class="comment">cur-&gt;next则指向未排序的第一个元素也就是nex指针，nex的作用是即将作为第一个元素赋给pre-&gt;next.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || k == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">    ListNode* preheader = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode *pre, *nex, *cur;</div><div class="line">    preheader-&gt;next = head;</div><div class="line">    cur = pre = preheader;</div><div class="line">    <span class="keyword">while</span>(cur = cur-&gt;next)</div><div class="line">        num++;</div><div class="line">    <span class="keyword">while</span>(num &gt;= k)</div><div class="line">    &#123;</div><div class="line">        cur = pre-&gt;next;</div><div class="line">        nex = cur-&gt;next;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</div><div class="line">        &#123;</div><div class="line">            cur-&gt;next = nex-&gt;next;</div><div class="line">            nex-&gt;next = pre-&gt;next;</div><div class="line">            pre-&gt;next = nex;</div><div class="line">            nex = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">        pre = cur;</div><div class="line">        num -= k;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> preheader-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**递归法：</span></div><div class="line"><span class="comment">head：指向正序起始节点</span></div><div class="line"><span class="comment">curr：指向反转后的起始节点</span></div><div class="line"><span class="comment">tmp：head-&gt;next，用于保存下一个插入反转序列的节点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode* curr = head;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (curr != <span class="literal">nullptr</span> &amp;&amp; count != k) &#123; <span class="comment">// find the k+1 node</span></div><div class="line">        curr = curr-&gt;next;</div><div class="line">        count++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (count == k) &#123; <span class="comment">// if k+1 node is found</span></div><div class="line">        curr = reverseKGroup(curr, k); <span class="comment">// reverse list with k+1 node as head</span></div><div class="line">        <span class="comment">// head - head-pointer to direct part, </span></div><div class="line">        <span class="comment">// curr - head-pointer to reversed part;</span></div><div class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123; <span class="comment">// reverse current k-group: </span></div><div class="line">            ListNode* tmp = head-&gt;next; <span class="comment">// tmp - next head in direct part</span></div><div class="line">            head-&gt;next = curr; <span class="comment">// preappending "direct" head to the reversed list </span></div><div class="line">            curr = head; <span class="comment">// move head of reversed part to a new node</span></div><div class="line">            head = tmp; <span class="comment">// move "direct" head to the next node in direct part</span></div><div class="line">        &#125;</div><div class="line">        head = curr;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="将单链表的结点两两交换"><a href="#将单链表的结点两两交换" class="headerlink" title="将单链表的结点两两交换"></a>将单链表的结点两两交换</h3><p>题目描述：给定一个单链表，将相邻两个结点两两交换。例如链表：1-&gt;2-&gt;3-&gt;4, 交换后的序列为2-&gt;1-&gt;4-&gt;3。<a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历元素，两两交换</span></div><div class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    start-&gt;next = head;</div><div class="line">    ListNode* current = start;</div><div class="line">    ListNode *first, *second;</div><div class="line">    <span class="keyword">while</span>(current-&gt;next &amp;&amp; current-&gt;next-&gt;next)</div><div class="line">    &#123;</div><div class="line">        first = current-&gt;next;</div><div class="line">        second = first-&gt;next;</div><div class="line">        first-&gt;next = second-&gt;next;</div><div class="line">        current-&gt;next = second;</div><div class="line">        second-&gt;next = first;</div><div class="line">        current = current-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    ListNode* pNode = head-&gt;next;</div><div class="line">    head-&gt;next = swapPairs(head-&gt;next-&gt;next);</div><div class="line">    pNode-&gt;next = head;</div><div class="line">    <span class="keyword">return</span> pNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//二级指针</span></div><div class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode **pp = &amp;head, *a, *b;</div><div class="line">    <span class="keyword">while</span> ((a = *pp) &amp;&amp; (b = a-&gt;next)) </div><div class="line">    &#123;</div><div class="line">        a-&gt;next = b-&gt;next;</div><div class="line">        b-&gt;next = a;</div><div class="line">        *pp = b;    <span class="comment">//改变指针指指向的地址</span></div><div class="line">        pp = &amp;(a-&gt;next);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="按特定序列将单链表重排"><a href="#按特定序列将单链表重排" class="headerlink" title="按特定序列将单链表重排"></a>按特定序列将单链表重排</h3><p>问题描述：Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…<br>You must do this in-place without altering the nodes’ values.<br>For example, Given {1,2,3,4}, reorder it to {1,4,2,3}.<a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="external">LeetCode</a><br>分析：分三步走：<br>(1)找到链表的中点位置middle=(len-1)/2<br>(2)将后半部分（middle之后的元素）链表逆转<br>(3)同时遍历两部分链表元素，依次将后半部分元素插入到前半部分的相应位置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    ListNode *p1, *p2;</div><div class="line">    p1 = p2 = head;</div><div class="line">    <span class="comment">//Find the middle of the list, 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6, middle point to 3</span></div><div class="line">    <span class="keyword">while</span>(p2-&gt;next &amp;&amp; p2-&gt;next-&gt;next)</div><div class="line">    &#123;</div><div class="line">        p1 = p1-&gt;next;</div><div class="line">        p2 = p2-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//Reverse the half after middle  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 to 1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4</span></div><div class="line">    ListNode *middle = p1, *prev = p1-&gt;next, *cur;</div><div class="line">    <span class="keyword">while</span>(prev-&gt;next)</div><div class="line">    &#123;</div><div class="line">        cur = prev-&gt;next;</div><div class="line">        prev-&gt;next = cur-&gt;next;</div><div class="line">        cur-&gt;next = middle-&gt;next;</div><div class="line">        middle-&gt;next = cur;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//Start reorder one by one  1-&gt;2-&gt;3-&gt;6-&gt;5-&gt;4 to 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4</span></div><div class="line">    p1 = head;</div><div class="line">    p2 = middle-&gt;next;</div><div class="line">    <span class="keyword">while</span>(p1 != middle)</div><div class="line">    &#123;</div><div class="line">        middle-&gt;next = p2-&gt;next;</div><div class="line">        p2-&gt;next = p1-&gt;next;</div><div class="line">        p1-&gt;next = p2;</div><div class="line">        p1 = p2-&gt;next;</div><div class="line">        p2 = middle-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>问题描述：将两个有序链表合并成一个新的有序链表。<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//迭代法</span></div><div class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode *pNode = start;</div><div class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</div><div class="line">        &#123;</div><div class="line">            pNode-&gt;next = l2;</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            pNode-&gt;next = l1;</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">        &#125;</div><div class="line">        pNode = pNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(l1)  </div><div class="line">        pNode-&gt;next = l1;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        pNode-&gt;next = l2;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//递归法</span></div><div class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</div><div class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) </div><div class="line">    &#123;</div><div class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</div><div class="line">        <span class="keyword">return</span> l1;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</div><div class="line">        <span class="keyword">return</span> l2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="合并K个有序链表"><a href="#合并K个有序链表" class="headerlink" title="合并K个有序链表"></a>合并K个有序链表</h3><p>问题描述：<a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">法一：与合并两个有序列表的思想一致，每次比较 K 个节点，取其最小值；在遍历过程中，</span></div><div class="line"><span class="comment">若有列表已到达末尾节点，则将该列表从vector中移除</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (lists.empty())</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; pl;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists)</div><div class="line">        pl.push_back(node);</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode* pNode = start;</div><div class="line">    <span class="keyword">int</span> value = INT_MAX, index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = pl.begin(); iter != pl.end();)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (!(*iter))</div><div class="line">            &#123;</div><div class="line">                iter = pl.erase(iter);  <span class="comment">//注意erase()可能会造成后面的迭代器失效</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                iter++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pl.empty())</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        value = INT_MAX;</div><div class="line">        index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pl.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (pl[i]-&gt;val &lt; value)</div><div class="line">            &#123;</div><div class="line">                value = pl[i]-&gt;val;</div><div class="line">                index = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        pNode-&gt;next = pl[index];</div><div class="line">        pl[index] = pl[index]-&gt;next;</div><div class="line">        pNode = pNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//法二：借助优先队列实现</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (lists.empty())</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;     </div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode* pNode = start;</div><div class="line">    priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pql;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists)</div><div class="line">        <span class="keyword">if</span>(node)            <span class="comment">//注意此处要判断节点(链表)是否为空</span></div><div class="line">            pql.push(node);</div><div class="line">    <span class="keyword">while</span>(!pql.empty())</div><div class="line">    &#123;</div><div class="line">        pNode-&gt;next = pql.top();</div><div class="line">        pql.pop();</div><div class="line">        pNode = pNode-&gt;next;</div><div class="line">        <span class="keyword">if</span>(pNode-&gt;next != <span class="literal">NULL</span>)</div><div class="line">            pql.push(pNode-&gt;next);</div><div class="line">    &#125;     </div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//法三：递归求解，将有序列表两两合并</span></div><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(lists.empty())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;    </div><div class="line">        lists.push_back(mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>])); <span class="comment">//mergeTwoLists()见上</span></div><div class="line">        lists.erase(lists.begin());</div><div class="line">        lists.erase(lists.begin());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lists.front();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中经典链表问题总结归纳，接上一篇&lt;a href=&quot;https://senitco.github.io/2018/02/01/data-structure-linkedlist/&quot;&gt;链表问题集锦（一）&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>链表问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/02/01/data-structure-linkedlist/"/>
    <id>https://senitco.github.io/2018/02/01/data-structure-linkedlist/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.593Z</updated>
    
    <content type="html"><![CDATA[<p>将数据结构中一些经典的链表问题做一个总结归纳。<br><a id="more"></a></p>
<p>单链表结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode *next;</div><div class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="在O-1-时间内删除指定链表结点"><a href="#在O-1-时间内删除指定链表结点" class="headerlink" title="在O(1)时间内删除指定链表结点"></a>在O(1)时间内删除指定链表结点</h3><p>题目描述：给定链表的头指针和一个结点指针，在O(1)时间内删除该结点。<br>分析：一般做法是借助两个指针p1、p2（一前一后），从头开始遍历，直到后一个指针p2和待删除结点相同，然后使p1-&gt;next=p2-&gt;next，并释放掉p2结点。但此处强调是O(1)时间，因此可直接将待删除结点p的值替换为下一个结点的值，并使p-&gt;next=p-&gt;next-&gt;next，并删除下一个结点。当然前提是待删除结点不能是尾结点，即其下一个结点不能为空。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!node || !node-&gt;next)</div><div class="line">    	<span class="keyword">return</span>;</div><div class="line">    ListNode* pNext = node-&gt;next;</div><div class="line">    node-&gt;val = pNext-&gt;val;</div><div class="line">    node-&gt;next = pNext-&gt;next;</div><div class="line">    <span class="keyword">delete</span> pNext;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="求链表倒数第k个结点"><a href="#求链表倒数第k个结点" class="headerlink" title="求链表倒数第k个结点"></a>求链表倒数第k个结点</h3><p>题目描述：给定一个单链表，找到倒数第k个结点（或移除该结点），例如链表 1-&gt;2-&gt;3-&gt;4-&gt;5，k = 2，则倒数第k个结点值为4，移除该结点后，链表为1-&gt;2-&gt;3-&gt;5。<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="external">LeetCode</a><br>分析：借助快慢两个指针fast、slow，首先fast先正向移动到第n个结点，然后两个指针同步移动，直至fast指针为空（走到链表末尾），此时slow指针所指向的即是倒数第k个结点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找到倒数第n个结点</span></div><div class="line"><span class="function">ListNode* <span class="title">findNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode *slow = head, *fast = head;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; fast; i++)</div><div class="line">    &#123;</div><div class="line">    	fast = fast-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; n)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(fast)</div><div class="line">    &#123;</div><div class="line">    	slow = slow-&gt;next;</div><div class="line">    	fast = fast-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//删除倒数第n个结点</span></div><div class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);	<span class="comment">//加一个起始（首）结点可有效解决只有一个元素的情况</span></div><div class="line">    ListNode *front = start, *back = start;</div><div class="line">    back-&gt;next = head;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span> &amp;&amp; front; i++)</div><div class="line">    &#123;</div><div class="line">        front = front-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(i &lt; n + <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(front)</div><div class="line">    &#123;</div><div class="line">        front = front-&gt;next;</div><div class="line">        back = back-&gt;next;</div><div class="line">    &#125;</div><div class="line">    front = back-&gt;next;</div><div class="line">    back-&gt;next = back-&gt;next-&gt;next;</div><div class="line">    <span class="built_in">free</span>(front);</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h3><p>题目描述：求链表的中间结点，如果链表长度为奇数，则返回中间结点；若为偶数，则返回中间两个结点中的任意一个。<br>分析：一般思路是先完整遍历一次链表，求得整个链表的长度，然后长度取半，再从头开始移动指针，即可定位到中间结点。如果只允许遍历一次链表的话，可通过两个指针完成，两个指针均从头部结点开始，一个每次移动一步，另一个每次移动两步，这样快指针走到链表末尾时，慢指针刚好指向中间结点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">findMiddleNode</span><span class="params">(ListNode* head)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode *slow = head, *fast = head;</div><div class="line">    <span class="comment">//while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)	//对于链表长度为偶数的情况，返回中间两个结点中的第一个</span></div><div class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)	<span class="comment">//对于链表长度为偶数的情况，返回中间两个结点中的第二个</span></div><div class="line">    &#123;</div><div class="line">    	fast = fast-&gt;next-&gt;next;</div><div class="line">    	slow = slow-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> slow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="判断单链表是否存在环"><a href="#判断单链表是否存在环" class="headerlink" title="判断单链表是否存在环"></a>判断单链表是否存在环</h3><p>题目描述：输入一个单链表，判断链表是否存在环。<a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="external">LeetCode</a><br>分析：借助两个指针，分别从头结点出发，一个指针每次移动一个步长，另一个指针每次移动两个步长，如果存在环，则两个指针必在环内相遇。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ListNode *p1, *p2;</div><div class="line">    p1 = p2 = head;</div><div class="line">    <span class="keyword">while</span>(p2 &amp;&amp; p2-&gt;next)</div><div class="line">    &#123;</div><div class="line">        p1 = p1-&gt;next;</div><div class="line">        p2 = p2-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">if</span>(p1 == p2)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="找到单链表成环的入口点"><a href="#找到单链表成环的入口点" class="headerlink" title="找到单链表成环的入口点"></a>找到单链表成环的入口点</h3><p>题目描述，如果单链表存在环，则找到环的入口点，若不存在，则返回NULL。<a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="external">LeetCode</a><br>分析：借助两个指针，分别从头结点出发，一个指针每次移动一个步长，另一个指针每次移动两个步长，如果存在环，则两个指针必在环内相遇。然后一个指针指向链表头结点，另一个指针仍位于相遇点，两个指针均以单步长移动，再次相遇点即为环的起始点。设第一次相遇点距离链表起点为k，环起始点距离链表起点为s，环起始点到第一次相遇点距离为m，环长度为r，则有k = s + m, 且2k - k = nr = k, 即 s = nr - m。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode *p1, *p2;</div><div class="line">    p1 = p2 = head;</div><div class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(p2 &amp;&amp; p2-&gt;next)</div><div class="line">    &#123;</div><div class="line">        p1 = p1-&gt;next;</div><div class="line">        p2 = p2-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">if</span>(p1 == p2)  </div><div class="line">        &#123;</div><div class="line">            flag = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!flag)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    </div><div class="line">    p1 = head;</div><div class="line">    <span class="keyword">while</span>(p1 != p2)</div><div class="line">    &#123;</div><div class="line">        p1 = p1-&gt;next;</div><div class="line">        p2 = p2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h3><p>题目描述：给定两个单链表（不带环），判断是否相交</p>
<p><img src="https://i.loli.net/2018/02/02/5a73c7fb34565.jpg" alt="linkedlist.jpg"></p>
<p>分析：<br>1.使用两重循环判断一个链表的某个结点是否在另一个链表中，时间复杂度为O(n*m)<br>2.针对第一个链表构造hash表，然后遍历第二个链表，判断第二个链表是否有结点在hash表中，时间复杂度为O(n+m)，空间复杂度为O(n)<br>3.转换为环的问题：把第二个链表连接到第一个链表后面，如果得到的链表有环，则说明两链表相交，判断是否有环可借助上面的方法。这里可使用更简单的方法，如果有环，则第二个链表的表头也在环上，即构成一个循环链表，因此只需要遍历第二个链表，看是否回到起始点即可判断，时间复杂度为线性，空间复杂度为O(1)<br>4.如果两个没有环的链表相交于一点，那这个结点之后的所有结点都是共有的，包括最后一个结点，因此只需要分别遍历两个链表至最后一个结点，判断是否相等，即可确定两链表是否相交，时间复杂度为线性，空间复杂度为O(1)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersectOfTwoLinkedList</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head1 || !head2)	</div><div class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(head1-&gt;next)</div><div class="line">    	head1 = head1-&gt;next;</div><div class="line">    <span class="keyword">while</span>(head2-&gt;next)</div><div class="line">    	head2 = head2-&gt;next;</div><div class="line">    <span class="keyword">if</span>(head1 == head2)</div><div class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="两链表相交的第一个公共结点"><a href="#两链表相交的第一个公共结点" class="headerlink" title="两链表相交的第一个公共结点"></a>两链表相交的第一个公共结点</h3><p>题目描述：如果两个无环单链表相交，求出相交结点<br>分析：采用对齐的思想，分别遍历两个链表，得到其长度L1、L2，采用两个指针分别指向两个链表的头部，然后将较长链表的指针移动L2-L1个结点（假设L2&gt;L1），再同时向后移动两指针，直到两指针相等即为相交结点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">findIntersectNode</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</div><div class="line">    ListNode *pNode1 = head1, *pNode2 = head2;</div><div class="line">    <span class="keyword">while</span>(pNode1)</div><div class="line">    &#123;</div><div class="line">    	len1++;</div><div class="line">    	pNode1 = pNode1-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(pNode2)</div><div class="line">    &#123;</div><div class="line">    	len2++;</div><div class="line">    	pNode2 = pNode2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    pNode1 = head1;</div><div class="line">    pNode2 = head2;</div><div class="line">    <span class="keyword">if</span>(len1 &gt; len2)</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1 - len2; i++)</div><div class="line">    	   pNode1 = pNode1-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2 - len1; i++)</div><div class="line">    	   pNode2 = pnode2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(pNode1)</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">if</span>(pNode1 == pNode2)</div><div class="line">    	   <span class="keyword">return</span> pNode1;</div><div class="line">    	pNode1 = pNode1-&gt;next;</div><div class="line">    	pNode2 = pNode2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如果两链表有环，判断是否相交"><a href="#如果两链表有环，判断是否相交" class="headerlink" title="如果两链表有环，判断是否相交"></a>如果两链表有环，判断是否相交</h3><p>分析：如果两个链表有环且相交，则两个链表共有一个环，即环上的任意一个结点都存在与两个链表上，因此只需要判断一个链表的环起始点是否在另外一个链表（的环）上。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    ListNode *p1, *p2;</div><div class="line">    p1 = p2 = head;</div><div class="line">    <span class="keyword">while</span>(p2 &amp;&amp; p2-&gt;next)</div><div class="line">    &#123;</div><div class="line">        p1 = p1-&gt;next;</div><div class="line">        p2 = p2-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">if</span>(p1 == p2)  </div><div class="line">            <span class="keyword">return</span> p1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersectWithLoop</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode *pNode1, *pNode2;</div><div class="line">    pNode1 = hasCycle(head1);</div><div class="line">    pNode2 = hasCycle(head2);</div><div class="line">    <span class="keyword">if</span>(!pNode1 || !pNode2)</div><div class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span>(pNode1 == pNode2)</div><div class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    ListNode* pNode = pNode2-&gt;next;</div><div class="line">    <span class="keyword">while</span>(pNode != pNode2)</div><div class="line">    &#123;</div><div class="line">    	<span class="keyword">if</span>(pNode == pNode1)</div><div class="line">    	   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    	pNode = pNode-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将数据结构中一些经典的链表问题做一个总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>C++智能指针</title>
    <link href="https://senitco.github.io/2017/10/10/cplusplus-smart-pointer/"/>
    <id>https://senitco.github.io/2017/10/10/cplusplus-smart-pointer/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2018-03-20T04:42:28.029Z</updated>
    
    <content type="html"><![CDATA[<p>C++中智能指针（auto_ptr、unique_ptr、shared_ptr）的简单总结。<br><a id="more"></a></p>
<h3 id="智能指针的设计思想"><a href="#智能指针的设计思想" class="headerlink" title="智能指针的设计思想"></a>智能指针的设计思想</h3><pre><code>先看一个简单的例子：
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> * ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str);</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (weird_thing())</div><div class="line">        <span class="keyword">throw</span> exception();</div><div class="line">    str = *ps; </div><div class="line">    <span class="keyword">delete</span> ps;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露。如何避免这种问题？直接在throw exception();之前加上delete ps;。这样确实可行，但更多时候开发者都会忘记在适当的地方加上delete语句。换个角度想，如果func()函数终止（不管是正常终止还是异常终止），局部变量都会自动从栈内存中删除，因此指针ps占据的内存将被释放，如果ps指向的内存也能被自动释放，这样就不会出现内存泄漏的问题，析构函数确实有这个功能，如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但是问题在于ps只是一个常规指针，不是有析构凼数的类对象指针。因此引出了智能指针的设计思想：将常规指针封装成类（类模板，以适应不同类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。这样就无需程序员显式调用delete语句释放内存，也不会因为程序异常退出导致内存泄漏。</p>
<h3 id="智能指针的简单介绍"><a href="#智能指针的简单介绍" class="headerlink" title="智能指针的简单介绍"></a>智能指针的简单介绍</h3><p>&emsp;&emsp;C++一共提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr（此处只介绍前三种）。auto_ptr是C++98提供的解决方案，C+11已将将其摒弃，并提供了另外两种解决方案。然而，虽然auto_ptr被摒弃，但已使用了多年：同时，如果你所用的编译器不支持其他两种解决力案，auto_ptr将是唯一的选择。</p>
<ul>
<li><p>所有的智能指针都有一个explicit构造函数，以指针作为参数，因此不能自动将指针转换为智能指针对象，必须显示调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pd; </div><div class="line"><span class="keyword">double</span> *p_reg = <span class="keyword">new</span> <span class="keyword">double</span>;</div><div class="line">pd = p_reg;                               <span class="comment">// not allowed (implicit conversion)</span></div><div class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt;(p_reg);           <span class="comment">// allowed (explicit conversion)</span></div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared = p_reg;       <span class="comment">// not allowed (implicit conversion)</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared(p_reg);        <span class="comment">// allowed (explicit conversion)</span></div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; ps = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>);   <span class="comment">// not allowed (implicit conversion)</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; ps(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>));    <span class="comment">// allowed (explicit conversion)</span></div></pre></td></tr></table></figure>
</li>
<li><p>应避免将存储在栈区的普通变量或对象的地址作为智能指针的初始化参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> number = <span class="number">10</span>;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; pvac(&amp;number);   <span class="comment">// pvac过期时，程序将把delete运算符用于非堆内存，这是错误的</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>&emsp;&emsp;对于下面的赋值语句，可以看出，两个常规指针指向同一个对象，这样会导致错误的结果，因为程序试图销毁同一个对象两次，除非程序员特别注意只delete一个指针，但这个过程是不可控的，也应尽量避免在程序中留下这种隐患。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> *p1 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello World!"</span>);</div><div class="line"><span class="built_in">string</span> *p2 = p1;</div><div class="line">...</div><div class="line"><span class="keyword">delete</span> p1;</div><div class="line"><span class="keyword">delete</span> p2;</div></pre></td></tr></table></figure></p>
<p>要避免这种问题，有多种方法：</p>
<ul>
<li>在复制指针的时候采用深拷贝。这样两个指针将指向不同的对象，其中一个对象时另一个对象的副本。缺点时浪费空间，所有智能指针都未采用此方案。</li>
<li>建立所有权概念。对于特定的对象，只有一个智能指针可拥有，在进行复制操作时，会转让对象的所有权，这样只有拥有该对象的智能指针在生命周期结束时会自动销毁对象。这就是auto_ptr和unique_ptr的策略，但unique_ptr的策略更严格。</li>
<li>创建智能程度更高的指针，跟踪引用（指向）特定对象的智能指针数，称为引用计数。例如赋值时引用计数加一，而指针过期时计数减一，当减为0时才调用delete。这时shared_ptr采用的策略。</li>
</ul>
<p>同样的策略适用于复制运算符（重载）和复制构造函数。但是auto_ptr存在一定的弊端，这也是在后面的版本中将其摒弃的原因。举个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;	//包含智能指针的头文件</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; str[<span class="number">5</span>] = &#123;</div><div class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"What"</span>));</div><div class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Why"</span>));</div><div class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Where"</span>));</div><div class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"when"</span>));</div><div class="line">		<span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"How"</span>));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">	s = str[<span class="number">2</span>];	<span class="comment">//str[2]所指对象的所有权转让给了s</span></div><div class="line">	<span class="keyword">if</span>(str[<span class="number">2</span>].get() == <span class="literal">NULL</span>)	<span class="comment">//此处判断条件为真</span></div><div class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"The pointer is null!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; *str[i]&lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面程序运行会崩溃，因为str[2]转让所有权后（对应的裸指针）变成空指针了，因此输出访问空指针必然会崩溃。如果将auto_ptr换成shared_ptr或unique_ptr后，程序不会崩溃。</p>
<ul>
<li>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，s与str[2]指向同一块内存，同一个对象，在释放空间时会先判断引用计数值的大小，不会出现多次删除同一个对象的情况。</li>
<li>使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique时，程序不会等待运行阶段崩溃，而会在编译期就报错。<br>之所以要摒弃auto_ptr，就是要避免潜在的内存崩溃问题。</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>&emsp;&emsp;unique_ptr和auto_ptr一样，一个对象只能被一个智能指针所占有，这样可防止多个指针试图销毁销毁同一个对象。但在进行复制操作后，auto_ptr可能存在潜在的内存崩溃问题，如果访问失去对象所有权的指针的话，而unique_ptr则会在编译期提前报错。此外，unique_ptr还有其他优势，例如下面的例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; func(<span class="keyword">const</span> <span class="keyword">char</span>* s)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; temp(<span class="keyword">new</span> <span class="built_in">string</span>(s));</div><div class="line">	<span class="keyword">return</span> temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps = func(<span class="string">"Hello World"</span>);</div></pre></td></tr></table></figure></p>
<p>func()返回一个临时的unique_ptr，ps接管了临时unique_ptr所指的对象，而返回时该临时unique_ptr被销毁，也就是说后面没有机会通过该指针来访问无效的数据。也就是说这种赋值是没有问题的，实际上，编译器也允许unique_ptr的这种赋值。<br>简单总结，当程序试图将一个unique_ptr赋值给另一个时，如果源unique_ptr是个临时右值，编译器运行这么做；如果源unique_ptr将存在一段时间，编译器将禁止这种做法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello World"</span>));	</div><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps2 = ps1;	<span class="comment">//调用拷贝构造函数 #1 not allowed</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">unique_ptr&lt;string&gt; ps2;</span></div><div class="line"><span class="comment">ps2 = ps1；	//赋值运算符重载（operator=）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps3;		<span class="comment">//调用默认（无参）构造函数</span></div><div class="line">ps3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello World"</span>));	<span class="comment">//先调用有参构造函数创建临时对象，再调用赋值运算符	#2 allowed</span></div></pre></td></tr></table></figure></p>
<p>前面已经提到，第一种情况#1编译器是会报错的，转让对象所有权留下了空指针，而第二种情况#2是先创建可一个unique_ptr临时对象，然后将所指对象的所有权转让给ps3。这种随情况而异的行为表明，unique_ptr从安全性和实用性方面都优于auto_ptr。<br>如果想对unique_ptr对象执行普通的赋值操作，可借助移动语义实现（将左值转换为右值，std::move()）,能够直接将一个unique_ptr赋给另一个，使用move()后，原来的指针转让所有权成为空指针，可对其重新赋值后再使用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps1 = unique&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello World!"</span>));	<span class="comment">//等价于unique_ptr&lt;string&gt; ps1(new string("Hello world!"))，直接调用有参构造函数</span></div><div class="line">uinque_ptr&lt;<span class="built_in">string</span>&gt; ps2 = <span class="built_in">std</span>::move(ps1)</div><div class="line"><span class="keyword">if</span>(ps == <span class="literal">NULL</span>)	<span class="comment">//此处判断条件为真，与auto_ptr必须通过get()成员函数返回指针略有不同，ps可直接和指针进行比较（应该是重载了operator==），也可通过get()函数返回指针</span></div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The pointer is null!"</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>&emsp;&emsp;shared_ptr是通过引用计数来共享同一个对象的智能指针，也就是说多个shared_ptr指针可指向同一个对象，通过引用计数的方式可避免多次释放内存。但在使用shared_ptr指针时也存在一些陷阱。见下面例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #1 正确用法</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ps1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ps2 = ps1;</div><div class="line"></div><div class="line"><span class="comment">// #2 错误用法</span></div><div class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ps3(p);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ps4(p);</div></pre></td></tr></table></figure></p>
<p>第一个例子中是两个shared_ptr指针共享一个对象，ps1和ps2是有关联的，引用计数为2，最后一个负责释放new的变量；第二个例子中是两个独立的shared_ptr指针指向了同一个对象，ps3和ps4是没有关联的，他们并不知道对方的存在，因此会争相去释放p指针，导致重复释放。一个裸指针只能用来初始化一个shared_ptr指针，如果要让对象在多个指针间共享，需通过shared_ptr指针之间的拷贝，而不能直接拷贝原始指针。<br>&emsp;&emsp;使用智能指针难以避免的场景之一就是需要把 this 当成一个 shared_ptr 传递到其他函数中去，不能简单粗暴的用 this 指针构造一个 shared_ptr，因为那样做会导致两个独立的 shared_ptr 指向同一份内存资源，就像第二个例子那样<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; GetPtr() </div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">this</span>); <span class="comment">// 错误</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">auto</span> widget = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;();</div><div class="line">	widget-&gt;GetPtr();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正确的做法是继承模板类 std::enable_shared_from_this，然后调用它的 shared_from_this 成员函数，这种把自己作为基类的模板参数的做法称为——奇异递归模板模式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt; </div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; GetPtr()</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> shared_from_this();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">auto</span> widget = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;();</div><div class="line">	widget-&gt;GetPtr();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在裸指针被初始化给多个shared_ptr的异常场景下，shared_from_this返回的对象将会增加哪个shared_ptr的引用计数呢？ 对于这种未定义的行为通常答案是由编译器决定。可以看出裸指针通过shared_from_this返回的对象与最近一个初始化的share_ptr相关联。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Widget&gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; xxx()</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> shared_from_this();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	Widget *p = <span class="keyword">new</span> Widget();</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; one1(p);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; one2(one1);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; one3(one1);</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; one1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//3</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; one2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//3</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; one3.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//3</span></div><div class="line"></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; two1(p);    <span class="comment">//这种用一个裸指针初始化多个shared_ptr指针的行为实际上是不允许的</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; two1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//1</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; guess = p-&gt;xxx();</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; one1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//3</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; two1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; guess.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// crash at end</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="如何选择智能指针"><a href="#如何选择智能指针" class="headerlink" title="如何选择智能指针"></a>如何选择智能指针</h3><ul>
<li>如果程序要使用多个指向同一个对象的指针，应该选择shared_ptr。例如STL容器中包含指针，很多STL算法都只会复制和赋值操作，这些操作可用于shared_ptr，而不能用于unique_ptr（编译器warning警告）和auto_ptr（行为不确定）。</li>
<li>如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr，可省去显式调用delete销毁对象的过程；而且unique_ptr可通过传引用的方式作为函数的参数，传值则不允许。</li>
<li>尽量不要使用auto_ptr指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; make_int(<span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(n));	</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;p)</span>	<span class="comment">//形参为引用是允许的，传值则不允许</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *a &lt;&lt; <span class="string">' '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; vp(size);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vp.size(); i++)</div><div class="line">        vp[i] = make_int(rand() % <span class="number">1000</span>);       <span class="comment">// copy temporary unique_ptr</span></div><div class="line">    vp.push_back(make_int(rand() % <span class="number">1000</span>));     <span class="comment">// ok because arg is temporary</span></div><div class="line">    for_each(vp.begin(), vp.end(), show);      <span class="comment">// use for_each()</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化p，而这是不允许的，编译器会报错。</p>
<p>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给另一个需要满足的条件相同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(make_int(rand() % <span class="number">1000</span>));   <span class="comment">// ok</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(p1);                        <span class="comment">// not allowed, p1 as lvalue</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3(make_int(rand() % <span class="number">1000</span>));   <span class="comment">// ok</span></div></pre></td></tr></table></figure></p>
<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="http://yizhi.ren/2016/11/14/sharedptr/" target="_blank" rel="external">http://yizhi.ren/2016/11/14/sharedptr/</a></li>
<li><a href="http://blog.guorongfei.com/2017/01/25/enbale-shared-from-this-implementaion/" target="_blank" rel="external">http://blog.guorongfei.com/2017/01/25/enbale-shared-from-this-implementaion/</a></li>
<li><a href="http://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="external">http://www.cnblogs.com/lanxuezaipiao/p/4132096.html</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++中智能指针（auto_ptr、unique_ptr、shared_ptr）的简单总结。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="https://senitco.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://senitco.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning -- Optimization</title>
    <link href="https://senitco.github.io/2017/09/15/deep-learning-optimization/"/>
    <id>https://senitco.github.io/2017/09/15/deep-learning-optimization/</id>
    <published>2017-09-14T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.593Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在机器学习中，模型优化通常会定义一个代价函数(Loss Function)，然后通过最小化代价函数，求得一组参数，例如Logistic Regression、SVM以及神经网络等都属于这类问题，而这类模型往往使用迭代法求解，其中梯度下降法(Gradient Descent)应用最为广泛。<br><a id="more"></a></p>
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h3 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h3><p>&emsp;&emsp;由一组模型参数$\theta$定义的目标函数$J(\theta)$，梯度下降法通过计算目标函数对所有参数的梯度$\nabla _{\theta}J(\theta)$，然后往梯度相反的方向更新参数，使得目标函数逐步下降，最终趋于（局部）极小值。<br>$$\theta = \theta - \eta \cdot \nabla_\theta J( \theta)$$<br>学习率$\eta$决定每次更新的步长。梯度下降法有三种变体：Batch gradient descent、Stochastic gradient descent、Mini-batch gradient descent。不同之处在于每次迭代训练使用的样本数。</p>
<h4 id="Batch-Gradient-Descent"><a href="#Batch-Gradient-Descent" class="headerlink" title="Batch Gradient Descent"></a>Batch Gradient Descent</h4><p>&emsp;&emsp;BGD每次迭代计算所有训练样本的代价函数（均值），并求其梯度用于更新参数，这种方法在较小的学习率下能够保证收敛到全局最小（凸函数）或者局部最小（非凸函数）。但每次更新参数需要计算整个训练集的梯度，造成训练缓慢；样本数据较多的情况下无法全部放入内存；并且不能在线(Online)更新。</p>
<h4 id="Stochastic-Gradient-Descent"><a href="#Stochastic-Gradient-Descent" class="headerlink" title="Stochastic Gradient Descent"></a>Stochastic Gradient Descent</h4><p>&emsp;&emsp;SGD和BGD相反，每次迭代训练只计算一个样本的梯度，对参数进行更新。相比于Batch gradient descent对大数据集执行冗余计算，每次更新参数之前都要重复计算相似样本的梯度，SGD通过每次计算单个样本可以消除这种冗余，参数更新较快，可用于在线学习。而且SGD在迭代的过程中波动较大，可能从一个局部最优跳到另一个更好的局部最优，甚至是全局最优。但SGD没法利用矩阵运算加速计算过程。</p>
<h4 id="Mini-batch-Gradient-Descent"><a href="#Mini-batch-Gradient-Descent" class="headerlink" title="Mini-batch Gradient Descent"></a>Mini-batch Gradient Descent</h4><p>&emsp;&emsp;Mini-batch Gradient Descent相当于是BGD和SGD的折衷，每次迭代训练从数据集中选取一部分样本(minibatch)计算梯度值。这种方法减少了参数更新时的波动，使代价函数整体上呈下降趋势，达到了平稳收敛的效果；而且可以有效利用矩阵计算工具加速训练，通常minibatch的取值范围为[50, 256]。由于minibatch的方法使用较为广泛，因此现在的SGD一般是指Mini-batch Gradient Descent。</p>
<h4 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h4><p>&emsp;&emsp;上述几种梯度下降法并不能保证模型达到最优的效果，还有一些比较有挑战性的问题需要解决：</p>
<ul>
<li>选取合适的学习率是困难的。学习率较小导致训练缓慢；学习率较大造成收敛困难，代价函数在最小值附近波动甚至发散</li>
<li>通过Schedule的方式在训练过程中调整学习率，例如迭代到一定次数后降低学习率，但这些都需要提前设置好，不能适应训练数据的特性</li>
<li>所有参数更新的学习率是相同的，如果训练数据是稀疏的，而且特征出现的频率不一样，比较合适的做法是对出现频率低的特征采用较大的学习率更新</li>
<li>对于非凸函数，可能会陷入鞍点(saddle points)而导致训练困难，在鞍点区域某些维度呈上升趋势，而另外一些呈下降趋势，鞍点的梯度在所有维度都趋近于0，导致代价函数陷入其中，参数更新困难</li>
</ul>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>&emsp;&emsp;SGD存在一个缺陷就是，当某一个方向(维度)梯度较大、另一个方向梯度较小时，代价函数可能会在大梯度方向以大步长来回振荡，而在小梯度方向缓慢前进，造成收敛缓慢。Momentum受到物理学中动量的启发，能够在相关方向加速SGD，并抑制振荡，加快收敛<br><img src="https://i.loli.net/2017/12/23/5a3e02df1d688.jpg" alt="momentum.jpg" title="SGD without momentum(left) and with momentum(right)"></p>
<p>\begin{split}<br>v_t &amp;= \gamma v_{t-1} + \eta \nabla_\theta J(\theta) \cr<br>\theta &amp;= \theta - v_t<br>\end{split}</p>
<p>由上式可以看到，当前梯度的方向要与之前的梯度方向进行加权平均，$\gamma$一般取值为0.9。在梯度方向不变的维度，momentum项增加；在梯度方向频繁改变的维度，momentum项更新减少。经过一段时间动量项的累加，可以在一定程度上抑制振荡，加速收敛。</p>
<h3 id="Nesterov-accelerated-gradient-NAG"><a href="#Nesterov-accelerated-gradient-NAG" class="headerlink" title="Nesterov accelerated gradient(NAG)"></a>Nesterov accelerated gradient(NAG)</h3><p>&emsp;&emsp;在梯度下降更新参数的过程中，有时候希望提前知道下一步到达位置的梯度，以便及时调整参数更新方向。NAG实现了这一想法，利用Momentum预测下一步的梯度，而不是直接使用当前的$\theta$</p>
<p>\begin{split}<br>v_t &amp;= \gamma v_{t-1} + \eta \nabla_\theta J( \theta - \gamma v_{t-1} ) \cr<br>\theta &amp;= \theta - v_t<br>\end{split}</p>
<p>动量项系数$\gamma$取值为0.9。在上面提到的Momentum方法中，首先计算当前参数(位置)的梯度，然后更新动量项，并沿着动量项（更新后）的方向更新参数；而在NAG方法中，首先沿着之前累积的动量项的方向更新参数，然后基于更新后的参数计算梯度，并对参数进行调整。两种方法的对比如下图所示：<br><img src="https://i.loli.net/2017/09/17/59be22509c283.jpeg" alt="nesterov.jpeg" title="Momentum and NAG"><br>详细介绍可参考<a href="http://cs231n.github.io/neural-networks-3/#sgd-and-bells-and-whistles" target="_blank" rel="external">cs231n-sgd</a></p>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><p>&emsp;&emsp;Adagrad是一种在学习过程中自动调整学习率的参数优化方法，不同参数采用不同的学习率进行更新。出现频率低的参数更新较大，频率高的参数更新较小，因此特别适用于处理稀疏数据，而且Adagrad提高了SGD的鲁棒性</p>
<p>\begin{split}<br>g_t &amp;= \nabla_\theta J( \theta) \cr<br>G_t &amp;= G_{t-1} + g_t^2 \cr<br>\theta_{t+1} &amp;= \theta_t -  \dfrac{\eta}{\sqrt{G_t + \varepsilon}} \cdot g_t<br>\end{split}</p>
<p>$t$表示迭代次数，$G_t是每个参数的梯度平方的累加和$，使用$\sqrt{G_t + \varepsilon}$作为约束项自动调整每个参数在训练过程中的学习率。对于梯度较大的参数，有效学习率会降低；而梯度较小的参数，有效学习率则相对会增大。但对每个参数而言，由于梯度平方和的累加，学习率实际上一直是递减的，这也是Adagrad的一个缺陷，可能会导致学习率降低至0，过早结束训练过程。</p>
<h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><p>&emsp;&emsp;Adagrad方法比较激进，会过早结束训练过程。在对参数进行调整时，Adagrad使用的是每次迭代的梯度累加和，而在Adadelta中则通过衰减平均(decaying average)的方式计算梯度平方的加权均值<br>$$E[g^2]_t = \gamma E[g^2]_{t-1} + (1 - \gamma) g^2_t$$<br>$\gamma$可取值为0.9(0.95)，使用$E[g^2]_t$调整学习率<br>$$\Delta \theta_t = - \dfrac{\eta}{\sqrt{E[g^2]_t + \epsilon}} g_{t}$$<br>考虑到分母为梯度的均方根(root mean squared, RMS)，公式可替换为<br>$$\Delta \theta_t = - \dfrac{\eta}{RMS[g]_{t}} g_t,&emsp;RMS[g]_t=\sqrt{E\left[g^2\right]_t+\epsilon}$$<br>将学习率$\eta$替换为$RMS[\Delta \theta]_{t-1}$，利用之前的步长估计下一步的步长，公式如下：</p>
<p>\begin{split}<br>\Delta \theta_t &amp;= - \dfrac{RMS[\Delta \theta]_{t-1}}{RMS[g]_{t}} g_{t} \\<br>\theta_{t+1} &amp;= \theta_t + \Delta \theta_t<br>\end{split}</p>
<p>式中，$RMS[\Delta \theta]_{t} = \sqrt{E[\Delta \theta^2]_t + \epsilon},E[\Delta \theta^2]_t = \gamma E[\Delta \theta^2]_{t-1} + (1 - \gamma) \Delta \theta^2_t$，在Adadelta中，不需要设置默认学习率，其自身可通过迭代计算得到。详细讲解参考原论文<a href="https://arxiv.org/pdf/1212.5701v1.pdf" target="_blank" rel="external">Adadelta</a></p>
<h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><p>&emsp;&emsp;RMSprop同样是用来解决Adagrad学习率趋于0、过早结束训练的方法，来源于Hinton大神的<a href="http://218.199.87.242/cache/9/03/www.cs.toronto.edu/a1dce074ab79c3b6a179c02438d76249/lecture_slides_lec6.pdf" target="_blank" rel="external">slide</a>，而且思想基本和Adadelta一致，公式就是上面Adadelta方法中的前两项：</p>
<p>\begin{split}<br>E[g^2]_t &amp;= \gamma E[g^2]_{t-1} + (1-\gamma) g^2_t \\<br>\theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{\sqrt{E[g^2]_t + \epsilon}} g_{t}<br>\end{split}</p>
<p>$\gamma$为权重衰减率，一般可设置为0.9、0.99、0.999，$\eta$为学习率，可取值为0.001。</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>&emsp;&emsp;Adaptive Moment Estimation(Adam)是一种结合了Momentum和RMSprop优点的方法，利用指数衰减平均的方法(exponentially decaying average)计算梯度平方的加权均值$v_t$，类似于Adadelta和RMSprop，并且基于同样的方法计算梯度值的加权均值$m_t$，相当于引入动量项</p>
<p>\begin{split}<br>m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t \\<br>v_t &amp;= \beta_2 v_{t-1} + (1 - \beta_2) g_t^2<br>\end{split}</p>
<p>$m_t$和$v_t$分别是梯度的一阶矩（均值）和二阶矩（方差）估计，$\beta_1$和$\beta_2$为衰减率，一般取值为$\beta_1=0.9$、$\beta_2=0.999$。由于$m_t$和$v_t$在初始几步的取值较小，趋近于0，Adam对此进行了偏差校正(Bias Correction)：</p>
<p>\begin{split}<br>\hat{m}_t &amp;= \dfrac{m_t}{1 - \beta^t_1} \\<br>\hat{v}_t &amp;= \dfrac{v_t}{1 - \beta^t_2}<br>\end{split}</p>
<p>参数更新规则类似于RMSprop：<br>$$\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t$$<br>Adam集成了多种优化方法的优点，既适用于处理稀疏数据，又能够达到平稳快速收敛的效果，应用十分广泛。</p>
<h3 id="AdaMax"><a href="#AdaMax" class="headerlink" title="AdaMax"></a>AdaMax</h3><p>&emsp;&emsp;AdaMax是Adam的一种变体，在Adam中计算$v_t$时考虑的是$\ell_2$范数(l2-norm)，AdaMax将这种约束推广到$\ell_p$范数：<br>$$v_t = \beta_2^p v_{t-1} + (1 - \beta_2^p) |g_t|^p$$<br>$\ell_\infty$能够取得较为稳定的结果，因此在AdaMax中被采纳</p>
<p>\begin{split}<br>u_t &amp;= \beta_2^\infty v_{t-1} + (1 - \beta_2^\infty) |g_t|^\infty\\<br>              &amp; = \max(\beta_2 \cdot v_{t-1}, |g_t|)\\<br>              \theta_{t+1} &amp;= \theta_{t} - \dfrac{\eta}{u_t} \hat{m}_t<br>\end{split}</p>
<p>$u_t$取两项中的较大值，不需要再执行偏差校正操作，$\hat{m}_t$仍然和Adam中一样，超参数取值分别为$\eta = 0.002,\beta_1=0.9,\beta_2=0.999$。</p>
<h3 id="Nadam"><a href="#Nadam" class="headerlink" title="Nadam"></a>Nadam</h3><p>&emsp;&emsp;Nadam类似于带有Nesterov动量项的Adam，相当于NAG和Adam的组合，在NAG中，参数更新规则为：</p>
<p>\begin{split}<br>g_t &amp;= \nabla_{\theta_t}J(\theta_t - \gamma m_{t-1})\\<br>m_t &amp;= \gamma m_{t-1} + \eta g_t\\<br>\theta_{t+1} &amp;= \theta_t - m_t<br>\end{split}</p>
<p>在NAG中既要更新梯度$g_t$，又要更新参数$\theta_{t+1}$，Nadam作者Dozat直接应用look-ahead momentum更新当前参数</p>
<p>\begin{split}<br>g_t &amp;= \nabla_{\theta_t}J(\theta_t)\\<br>m_t &amp;= \gamma m_{t-1} + \eta g_t\\<br>\theta_{t+1} &amp;= \theta_t - (\gamma m_t + \eta g_t)<br>\end{split}</p>
<p>注意到在更新参数时，用的不是previous momentum $m_{t-1}$，而是current momentum $m_t$。Adam的参数更新规则为</p>
<p>\begin{split}<br>m_t &amp;= \beta_1 m_{t-1} + (1 - \beta_1) g_t\\<br>\hat{m}_t &amp; = \frac{m_t}{1 - \beta^t_1}\\<br>\theta_{t+1} &amp;= \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t<br>\end{split}</p>
<p>为了将Nesterov momentum加入Adam中，需要扩展参数更新式：</p>
<p>\begin{split}<br>\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\dfrac{\beta_1 m_{t-1}}{1 - \beta^t_1} + \dfrac{(1 - \beta_1) g_t}{1 - \beta^t_1}) \<br>&amp;= \theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\beta_1 \hat{m}_{t-1} + \dfrac{(1 - \beta_1) g_t}{1 - \beta^t_1})<br>\end{split}</p>
<p>将$\hat{m}_{t-1}$替换为$\hat{m}_t$，即可得到Nadam的参数更新规则<br>$$\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\beta_1 \hat{m}_t + \dfrac{(1 - \beta_1) g_t}{1 - \beta^t_1})$$<br>详细内容参考论文<a href="http://cs229.stanford.edu/proj2015/054_report.pdf" target="_blank" rel="external">Nadam</a></p>
<h3 id="Visualization-of-Algorithms"><a href="#Visualization-of-Algorithms" class="headerlink" title="Visualization of Algorithms"></a>Visualization of Algorithms</h3><p>&emsp;&emsp;下面两幅图直观地展示了各种优化方法的性能，从左图中可以看出，Adagrad、Adadelta、RMSprop能够朝着正确的方向更新参数，而Momentum和NAG则在一开始偏离了正确路线，但最后均完成了收敛，而且NAG可以较为迅速地校正参数更新方向。右图展示了各种方法在鞍点处的表现，可以看出SGD、Momentum和NAG很难打破鞍点处的平衡(symmetry)，不过Momentum和NAG最终还是能够逃逸出来，而Adagrad、Adadelta、RMSprop则能够迅速朝代价函数的下降方向更新参数。</p>
<p><table><br>  <tr><br>    <td style="padding:1px"><br>      <figure><br>      <img src="https://i.loli.net/2017/09/17/59be6494370fd.gif" style="width: 100%; height: 100%" title="SGD optimization on loss surface contours"><br></figure><br>    </td><br>    <td style="padding:1px"><br>      <figure><br>      <img src="https://i.loli.net/2017/09/17/59be6493e3d8b.gif" style="width: 100%; height: 100%" title="SGD optimization on saddle point"><br></figure><br>    </td><br>  </tr><br></table></p>
<h3 id="Which-Optimizer-to-use"><a href="#Which-Optimizer-to-use" class="headerlink" title="Which Optimizer to use"></a>Which Optimizer to use</h3><ul>
<li>对于稀疏数据，尽可能地选择能够自适应调整学习率(adaptive learning rate)的优化方法，不需手动调节，在设置好默认值的情况下可以实现较好的结果</li>
<li>RMSprop、Adadelta是Adagrad的扩展，解决了Adagrad学习率递减、过早结束训练的问题；RMSprop、Adadelta、Adam在相似的情况下表现差不多，相对而言Adam能够达到更好的效果</li>
<li>SGD通常训练时间更长，可能陷入鞍点，但是在好的参数初始化和学习率调度方案的情况下，结果依然十分可靠</li>
<li>在训练深层或复杂的网络时，如果考虑快速收敛，一般选择Adam这类自适应调整学习率的优化方法</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="http://ruder.io/optimizing-gradient-descent/" target="_blank" rel="external">http://ruder.io/optimizing-gradient-descent/</a></li>
<li><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="external">Paper: An overview of gradient descent optimization algorithms</a></li>
<li><a href="http://cs231n.github.io/optimization-1/" target="_blank" rel="external">http://cs231n.github.io/optimization-1/</a></li>
<li><a href="http://ufldl.stanford.edu/wiki/index.php/%E5%8F%8D%E5%90%91%E4%BC%A0%E5%AF%BC%E7%AE%97%E6%B3%95" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/%E5%8F%8D%E5%90%91%E4%BC%A0%E5%AF%BC%E7%AE%97%E6%B3%95</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="external">http://cs231n.github.io/neural-networks-3/</a></li>
<li><a href="http://blog.mrtanke.com/2016/10/24/An-overview-of-gradient-descent-optimization-algorithms/" target="_blank" rel="external">http://blog.mrtanke.com/2016/10/24/An-overview-of-gradient-descent-optimization-algorithms/</a></li>
<li><a href="http://shuokay.com/2016/06/11/optimization/" target="_blank" rel="external">http://shuokay.com/2016/06/11/optimization/</a></li>
<li><a href="https://blog.slinuxer.com/2016/09/sgd-comparison" target="_blank" rel="external">https://blog.slinuxer.com/2016/09/sgd-comparison</a></li>
<li><a href="https://json0071.gitbooks.io/svm/content/sui_ji_ti_du_xia_jiang.html" target="_blank" rel="external">https://json0071.gitbooks.io/svm/content/sui_ji_ti_du_xia_jiang.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22252270" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/22252270</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在机器学习中，模型优化通常会定义一个代价函数(Loss Function)，然后通过最小化代价函数，求得一组参数，例如Logistic Regression、SVM以及神经网络等都属于这类问题，而这类模型往往使用迭代法求解，其中梯度下降法(Gradient Descent)应用最为广泛。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://senitco.github.io/categories/Algorithm/"/>
    
    
      <category term="DL" scheme="https://senitco.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning -- Normalization</title>
    <link href="https://senitco.github.io/2017/09/12/deep-learning-normalization/"/>
    <id>https://senitco.github.io/2017/09/12/deep-learning-normalization/</id>
    <published>2017-09-11T16:00:00.000Z</published>
    <updated>2017-09-18T04:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Normalization可理解为归一化、标准化或者规范化，广泛应用于诸多领域。整体来讲，Normalization扮演着对数据分布重新调整的角色。在图像处理领域，不同形式的归一化可以改变图像的灰度、对比度信息；在机器学习和神经网络中，Normalization可用于对数据去相关，加速模型训练，提高模型的泛化能力。<br><a id="more"></a></p>
<h3 id="Normalization-min-max"><a href="#Normalization-min-max" class="headerlink" title="Normalization(min-max)"></a>Normalization(min-max)</h3><p>&emsp;&emsp;通常意义上的归一化，也是使用较为频繁的一种是对数据按比例缩放，使之分布在一个特定的区间。例如将数据映射到[0, 1]区间，这在数据挖掘和机器学习中较为常见，在原始数据集中，不同维的数据（特征）往往具有不同的量纲或范围，会导致不同特征呈现不同的重要性，为了消除这种影响，将不同维的特征归一化到特定区间，使所有指标处于同一数量级，将归一化的数据应用于后续的算法模型，也会更加高效便捷。归一化的数学表达式如下：<br>$$x = \dfrac{x-x_{min}}{x_{max}-x_{min}}$$<br>如果是映射到特定区间[a,b]，公式如下：<br>$$x = \dfrac{x-x_{min}}{x_{max}-x_{min}} (b-a) + a$$<br>在图像处理中，经常会将像素灰度值映射到区间[0,255]。此外，还有直方图均衡化(Histogram Equalization)、按特定幂函数对图像进行对比度拉伸(Contrast Stretching)等图像预处理操作。</p>
<h3 id="Standardization"><a href="#Standardization" class="headerlink" title="Standardization"></a>Standardization</h3><p>&emsp;&emsp;z-score标准化方法使数据符合均值为0、标准差为1的分布，数学变换式如下：<br>$$\widehat x = \dfrac{x - \mu}{\sigma}$$<br>式中，$\mu、\sigma$分别为原始数据的均值和标准差。这种标准化方法在一定程度上可以降低数据之间的相关性，并加速训练过程。就图像和视觉领域而言，通常只需要减去均值即可。对于所有图像样本，对相同坐标的像素求取均值，这样便可得到一个均值模板图像，然后让所有图像减去这个均值模板，这是一种比较通用的处理方法；还有一种是对所有图像的所有像素在RGB三个通道求取均值，然后让所有像素的三通道值分别减去对应通道的均值，这种方法有在Faster R-CNN等系列目标检测领域中用到。</p>
<h3 id="ZCA-Whitening"><a href="#ZCA-Whitening" class="headerlink" title="ZCA Whitening"></a>ZCA Whitening</h3><p>&emsp;&emsp;白化(Whitening)的目的是降低数据之间的相关性，对于图像数据而言，相邻像素之间具有很强的相关性，也就是说数据是冗余的。通过白化过程，希望数据具备如下两点性质：</p>
<ul>
<li>特征之间的相关性降低</li>
<li>所有特征具有相同的方差</li>
</ul>
<p>&emsp;&emsp;主成分分析(PCA)一般用于数据降维，其思路是计算数据样本集$X$协方差矩阵的特征值和特征向量，通过选取前k个特征值对应的特征向量组成投影矩阵，将原始数据映射到新的特征空间，这样便去除了数据之间的相关性（具体内容可参考<a href="https://senitco.github.io/2017/05/10/data-dimensionality-reduction/">博文</a>）。白化的第一步操作就是PCA，如下图所示，假设由特征向量组成的变换矩阵为$U$（既可以保留所有特征向量，也可以只取前k个），那么变换后的数据为<br>$$X_{PCA}=U^T X$$</p>
<p><img src="https://i.loli.net/2017/09/14/59ba2ec2b1f8d.png" alt="pca.png"></p>
<p>第二步PCA白化对变换后数据的每一维特征做标准差归一化处理，使得不同特征的方差相同（单位方差），变换式如下：<br>$$X_{PCAwhite} = \dfrac{X_{PCA}}{std(X_{PCA})}$$<br>也可直接采用下式：<br>$$X_{PCAwhite} = \dfrac{X_{PCA}}{\sqrt{\lambda_i + \varepsilon}}$$<br>$\lambda_i$是PCA得到的特征值，$\varepsilon$是正则化项，避免除数为0，一般取值为$\varepsilon \approx 10^{-5}$。PCA白化后数据分布如下图所示：</p>
<p><img src="https://i.loli.net/2017/09/14/59ba31a97d72d.jpg" alt="pca whitening.jpg" title="PCA Whitening"></p>
<p>第三步ZCA白化是在PCA白化的基础上，将数据变换回原来的特征空间，使得白化后的数据尽可能地接近原始数据。<br>$$X_{ZCAwhite} = U X_{PCAwhite}$$</p>
<p><img src="https://i.loli.net/2017/09/14/59ba31ae6663c.jpg" alt="zca whitening.jpg" title="ZCA Whitening"></p>
<p>不同于 PCA白化，当使用ZCA白化时，通常保留数据的全部n个维度，不尝试去降低它的维数。关于图像的协方差矩阵和ZCA白化可参考<a href="http://218.199.87.242/cache/12/03/www.cs.toronto.edu/cb468cfcbdb22c46e3e49e2ba3c72198/learning-features-2009-TR.pdf" target="_blank" rel="external">Learning Multiple Layers of Features from Tiny Images</a></p>
<h3 id="Global-Contrast-Normalization-GCN"><a href="#Global-Contrast-Normalization-GCN" class="headerlink" title="Global Contrast Normalization(GCN)"></a>Global Contrast Normalization(GCN)</h3><p>&emsp;&emsp;全局对比度标准化(GCN)就是计算图像中所有像素的均值和标准差，然后每个像素分别减去权值并除以标准差，GCN和ZCA Whitening通常一起使用。</p>
<h3 id="Local-Contrast-Normalization-LCN"><a href="#Local-Contrast-Normalization-LCN" class="headerlink" title="Local Contrast Normalization(LCN)"></a>Local Contrast Normalization(LCN)</h3><p>&emsp;&emsp;局部对比度标准化(LCN)是通过计算图像中局部邻域的均值和标准差来进行标准化，可参考论文<a href="http://yann.lecun.com/exdb/publis/pdf/jarrett-iccv-09.pdf" target="_blank" rel="external">What is the Best Multi-Stage Architecture for Object Recognition</a>，具体流程如下：</p>
<ul>
<li>对图像中的像素，考虑一个$3 \times 3$的邻域</li>
<li>计算邻域窗口内所有像素的均值(mean)和标准差(std)，并让中心像素减去均值</li>
<li>比较标准差与1的大小，如果大于1，则中心像素值（减去均值后）除以标准差作为标准化后的最终值；否则，直接将减去均值后的中心像素值作为最终值</li>
<li>遍历图像中的所有像素，按照上述流程分别进行局部标准化</li>
</ul>
<p>在实际处理过程中，可以考虑不同窗口大小的邻域，也可利用加权的方式求取邻域像素的均值。如果在卷积神经网络中，存在多个特征图(feature map)的情况，可以同时考虑空间邻域和特征邻域，例如相邻两个特征图的$3 \times 3$邻域，则每个像素有$3 \times 3 \times 3 -1 = 26$个邻域像素点。LCN可以增强某些特征图的特征表达能力，而限制另外一些特征图的特征表达(?)。</p>
<h3 id="Local-Response-Normalization-LRN"><a href="#Local-Response-Normalization-LRN" class="headerlink" title="Local Response Normalization(LRN)"></a>Local Response Normalization(LRN)</h3><p>&emsp;&emsp;局部响应标准化(LRN)这一概念是在<a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="external">AlexNet</a>中提出的，受到LCN的启发，通过考虑相邻特征图进行标准化，数学表达式如下：<br>$$b_{x,y}^i = a_{x,y}^i / (k + \alpha \Sigma_{j=max(0,i-n/2)}^{min(N-1, i+n/2)}(a_{x,y}^j)^2)^\beta$$<br>$a_{x,y}^i$是第$i$个卷积核在特征图中坐标$(x,y)$处的激活输出，$b_{x,y}^i$为对应的LRN输出值，$N$是卷积核或者特征图的数量，$n$是考虑的邻域特征图个数，论文中取值为5，$k、\alpha、\beta$是超参数，分别取值为$k=2,\alpha=10^{-4},\beta=0,75$。LRN的流程图如下：</p>
<p><img src="https://i.loli.net/2017/09/14/59ba46a4b1b6c.jpg" alt="local_response_normalization_process.jpg" title="LRN流程图"></p>
<p>为了使LRN输入输出的特征图数量一致，需要对特征图进行扩充(padding)，两端分别增加$n/2$个特征图，可直接拷贝相邻特征图。后续有研究表明，LRN在实际模型中发挥的作用不大，因而使用逐渐变少。</p>
<h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p>&emsp;&emsp;在训练神经网络模型时，由于网络参数在不断更新，每一层的输入分布也在不断变化，这迫使网络设置更小的学习率，导致更慢的训练速度，而且对参数初始化的要求也较高，这种现象称为Internal Convariate Shift。而Batch Normalization通过对每层的输入进行归一化，可以有效地缓解这个问题，网络可以使用较大的学习率，参数初值也无需刻意设置，并且可以起到正则化(Regularization)的作用，减弱了对Dropout的需求，保证了更快的训练速度和更精确的网络模型。</p>
<h4 id="Why-need-BN"><a href="#Why-need-BN" class="headerlink" title="Why need BN"></a>Why need BN</h4><p>&emsp;&emsp;在神经网络中，最基本的参数优化方法就是随机梯度下降(SGD)，通过最小化代价函数来求得一组模型参数<br>$$\theta = \underset{\theta}{\mathrm{arg min}} \dfrac{1}{N} \sum_{i=1}^N{\mathcal L\left(x_i, \theta\right)}$$<br>在实际训练过程中，通常采用minibatch的方法，即每次迭代训练一批数据，梯度计算如下：<br>$$\dfrac{1}{m}\sum \dfrac{\partial{\mathcal L \left(x_i, \theta\right)}}{\partial \theta}$$<br>minibatch可以近似整个训练集的梯度，并且可以并行地计算m个样本，比单独计算每个样本要快。但SGD仍然存在一些固有缺陷：</p>
<ul>
<li>学习率比较难设置，为了尽量避免梯度弥散(Gradiant Vanish)，只能设置较小的学习率，导致训练缓慢</li>
<li>对权值参数的初始值要求较高，否则会造成收敛困难</li>
<li>每层的输入受到前面参数的影响，前面很小的变动，随着网络层数增加会不断被放大</li>
</ul>
<p>&emsp;&emsp;参数的更新会导致各层输入数据分布的变化，每次迭代，网络中的每一层需要学习拟合不同的数据分布，这样会显著降低网络的训练速度。当一个学习系统的输入分布是变化的，例如训练集和测试集的样本分布不一致，训练的模型就很难有较好的泛化能力。通常在将原始数据输入到网络中训练时，都会有一个归一化的预处理，也就是使得数据分布的均值为0、方差为1的近似白化过程。而Batch Normalization正是将这种归一化的方法应用到网络的每一层中，这样每一层的输入分布都不再受到前面参数变化的影响，该层网络也不需要适应输入分布的变化。</p>
<p>&emsp;&emsp;考虑到网络使用饱和非线性的激活函数例如Sigmoid，参数的变化可能会导致输入大量分布于饱和区域，局部梯度趋近于0，在反向传播的时候可能会出现梯度弥散的情况，进一步导致前面参数更新较慢或者停止更新，模型收敛困难。ReLU激活函数、合适的初值以及较小的学习率可以在一定程度上解决梯度消失的问题，而采用Batch Normalization的方法使每一层的输入分布更稳定，哪怕是使用Sigmoid激活函数，输入也不太可能分布于饱和区域，降低了模型对激活函数选择的依赖。</p>
<p>&emsp;&emsp;在传统的深度网络中，过高的学习率会导致梯度爆炸或消失(explode or vanish)，以及陷入局部极值，BN可以防止参数变化的影响逐层放大，避免陷入饱和区域。而且BN使得训练对参数的尺度(scale)更加鲁棒，一般高学习率会增加参数的scale，在反向传播中放大梯度，导致模型爆炸。在进行BN之后，<br>$$BN(wu) = BN((\alpha w)u)$$<br>$$\frac{\partial BN((\alpha w)u)}{\partial u} = \frac{\partial BN(wu)}{\partial u}$$<br>$$\frac{\partial BN((\alpha w)u)}{\partial (\alpha w)} = \frac{1}{\alpha} \frac{\partial BN(wu)}{\partial w}$$<br>可以看出较大的$w$将获得较小的梯度，也就是说较大的权值更新较小，较小的权值更新较大。因此，BN使得权重的更新更加稳健，反向传播的梯度不受参数scale的影响，解决了梯度爆炸或梯度消失的问题。</p>
<h4 id="What-is-BN"><a href="#What-is-BN" class="headerlink" title="What is BN"></a>What is BN</h4><p>&emsp;&emsp;Batch Normalization作用在每一层的输入，也就是激活函数（非线性变换）之前，而不是前一层的输出，BN的算法流程如下：</p>
<p><img src="https://i.loli.net/2017/09/16/59bce0018d695.jpg" alt="batch-norm.jpg" title="Batch Normalizing Transform"></p>
<p>BN Transform在对输入数据做0均值、单位方差的归一化处理后，又进行了一次线性变换，引入了一对可学习的参数$\gamma、\beta$，提升了模型的容纳能力(capacity)，如果$\gamma=\sqrt{\sigma_{\beta}^2}、\beta=\mu_{\beta}$，这样$y_i$就恢复成原来的输入分布$x_i$。 至于是否需要对$y_i$进行还原，则由网络模型自动从训练数据中学习决定。BN层的梯度反向传播公式如下：</p>
<p><img src="https://i.loli.net/2017/09/16/59bce41fc966a.jpg" alt="bn-bp.jpg" title="bn-bp.jpg"></p>
<p>训练结束将模型用于测试时，均值$\mu$和标准差$\sigma$是固定的，均值为训练阶段所有Batch均值的统计平均，方差为所有训练Batch方差的无偏估计，公式如下：<br>$$E[x]=E_{B}[\mu _B],&emsp;Var[x]=\dfrac{m}{m-1}E_{B}[\sigma_B^2]$$<br>在测试阶段，BN变换式为<br>$$y=\dfrac{\gamma}{\sqrt{Var[x]+\varepsilon}}x+(\beta-\dfrac{\gamma E[x]}{\sqrt{Var[x]+\varepsilon}})$$</p>
<p>整个训练和测试流程如下：</p>
<p><img src="https://i.loli.net/2017/09/16/59bce867e253a.jpg" alt="bn-inference.jpg" title="Training and Inference BN Network"></p>
<p>BN变换置于网络激活函数层的前面，对于普通前馈神经网络，BN是对一层的每个神经元进行归一化处理；而在卷积神经网络中，BN则是对一层的每个特征图进行处理，类似于权值共享，一个特征图只有一对可学习参数$\gamma、\beta$，如果某一层的输入张量为$[batch\_size, height, width, channels]$，则BN变换是按照channels进行的，minibatch的大小相当于$batch\_size \times height \times width$。</p>
<h4 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h4><p>总体来说，Batch Normalization主要有如下优点：</p>
<ul>
<li>保证网络各层输入的均值和方差稳定（数据分布不一定一致？），减弱Internal Convariate Shift的影响</li>
<li>减小参数scale和初值对梯度的影响，解决了梯度爆炸或梯度消失的问题</li>
<li>在某种程度上实现了正则化，减弱对L2-norm、Dropout的依赖</li>
<li>让输入分布于饱和区域(Sigmoid)的概率降低</li>
<li>降低超参数选择对模型的影响，可使用较大的学习率加速训练</li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="https://arxiv.org/pdf/1502.03167.pdf" target="_blank" rel="external">Paper: Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a></li>
<li><a href="http://yann.lecun.com/exdb/publis/pdf/jarrett-iccv-09.pdf" target="_blank" rel="external">Paper: Local Contrast Normalization: What is the Best Multi-Stage Architecture for Object Recognition?</a></li>
<li><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="external">Paper: ImageNet Classification with Deep Convolutional Neural Networks</a></li>
<li><a href="http://yeephycho.github.io/2016/08/03/Normalizations-in-neural-networks/" target="_blank" rel="external">http://yeephycho.github.io/2016/08/03/Normalizations-in-neural-networks/</a></li>
<li><a href="https://calculatedcontent.com/2017/06/16/normalization-in-deep-learning/" target="_blank" rel="external">https://calculatedcontent.com/2017/06/16/normalization-in-deep-learning/</a></li>
<li><a href="http://ufldl.stanford.edu/wiki/index.php/%E7%99%BD%E5%8C%96" target="_blank" rel="external">http://ufldl.stanford.edu/wiki/index.php/%E7%99%BD%E5%8C%96</a></li>
<li><a href="http://www.csuldw.com/2015/11/15/2015-11-15%20normalization/" target="_blank" rel="external">http://www.csuldw.com/2015/11/15/2015-11-15%20normalization/</a></li>
<li><a href="http://blog.csdn.net/hjimce/article/details/50866313" target="_blank" rel="external">http://blog.csdn.net/hjimce/article/details/50866313</a></li>
<li><a href="https://stats.stackexchange.com/questions/117427/what-is-the-difference-between-zca-whitening-and-pca-whitening" target="_blank" rel="external">https://stats.stackexchange.com/questions/117427/what-is-the-difference-between-zca-whitening-and-pca-whitening</a></li>
<li><a href="http://shuokay.com/2016/05/28/batch-norm/" target="_blank" rel="external">http://shuokay.com/2016/05/28/batch-norm/</a></li>
<li><a href="http://jiangqh.info/Batch-Normalization%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://jiangqh.info/Batch-Normalization%E8%AF%A6%E8%A7%A3/</a></li>
<li><a href="http://blog.csdn.net/u012816943/article/details/51691868" target="_blank" rel="external">http://blog.csdn.net/u012816943/article/details/51691868</a></li>
<li><a href="http://blog.csdn.net/hjimce/article/details/50866313" target="_blank" rel="external">http://blog.csdn.net/hjimce/article/details/50866313</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Normalization可理解为归一化、标准化或者规范化，广泛应用于诸多领域。整体来讲，Normalization扮演着对数据分布重新调整的角色。在图像处理领域，不同形式的归一化可以改变图像的灰度、对比度信息；在机器学习和神经网络中，Normalization可用于对数据去相关，加速模型训练，提高模型的泛化能力。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://senitco.github.io/categories/Algorithm/"/>
    
    
      <category term="DL" scheme="https://senitco.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning -- Regularization</title>
    <link href="https://senitco.github.io/2017/09/10/deep-learning-regularization/"/>
    <id>https://senitco.github.io/2017/09/10/deep-learning-regularization/</id>
    <published>2017-09-09T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.594Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在训练神经网络时，为了缓解网络规模较大、训练数据较少而可能导致的过拟合(Overfitting)问题，通常会采取正则化(Regularization)方法，以提高模型的泛化能力。<br><a id="more"></a></p>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>&emsp;&emsp;过拟合具体表现如下图所示，在迭代训练的过程中，模型复杂度增加，在训练集上的错误率降低，而在验证集上反而上升，也就是说，模型过拟合了训练集，在除训练集以外的其他数据集上表现较差。有较多的方法可用来缓解过拟合问题，例如减小网络规模，扩增数据集(Date Argumentation)、正则化(Regulariztion)、提前终止(Early stopping)等。由于较大的网络规模通常具有较强的模型表达能力，所以减小网络规模以缓解过拟合并不十分可取。正则化则是一种使用较为广泛的方法，主要有L1-norm、L2-norm、Dropout。</p>
<p><img src="https://i.loli.net/2017/09/13/59b9296eb2674.png" alt="overfitting.png" title="Overfitting"></p>
<h3 id="L2-Regularization"><a href="#L2-Regularization" class="headerlink" title="L2 Regularization"></a>L2 Regularization</h3><p>&emsp;&emsp;L2正则也称为权重衰减(Weights Decay)，直接在代价函数(Loss Function)后面增加一个L2范数的正则化项，也就是对网络中所有权值求平方和然后开方。数学表达式如下：<br>$$C = C_0 + \dfrac{\lambda}{2n} \Sigma_w w^2$$<br>式中，$C_0$为原始代价函数，$n$为训练集大小，$\lambda$是两项的平衡系数。L2正则项通过惩罚(penalizes)权重的平方，倾向于让网络学习到更小的权值。添加正则项后的代价函数对网络参数的梯度为<br>$$\dfrac{\partial C}{\partial w} = \dfrac{\partial C_0}{\partial w} + \dfrac{\lambda}{n}w,&emsp;\dfrac{\partial C}{\partial b} = \dfrac{\partial C_0}{\partial b}$$<br>梯度反向传播用于更新网络权值<br>$$w = w - \eta (\dfrac{\partial C_0}{\partial w} + \dfrac{\lambda}{n}w) = (1-\dfrac{\eta \lambda}{n})w - \eta \dfrac{\partial C_0}{\partial w}$$<br>$$b = b - \eta \dfrac{\partial C_0}{\partial b}$$<br>式中，$\eta$为学习率(learning rate)，$w$的系数$(1-\dfrac{\eta \lambda}{n})$使得权重相比未正则化时减小，这也是$L2-norm$称作权重衰减的原因。<br>&emsp;&emsp;更小的权重，如何保证能够缓解过拟合？从某种意义上，权重越小表示模型复杂度更低，对数据的拟合刚好。在实际应用中，也验证了L2正则化的效果往往更好。过拟合的时候，拟合函数的系数通常较大，如下图所示，拟合函数需要顾及每个数据点，因此波动较大。在一些较小的区间内，函数值变化剧烈，意味着函数在这些小区间内的导数值（绝对值）非常大。由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。而L2正则化通过约束权值参数的范数使其不要太大，可以在一定程度上减少过拟合情况。</p>
<p><img src="https://i.loli.net/2017/09/13/59b93367e4f7f.png" alt="regular2.png"></p>
<h3 id="L1-Regularization"><a href="#L1-Regularization" class="headerlink" title="L1 Regularization"></a>L1 Regularization</h3><p>&emsp;&emsp;L1正则是在原始的代价函数后增加一个L1范数的正则化项，即所有权重绝对值的和。数学表达式如下：<br>$$C = C_0 + \dfrac{\lambda}{n} \Sigma_w w$$<br>梯度计算公式为<br>$$\dfrac{\partial C}{\partial w} = \dfrac{\partial C_0}{\partial w} + \dfrac{\lambda}{n}sgn(w)$$<br>式中$sgn(w)$表示权重的符号，权重更新规则为<br>$$w = w - \eta (\dfrac{\partial C_0}{\partial w} + \dfrac{\lambda}{n}sgn(w))$$<br>L1正则化对梯度的影响不再与权重$w$线性相关，而是一个常量因子。当$w$为正时，更新后的$w$变小；当$w$为负时，更新后的$w$变大。因此L1正则化的效果就是让$w$往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。与L2-norm相比，L1-norm会导致参数稀疏，因此可用于特征选取，参数被惩罚为0的特征可以被丢弃。</p>
<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>&emsp;&emsp;L1、L2正则化是通过修改代价函数来实现的，而Dropout则是修改神经网络本身，使得网络中的部分神经元以一定概率停止工作，具体内容可参考博文<a href="https://senitco.github.io/2017/09/08/deep-learning-dropout/">Dropout</a></p>
<h3 id="Data-Argumentation"><a href="#Data-Argumentation" class="headerlink" title="Data Argumentation"></a>Data Argumentation</h3><p>&emsp;&emsp;引起过拟合的一个因素就是数据量较少，扩增数据集，可以适应更深的网络模型，训练表达能力更强的模型。数据扩增的方法主要有：</p>
<ul>
<li>沿水平方向将图像左右翻转</li>
<li>平移、缩放、旋转或者随机裁剪图像</li>
<li>添加随机噪声</li>
</ul>
<h3 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h3><p>&emsp;&emsp;过拟合在验证集上表现为模型的错误率降到最低后上升，因此提前终止就是在模型的错误率降到最低，性能变坏之前停止迭代训练，如下图所示。当然在实际训练过程中，并不需要如此操作，而且通过设置checkpoints，每迭代一定次数保存模型，最后选择最优的作为最终模型。</p>
<p><img src="https://i.loli.net/2017/09/13/59b93c6685cc0.png" alt="early stopping.png"></p>
<p>关于数据集的划分：<br>&emsp;&emsp;一般数据集分为三部分：训练集(training data)、验证集(validation data)、测试集(testing data)。训练集用于在迭代训练中计算梯度、更新网络权值。验证集则在训练中评估模型的性能，用于确定一组模型的超参数，如学习率等；也就是说通过验证集，需要确定一组最优的超参数，以及在该组超参数下训练出的网络模型。而测试集则用于评估最终的模型性能，既不参与训练，也不用于选取超参数。验证集和测试集容易搞混，如果直接将测试集作为验证集使用，随着训练的进行，网络实际上在拟合测试集中的数据，那么测试集对网络的评估没有任意意义，因为最终用于评估模型的数据集应当是一个未知数据集，不参与任何训练过程。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="https://chatbotslife.com/regularization-in-deep-learning-f649a45d6e0" target="_blank" rel="external">https://chatbotslife.com/regularization-in-deep-learning-f649a45d6e0</a></li>
<li><a href="http://www.deeplearningbook.org/contents/regularization.html" target="_blank" rel="external">http://www.deeplearningbook.org/contents/regularization.html</a></li>
<li><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap3/c3s5ss1.html" target="_blank" rel="external">https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap3/c3s5ss1.html</a></li>
<li><a href="http://shartoo.github.io/regularization-deeplearning/" target="_blank" rel="external">http://shartoo.github.io/regularization-deeplearning/</a></li>
<li><a href="http://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="external">http://blog.csdn.net/u012162613/article/details/44261657</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在训练神经网络时，为了缓解网络规模较大、训练数据较少而可能导致的过拟合(Overfitting)问题，通常会采取正则化(Regularization)方法，以提高模型的泛化能力。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://senitco.github.io/categories/Algorithm/"/>
    
    
      <category term="DL" scheme="https://senitco.github.io/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>Deep Learning -- Dropout</title>
    <link href="https://senitco.github.io/2017/09/08/deep-learning-dropout/"/>
    <id>https://senitco.github.io/2017/09/08/deep-learning-dropout/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2017-09-18T04:15:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;训练神经网络模型时(Nerual Network)，如果网络规模较大，训练样本较少，为了防止模型过拟合，通常会采用Regularization(正则化，e.g. L2-norm、Dropout)。Dropout的基本思想是在模型训练时，让某些神经元以一定的概率不工作。<br><a id="more"></a></p>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>&emsp;&emsp;深度学习领域大神Hinton在2012的一篇文献<a href="https://arxiv.org/pdf/1207.0580.pdf" target="_blank" rel="external">《Improving neural networks by preventing co-adaptation of feature detectors》</a>中提出，在每次训练的时候，让一半的特征检测器停止工作，可以提高网络模型的泛化能力。Hinton认为过拟合可通过阻止某些特征的协同作用来缓解，并将这种方法称之为Dropout。<br>&emsp;&emsp;Dropout的工作原理是在模型的迭代训练过程中，让网络中的某些隐层节点(神经元)以一定概率不工作，相当于去除部分节点，但节点的权重会保留下来，只是暂时不更新。每次迭代去除的节点不一样，这样相当于每次训练不同的网络，而且实现了网络的权值共享。</p>
<h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>&emsp;&emsp;在训练一个普通的多层神经网络时，其流程是：将输入样本通过网络前向传播计算每次的激活值，并得到最后的Loss Function，然后反向传播误差并更新每层的权值参数。使用Dropout后，网络模型变化如下图所示：</p>
<p><img src="https://i.loli.net/2017/09/12/59b79168a4cf7.jpg" alt="dropout.jpg"></p>
<p>如何实现让神经元以一定概率停止工作，可参考以下公式，一般情况下，网络的前向计算公式如下：</p>
<p>$$z_i ^{(l+1)} = w_i ^{(l+1)} y^{(l)} + b_i ^{(l+1)}$$<br>$$y_i ^{(l+1)} = f(z_i ^{(l+1)})$$<br>采用Dropout后计算公式变成：<br>$$r_j ^{(l)} \sim Bernoulli(p),&emsp;\overline{y}^{(l)} = r^{(l)} \ast y^{(l)}$$<br>$$z_i ^{(l+1)} = w_i ^{(l+1)} \overline{y}^{(l)} + b_i ^{(l+1)},&emsp;y_i ^{(l+1)} = f(z_i ^{(l+1)})$$<br>上式中，$r_j ^{(l)}$服从概率为$p$的伯努利二项分布，$r^{(l)}$为生成的0、1向量。通过将激活值置0，实现了网络中$l$层部分节点停止工作，而$l+1$层的输入中，也只考虑了$l$层中非0的节点（其实考虑了所有节点，只是输出为0的结点对下一层网络不起作用，在反向传播时，也无法更新和其相关的网络权值）。关于Dropout还有几点需要注意：</p>
<ul>
<li>如果网络某一层的神经元个数为1000，dropout的比例为0.4(p=0.6)，那么经过Dropout操作后，大约会有400个神经元的激活值会置0</li>
<li>每次训练迭代，都会重新随机选取一定比例的节点激活值置0，因此每次删除的节点会有差异</li>
<li>反向传播时，非0节点的权值参数得到更新，而0节点的权值保持不变</li>
<li>删除某些节点使其激活值为0后，需要对其他节点进行rescale，也就是乘以$1/p$(p是保留节点的比例)；如果训练时没有rescale，测试时则需要对权重rescale，$W_{test}=pW$</li>
</ul>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>&emsp;&emsp;关于Dropout能够缓解过拟合、提高模型泛化能力的几点直观解释：</p>
<ul>
<li>减少神经元之间的共适应关系：在迭代训练时，隐层节点以一定概率随机出现(或消失)，因此不能保证每两个节点同时出现，这样权值的更新不再依赖于有固定关系的隐层节点，阻止了某些特征在其他特征下才有效果的情况，迫使网络学习更鲁棒的特征</li>
<li>模型平均作用：Dropout删除不同的神经元，类似于每次训练不同的网络，整个训练过程相当于对不同的模型取平均，而且不同的网络结构共享权值参数</li>
</ul>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>&emsp;&emsp;Dropout比较适用于大型网络缓解过拟合，能够取得明显的效果，但网络的训练速度也会明显变慢，不过对测试没有影响。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="http://www.jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf" target="_blank" rel="external">Paper: Dropout: A Simple Way to Prevent Neural Networks from Overfitting</a></li>
<li><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="external">Paper: ImageNet Classification with Deep Convolutional Neural Networks</a></li>
<li><a href="https://arxiv.org/pdf/1207.0580.pdf" target="_blank" rel="external">Paper: Improving neural networks by preventing co-adaptation of feature detectors</a></li>
<li><a href="http://www.cs.toronto.edu/~nitish/msc_thesis.pdf" target="_blank" rel="external">Paper: Improving Neural Networks with Dropout</a></li>
<li><a href="http://blog.csdn.net/hjimce/article/details/50413257" target="_blank" rel="external">http://blog.csdn.net/hjimce/article/details/50413257</a></li>
<li><a href="http://www.cnblogs.com/tornadomeet/p/3258122.html" target="_blank" rel="external">http://www.cnblogs.com/tornadomeet/p/3258122.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23178423" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23178423</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;训练神经网络模型时(Nerual Network)，如果网络规模较大，训练样本较少，为了防止模型过拟合，通常会采用Regularization(正则化，e.g. L2-norm、Dropout)。Dropout的基本思想是在模型训练时，让某些神经元以一定的概率不工作。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://senitco.github.io/categories/Algorithm/"/>
    
    
      <category term="DL" scheme="https://senitco.github.io/tags/DL/"/>
    
  </entry>
  
</feed>
