<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Senit_Co</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://senitco.github.io/"/>
  <updated>2018-08-03T04:22:11.890Z</updated>
  <id>https://senitco.github.io/</id>
  
  <author>
    <name>Senit_Co</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串(String)问题集锦</title>
    <link href="https://senitco.github.io/2018/04/08/data-structure-string-3/"/>
    <id>https://senitco.github.io/2018/04/08/data-structure-string-3/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.890Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中字符串(String)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Multiply-Strings"><a href="#Multiply-Strings" class="headerlink" title="Multiply Strings"></a>Multiply Strings</h3><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.<br>Note:<br>The length of both num1 and num2 is &lt; 110.<br>Both num1 and num2 contains only digits 0-9.<br>Both num1 and num2 does not contain any leading zero.<br>You must not use any built-in BigInteger library or convert the inputs to integer directly.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">see https://github.com/SenitCo/Algorithm/blob/master/images/43_multiply.jpg</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len1 + len2, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, mul = <span class="number">0</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</div><div class="line">            &#123;</div><div class="line">                mul = (num1[i] - <span class="string">'0'</span>) * (num2[j] - <span class="string">'0'</span>);</div><div class="line">                p1 = i + j;</div><div class="line">                p2 = i + j + <span class="number">1</span>;</div><div class="line">                sum = mul + pos[p2];    <span class="comment">//+pos[p2]是因为经过j--,上一轮的进位由pos[p1]变为pos[p2]</span></div><div class="line">                pos[p1] += sum / <span class="number">10</span>;    <span class="comment">//pos[p1]表示这一轮的进位</span></div><div class="line">                pos[p2] = sum % <span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="built_in">string</span> result;</div><div class="line">        <span class="keyword">while</span>(i &lt; pos.size() &amp;&amp; pos[i] == <span class="number">0</span>)    i++;</div><div class="line">        <span class="keyword">for</span>(; i &lt; pos.size(); i++)</div><div class="line">        &#123;</div><div class="line">            result.append(<span class="number">1</span>, pos[i] + <span class="string">'0'</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(result.empty())</div><div class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Simplify-Path"><a href="#Simplify-Path" class="headerlink" title="Simplify Path"></a>Simplify Path</h3><p><a href="https://leetcode.com/problems/simplify-path/description/" target="_blank" rel="external">Description</a>: Given an absolute path for a file (Unix-style), simplify it.<br>For example, path = “/home/“, =&gt; “/home”, path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</div><div class="line">        <span class="built_in">string</span> result, temp;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</div><div class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(path)</span></span>;</div><div class="line">        <span class="keyword">while</span>(getline(ss, temp, <span class="string">'/'</span>))   <span class="comment">//getlines可以分割(split)字符串</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(temp == <span class="string">""</span> || temp == <span class="string">"."</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(temp == <span class="string">".."</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(!vs.empty())</div><div class="line">                    vs.pop_back();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                vs.push_back(temp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : vs)</div><div class="line">            result += <span class="string">'/'</span> + s;</div><div class="line">        <span class="keyword">return</span> result.empty() ? <span class="string">"/"</span> : result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Text-Justification"><a href="#Text-Justification" class="headerlink" title="Text Justification"></a>Text Justification</h3><p><a href="https://leetcode.com/problems/text-justification/description/" target="_blank" rel="external">Description</a>: Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified. You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters. Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right. For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example, words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”], L: 16.<br>Return the formatted lines as:<br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]<br>Note: Each word is guaranteed not to exceed L in length.<br>Corner Cases:<br>A line other than the last line might contain only one word. What should you do in this case?<br>In this case, that line should be left-justified.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; fullJustify(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="keyword">int</span> L) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>, l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; words.size(); i += k) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(k = l = <span class="number">0</span>; i + k &lt; words.size() &amp;&amp; l + words[i + k].size() &lt;= L - k; k++) </div><div class="line">        &#123;</div><div class="line">            l += words[i+k].size();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">string</span> tmp = words[i];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i + k &gt;= words.size()) </div><div class="line">                tmp += <span class="string">" "</span>;</div><div class="line">            <span class="keyword">else</span> </div><div class="line">                tmp += <span class="built_in">string</span>((L - l) / (k - <span class="number">1</span>) + (j &lt; (L - l) % (k - <span class="number">1</span>)), <span class="string">' '</span>);</div><div class="line">            tmp += words[i + j + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        tmp += <span class="built_in">string</span>(L - tmp.size(), <span class="string">' '</span>);</div><div class="line">        res.push_back(tmp);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Valid-Number"><a href="#Valid-Number" class="headerlink" title="Valid Number"></a>Valid Number</h3><p><a href="https://leetcode.com/problems/valid-number/description/" target="_blank" rel="external">Description</a>: Validate if a given string is numeric.<br>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(; s[i] == <span class="string">' '</span>; i++) &#123;&#125;  <span class="comment">// skip the whilespaces</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++;     <span class="comment">// check the significand, skip the sign if exist</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> n_num = <span class="number">0</span>, n_point = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(; (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;=<span class="string">'9'</span>) || s[i]==<span class="string">'.'</span>; i++)</div><div class="line">            s[i] == <span class="string">'.'</span> ? n_point++ : n_num++;       </div><div class="line">        <span class="keyword">if</span>(n_point &gt; <span class="number">1</span> || n_num &lt; <span class="number">1</span>) <span class="comment">// no more than one point, at least one digit</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// check the exponent if exist</span></div><div class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'e'</span>) &#123;</div><div class="line">            i++;</div><div class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'+'</span> || s[i] == <span class="string">'-'</span>) i++;     <span class="comment">// skip the sign</span></div><div class="line"></div><div class="line">            n_num = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(; s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;=<span class="string">'9'</span>; i++, n_num++) &#123;&#125;</div><div class="line">            <span class="keyword">if</span>(n_num &lt; <span class="number">1</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(; s[i] == <span class="string">' '</span>; i++) &#123;&#125;  <span class="comment">// skip the trailing whitespaces</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> i == s.length();  <span class="comment">// must reach the ending 0 of the string</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h3><p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="external">Description</a>: Given two binary strings, return their sum (also a binary string). For example, a = “11”, b = “1”, Return “100”.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> step = <span class="number">0</span>, sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</div><div class="line">        <span class="built_in">string</span> c;</div><div class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</div><div class="line">        &#123;</div><div class="line">            sum = (a[i] - <span class="string">'0'</span>) + (b[j] - <span class="string">'0'</span>) + step;</div><div class="line">            c.push_back(sum % <span class="number">2</span> + <span class="string">'0'</span>);</div><div class="line">            step = sum / <span class="number">2</span>;              </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            sum = (a[i] - <span class="string">'0'</span>) + step;</div><div class="line">            c.push_back(sum % <span class="number">2</span> + <span class="string">'0'</span>);</div><div class="line">            step = sum / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; j--)</div><div class="line">        &#123;</div><div class="line">            sum = (b[j] - <span class="string">'0'</span>) + step;</div><div class="line">            c.push_back(sum % <span class="number">2</span> + <span class="string">'0'</span>);</div><div class="line">            step = sum / <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(step &gt; <span class="number">0</span>)</div><div class="line">            c.push_back(<span class="string">'1'</span>);</div><div class="line">        reverse(c.begin(), c.end());</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">            </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</div><div class="line">        <span class="built_in">string</span> s;   </div><div class="line">        <span class="keyword">int</span> c = <span class="number">0</span>, i = a.size() - <span class="number">1</span>, j = b.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c == <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            c += i &gt;= <span class="number">0</span> ? a[i--] - <span class="string">'0'</span> : <span class="number">0</span>;</div><div class="line">            c += j &gt;= <span class="number">0</span> ? b[j--] - <span class="string">'0'</span> : <span class="number">0</span>;</div><div class="line">            s.push_back(c % <span class="number">2</span> + <span class="string">'0'</span>);</div><div class="line">            c /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        reverse(s.begin(), s.end());</div><div class="line">        <span class="keyword">return</span> s;          </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中字符串(String)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="string" scheme="https://senitco.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>字符串(String)问题、哈希表、双指针</title>
    <link href="https://senitco.github.io/2018/04/02/data-structure-string-2/"/>
    <id>https://senitco.github.io/2018/04/02/data-structure-string-2/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.889Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中字符串(String)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Substring-with-Concatenation-of-All-Words"><a href="#Substring-with-Concatenation-of-All-Words" class="headerlink" title="Substring with Concatenation of All Words"></a>Substring with Concatenation of All Words</h3><p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/" target="_blank" rel="external">Description</a>: You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.<br>For example, given: s: “barfoothefoobarman”, words: [“foo”, “bar”]. You should return the indices: [0,9]. (order does not matter).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">Using an unordered_map&lt;string, int&gt; counts to record the expected times of each word and another </span></div><div class="line"><span class="comment">unordered_map&lt;string, int&gt; seen to record the times we have seen. Then checking for every possible </span></div><div class="line"><span class="comment">position of i. Once we meet an unexpected word or the times of some word is larger than its expected </span></div><div class="line"><span class="comment">times, we stop the check. If we finish the check successfully, push i to the result indexes.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSubstring(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;counts;</div><div class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word : words)</div><div class="line">        &#123;</div><div class="line">            counts[word]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> length = s.length(), num = words.size(), len = words[<span class="number">0</span>].length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - num * len + <span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; seen;</div><div class="line">            <span class="keyword">for</span>(; j &lt; num; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">string</span> word = s.substr(i + j * len, len);</div><div class="line">                <span class="keyword">if</span>(counts.find(word) != counts.end())</div><div class="line">                &#123;</div><div class="line">                    seen[word]++;</div><div class="line">                    <span class="keyword">if</span>(seen[word] &gt; counts[word])</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == num)</div><div class="line">                result.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Minimum-Window-Substring"><a href="#Minimum-Window-Substring" class="headerlink" title="Minimum Window Substring"></a>Minimum Window Substring</h3><p><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="external">Description</a>: Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).<br>For example, S = “ADOBECODEBANC”, T = “ABC”, Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">1.用两个“指针”begin、end指向s中字符代表一个窗口</span></div><div class="line"><span class="comment">2.移动end指针搜索有效窗口(窗口中包含t中所有字符)</span></div><div class="line"><span class="comment">3.移动begin指针缩小有效窗口范围</span></div><div class="line"><span class="comment">为了让[begin, end)窗口成为一个有效窗口，需要一个映射表map(char, count)，存储t中每个字符出现的次数（t中字符可重复），</span></div><div class="line"><span class="comment">并定义一个counter统计t中的字符数，如果s中出现t中字符，即map[s[end]]&gt;0，则counter--，直至counter为0，说明已获取一个</span></div><div class="line"><span class="comment">有效窗口，因此移动begin指针缩小窗口范围。一个比较关键的步骤就是end指针每次步进前，都会执行map[s[end]]--操作，这样</span></div><div class="line"><span class="comment">如果t中已不存在对应字符，就会使得该字符的统计数为负。在得到一个有效的窗口（counter=0）时，判断现有窗口和之前窗口的</span></div><div class="line"><span class="comment">大小，取窗口较小值，并记录起始位置head=begin，如果遇到map[s[begin]] == 0，说明遇到了t中一个字符且该字符为有效窗口的</span></div><div class="line"><span class="comment">左边界，begin指针再往前走，窗口中就不包含t中所有字符，因此counter计数值自增。和end指针一样，begin指针每次步进前都要</span></div><div class="line"><span class="comment">执行map[s[begin]]++操作，对于s="bba",t="ba"，t中字符'b'只出现一次，而s中出现两次，end指针的map[s[end]]--操作使得</span></div><div class="line"><span class="comment">map['b']&lt;0，因此begin指针在步进时需要逐步恢复每个字符的统计值。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</div><div class="line">        <span class="comment">//vector&lt;int&gt; map(128, 0);</span></div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++)</div><div class="line">            <span class="built_in">map</span>[t[i]]++;</div><div class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, begin = <span class="number">0</span>, end = <span class="number">0</span>, len = INT_MAX, count = t.size();</div><div class="line">        <span class="keyword">while</span>(end &lt; s.size())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[end]] &gt; <span class="number">0</span>)</div><div class="line">                count--;</div><div class="line">            <span class="built_in">map</span>[s[end]]--;</div><div class="line">            end++;</div><div class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(end - begin &lt; len)</div><div class="line">                &#123;</div><div class="line">                    head = begin;</div><div class="line">                    len = end - begin;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin]] == <span class="number">0</span>)</div><div class="line">                    count++;</div><div class="line">                <span class="built_in">map</span>[s[begin]]++;</div><div class="line">                begin++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> len == INT_MAX ? <span class="string">""</span> : s.substr(head, len);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// See https://leetcode.com/problems/minimum-window-substring/discuss/26808</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">可读性较差的简化版本</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: t) <span class="built_in">map</span>[c]++;</div><div class="line">    <span class="keyword">int</span> counter=t.size(), begin=<span class="number">0</span>, end=<span class="number">0</span>, d=INT_MAX, head=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]--&gt;<span class="number">0</span>) counter--; <span class="comment">//in t</span></div><div class="line">        <span class="keyword">while</span>(counter==<span class="number">0</span>)&#123; <span class="comment">//valid</span></div><div class="line">            <span class="keyword">if</span>(end-begin&lt;d)  d=end-(head=begin);</div><div class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++==<span class="number">0</span>) counter++;  <span class="comment">//make it invalid</span></div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> d==INT_MAX? <span class="string">""</span>:s.substr(head, d);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/***************子串搜索的模板*******************/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For most substring problem, we are given a string and need to find a substring of it which satisfy some restrictions. </span></div><div class="line"><span class="comment">A general way is to use a hashmap assisted with two pointers. The template is given below.</span></div><div class="line"><span class="comment">**/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> counter; <span class="comment">// check whether the substring is valid</span></div><div class="line">    <span class="keyword">int</span> begin=<span class="number">0</span>, end=<span class="number">0</span>; <span class="comment">//two pointers, one point to tail and one  head</span></div><div class="line">    <span class="keyword">int</span> d; <span class="comment">//the length of substring</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>() &#123; <span class="comment">/* initialize the hash map here */</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]-- ?)&#123;  <span class="comment">/* modify counter here */</span> &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(<span class="comment">/* counter condition */</span>)&#123; </div><div class="line">             </div><div class="line">             <span class="comment">/* update d here if finding minimum*/</span></div><div class="line"></div><div class="line">            <span class="comment">//increase begin to make it invalid/valid again</span></div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]++ ?)&#123; <span class="comment">/*modify counter here*/</span> &#125;</div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        <span class="comment">/* update d here if finding maximum*/</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">One thing needs to be mentioned is that when asked to find maximum substring, we should update maximum after the inner </span></div><div class="line"><span class="comment">while loop to guarantee that the substring is valid. On the other hand, when asked to find minimum substring, we should </span></div><div class="line"><span class="comment">update minimum inside the inner while loop.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">The code of solving Longest Substring with At Most Two Distinct Characters is below:</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>, <span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </div><div class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++==<span class="number">0</span>) counter++;</div><div class="line">        <span class="keyword">while</span>(counter&gt;<span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]--==<span class="number">1</span>) counter--;</div><div class="line">        d=max(d, end-begin);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">The code of solving Longest Substring Without Repeating Characters is below:</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">map</span>(<span class="number">128</span>,<span class="number">0</span>);</div><div class="line">    <span class="keyword">int</span> counter=<span class="number">0</span>, begin=<span class="number">0</span>, end=<span class="number">0</span>, d=<span class="number">0</span>; </div><div class="line">    <span class="keyword">while</span>(end&lt;s.size())&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[s[end++]]++&gt;<span class="number">0</span>) counter++; </div><div class="line">        <span class="keyword">while</span>(counter&gt;<span class="number">0</span>) <span class="keyword">if</span>(<span class="built_in">map</span>[s[begin++]]--&gt;<span class="number">1</span>) counter--;</div><div class="line">        d=max(d, end-begin); <span class="comment">//while valid, update d</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="external">Description</a>: Given a string, find the length of the longest substring without repeating characters.<br>Examples:<br>Given “abcabcbb”, the answer is “abc”, which the length is 3.<br>Given “bbbbb”, the answer is “b”, with the length of 1.<br>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring,<br>“pwke” is a subsequence and not a substring.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>, len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(end &lt; s.length())</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">map</span>[s[end]]++;</div><div class="line">        <span class="keyword">while</span>(<span class="built_in">map</span>[s[end]] &gt; <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">map</span>[s[begin]]--;</div><div class="line">            begin++;</div><div class="line">        &#125;</div><div class="line">        end++;</div><div class="line">        <span class="keyword">if</span>(end - begin &gt; len)</div><div class="line">            len = end - begin;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</div><div class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.length(); i++) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (dict[s[i]] &gt; start)</div><div class="line">            start = dict[s[i]];</div><div class="line">        dict[s[i]] = i;</div><div class="line">        maxLen = max(maxLen, i - start);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="external">Description</a>: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>Example 1: Input: “babad”, Output: “bab”, Note: “aba” is also a valid answer.<br>Example 2: Input: “cbbd”, Output: “bb”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*reference</span></div><div class="line"><span class="comment">依次遍历字符串中的元素，并以该元素为中心点向两边搜索，判断两边元素是否对称，并延伸至最大长度，</span></div><div class="line"><span class="comment">而且在中心点处考虑了重复元素（连续出现）的情况</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (s.empty()) </div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span> (s.size() == <span class="number">1</span>) </div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    <span class="keyword">int</span> min_start = <span class="number">0</span>, max_len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (s.size() - i &lt;= max_len / <span class="number">2</span>)    </div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">int</span> j = i, k = i;</div><div class="line">        <span class="keyword">while</span> (k &lt; s.size()<span class="number">-1</span> &amp;&amp; s[k+<span class="number">1</span>] == s[k])    <span class="comment">// Skip duplicate characters.</span></div><div class="line">            ++k; </div><div class="line">        i = k + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (k &lt; s.size()<span class="number">-1</span> &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; s[k + <span class="number">1</span>] == s[j - <span class="number">1</span>])     <span class="comment">// Expand.</span></div><div class="line">        &#123; </div><div class="line">            ++k; </div><div class="line">            --j; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> new_len = k - j + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (new_len &gt; max_len)</div><div class="line">        &#123; </div><div class="line">            min_start = j; </div><div class="line">            max_len = new_len; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s.substr(min_start, max_len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*依次遍历字符串中每个字符，以该字符为起点，截取剩余长度子串，判断是否为回文序列，若不是，则子串长度递减，</span></div><div class="line"><span class="comment">直至不大于当前最长的回文序列；在外层循环中，若剩余长度不大于当前最长回文串的长度，则直接退出，时间复杂度O(N^2)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(s.length() &lt;= <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    <span class="keyword">int</span> lenS = s.length(), start = <span class="number">0</span>, maxLen = <span class="number">1</span>, len = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(len = lenS - i; len &gt; maxLen; len--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> mid = i + len / <span class="number">2</span>;</div><div class="line">            <span class="keyword">int</span> j = i, k = i + len - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(; j &lt; mid &amp;&amp; s[j] == s[k]; j++, k--);</div><div class="line">            <span class="keyword">if</span>(j == mid &amp;&amp; len &gt; maxLen)</div><div class="line">            &#123;</div><div class="line">                start = i;</div><div class="line">                maxLen = len;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(len &lt; maxLen)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> s.substr(start, maxLen);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Palindromic-Substrings"><a href="#Palindromic-Substrings" class="headerlink" title="Palindromic Substrings"></a>Palindromic Substrings</h3><p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="external">Description</a>: Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.<br>Example 1: Input: “abc”, Output: 3. Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2: Input: “aaa”, Output: 6. Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.<br>Note: The input string length won’t exceed 1000.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</div><div class="line">        &#123;</div><div class="line">            countPalindrome(s, i, i, count);</div><div class="line">            countPalindrome(s, i, i + <span class="number">1</span>, count);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>&amp; count)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left] == s[right])</div><div class="line">        &#123;</div><div class="line">            count++;</div><div class="line">            left--;</div><div class="line">            right++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Group-Anagrams"><a href="#Group-Anagrams" class="headerlink" title="Group Anagrams"></a>Group Anagrams</h3><p><a href="https://leetcode.com/problems/group-anagrams/description/" target="_blank" rel="external">Description</a>: Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:<br>[<br>  [“ate”, “eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note: All inputs will be in lower-case.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">将每个字符串进行排序，并将排序后的字符串作为hash键值，对原始字符串进行索引分类</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="built_in">map</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="built_in">string</span> str : strs)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">string</span> word = str;</div><div class="line">        sort(word.begin(), word.end());</div><div class="line">        <span class="built_in">map</span>[word].push_back(str);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = <span class="built_in">map</span>.begin(); iter != <span class="built_in">map</span>.end(); iter++)</div><div class="line">    &#123;</div><div class="line">        results.push_back(iter-&gt;second);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中字符串(String)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="two pointers" scheme="https://senitco.github.io/tags/two-pointers/"/>
    
      <category term="string" scheme="https://senitco.github.io/tags/string/"/>
    
      <category term="hash table" scheme="https://senitco.github.io/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>数组(Array)和双指针</title>
    <link href="https://senitco.github.io/2018/03/29/data-structure-array-two-pointers/"/>
    <id>https://senitco.github.io/2018/03/29/data-structure-array-two-pointers/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.880Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中数组（Array）问题总结归纳。<br><a id="more"></a></p>
<h3 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="external">Description</a>: Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>Example: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*直接使用STL的unique函数，不过向量的size不会改变，需重新计数*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">auto</span> iters = unique(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = nums.begin(); it != iters; it++, cnt++);</div><div class="line">        <span class="keyword">return</span> cnt;           </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//借助快慢指针</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)    </div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] != nums[j])</div><div class="line">            nums[++i] = nums[j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(nums[i] != nums[i - <span class="number">1</span>])</div><div class="line">            nums[cnt++] = nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Remove-Duplicates-from-Sorted-Array-II"><a href="#Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Remove Duplicates from Sorted Array II"></a>Remove Duplicates from Sorted Array II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="external">Description</a>: Follow up for “Remove Duplicates”: What if duplicates are allowed at most twice?</p>
<p>For example, Given sorted array nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">sum变量统计所有有效元素的个数，count变量统计连续相同元素的个数，如果超过两个，则只在sum后面复制两个相同元素</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();)</div><div class="line">        &#123;</div><div class="line">            count = <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(i + count &lt; nums.size() &amp;&amp; nums[i + count] == nums[i])</div><div class="line">                count++;</div><div class="line">            i += count;</div><div class="line">            count = count &gt; <span class="number">2</span> ? <span class="number">2</span> : count;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = sum; j &lt; sum + count; j++)</div><div class="line">                nums[j] = nums[i - count];  </div><div class="line">            sum += count;        </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">i为慢指针，j为快指针，cnt统计重复元素出现的次数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.size() &lt;= <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span> nums.size();</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.size();)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt; nums.size() &amp;&amp; nums[i] == nums[j])</div><div class="line">        &#123;</div><div class="line">            cnt++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            nums[i + <span class="number">1</span>] = nums[i];</div><div class="line">            <span class="keyword">if</span>(j &lt; nums.size())     <span class="comment">//需要考虑边界情况，否则会越界</span></div><div class="line">            &#123;</div><div class="line">                nums[i + <span class="number">2</span>] = nums[j];</div><div class="line">                i = i + <span class="number">2</span>;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                i++;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            nums[i + <span class="number">1</span>] = nums[j];</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">只保留k个相同元素的通用解法，注意数组是已经经过排序的</span></div><div class="line"><span class="comment">n表示fast指针，用于遍历每一个元素；i则是slow指针，表示有效元素的个数，</span></div><div class="line"><span class="comment">并在遍历过程中，逐个添加有效元素</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</div><div class="line">            <span class="keyword">if</span> (i &lt; k || n &gt; nums[i-k])</div><div class="line">                nums[i++] = n;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">i表示fast指针，j表示slow指针</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.size() &lt;= k)</div><div class="line">            <span class="keyword">return</span> nums.size();</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>, i = <span class="number">1</span>, j = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; nums.size())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] != nums[i - <span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                cnt = <span class="number">1</span>;</div><div class="line">                nums[j++] = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt &lt; k)</div><div class="line">            &#123;</div><div class="line">                nums[j++] = nums[i];</div><div class="line">                cnt++;</div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> j;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Sort-Colors"><a href="#Sort-Colors" class="headerlink" title="Sort Colors"></a>Sort Colors</h3><p><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="external">Description</a>: Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br>Note: You are not suppose to use the library’s sort function for this problem.<br>Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s<br>and followed by 2’s. Could you come up with an one-pass algorithm using only constant space?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">一次遍历，借助两个“指针”，分别指向调整位置后，0的下一个元素和2的前一个元素，对2的判断一定要在0之前，如果当前元素是2，</span></div><div class="line"><span class="comment">那么将后面的元素调整至当前位置时，还需进一步判断该元素是否为0；如果当前元素是0，那么将前面的元素调整至当前位置时，</span></div><div class="line"><span class="comment">不需要再判断该元素的值，因为前面的元素是确定的已经经过判断的，只可能为1或者0</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>, two = nums.size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= two; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(nums[i] == <span class="number">2</span> &amp;&amp; i &lt; two) swap(nums[i], nums[two--]);</div><div class="line">            <span class="keyword">while</span>(nums[i] == <span class="number">0</span> &amp;&amp; i &gt; zero) swap(nums[i], nums[zero++]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中数组（Array）问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
      <category term="two pointers" scheme="https://senitco.github.io/tags/two-pointers/"/>
    
  </entry>
  
  <entry>
    <title>链表问题集锦（三）</title>
    <link href="https://senitco.github.io/2018/03/28/data-structure-linkedlist-3/"/>
    <id>https://senitco.github.io/2018/03/28/data-structure-linkedlist-3/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.887Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中经典链表问题总结归纳。<br><a id="more"></a></p>
<h3 id="Remove-Duplicates-from-Sorted-List"><a href="#Remove-Duplicates-from-Sorted-List" class="headerlink" title="Remove Duplicates from Sorted List"></a>Remove Duplicates from Sorted List</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="external">Description</a>: Given a sorted linked list, delete all duplicates such that each element appear only once.<br>Example 1: Input: 1-&gt;1-&gt;2, Output: 1-&gt;2<br>Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3, Output: 1-&gt;2-&gt;3<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode *pNode = head;</div><div class="line">    ListNode *pNext = pNode;</div><div class="line">    <span class="keyword">while</span>(pNode)</div><div class="line">    &#123;</div><div class="line">        pNext = pNode-&gt;next;</div><div class="line">        <span class="keyword">if</span>(pNext &amp;&amp; pNode-&gt;val == pNext-&gt;val)</div><div class="line">        &#123;</div><div class="line">            pNode-&gt;next = pNext-&gt;next;</div><div class="line">            <span class="keyword">delete</span> pNext;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pNode = pNext;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Remove-Duplicates-from-Sorted-List-II"><a href="#Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Remove Duplicates from Sorted List II"></a>Remove Duplicates from Sorted List II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="external">Description</a>: Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.<br>For example, Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5. Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">利用两个指针pre、cur，pre指向重复元素区间的前一个元素，cur指向区间内的最后一个元素，比较cur指针相邻元素的值，如果不存在重复元素，则有pre-&gt;next = cur，移动pre指针继续遍历，即pre = pre-&gt;next；否则去掉重复元素，使pre-&gt;next = cur-&gt;next</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    ListNode *pNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    pNode-&gt;next = head;</div><div class="line">    ListNode *pre = pNode, *cur = head;</div><div class="line">    <span class="keyword">while</span>(cur)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        <span class="keyword">if</span>(pre-&gt;next == cur)</div><div class="line">            pre = pre-&gt;next;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pre-&gt;next = cur-&gt;next;</div><div class="line">        cur = cur-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pNode-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Rotate-List"><a href="#Rotate-List" class="headerlink" title="Rotate List"></a>Rotate List</h3><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="external">Description</a>: Given a list, rotate the list to the right by k places, where k is non-negative.<br>Example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2, return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">此处没必要利用快慢指针来定位到倒数第k个位置，因为k值可能大于链表结点数，所以必须先遍历一次获取链表的长度，</span></div><div class="line"><span class="comment">然后取模相减，得到需要移动的步长(len - k % len)，在第一次遍历至链表尾时，可直接将链表首尾相连，然后继续移动</span></div><div class="line"><span class="comment">(len - k % len)个步长，记录首结点指针start=tail-&gt;next，并使tail=NULL，解除环形</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!head)</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">        ListNode *start = head, *tail = head;</div><div class="line">        <span class="keyword">while</span>(tail-&gt;next)</div><div class="line">        &#123;</div><div class="line">            tail = tail-&gt;next;</div><div class="line">            len++;</div><div class="line">        &#125;</div><div class="line">        tail-&gt;next = head;  <span class="comment">//首尾相连</span></div><div class="line">        k = k % len;    <span class="comment">//k值可大于结点数</span></div><div class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k; i++)</div><div class="line">                tail = tail-&gt;next;</div><div class="line">        &#125;</div><div class="line">        start = tail-&gt;next;</div><div class="line">        tail-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//解除环形</span></div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中经典链表问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="linked list" scheme="https://senitco.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>数组(Array)和动态规划</title>
    <link href="https://senitco.github.io/2018/03/26/data-structure-array-dp/"/>
    <id>https://senitco.github.io/2018/03/26/data-structure-array-dp/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.880Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中数组（Array）问题总结归纳。<br><a id="more"></a></p>
<h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="external">Description</a>: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP解法：由于只能向下或向右移动，第一行第一列均为1，且满足关系式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; path(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">1</span>));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</div><div class="line">            path[i][j] = path[i - <span class="number">1</span>][j] + path[i][j - <span class="number">1</span>];</div><div class="line">    <span class="keyword">return</span> path[m - <span class="number">1</span>][n - <span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">公式解法：从(1, 1)到(m, n)一共要走 N = (m-1)+(n-1) = m+n-2 步，其中往下走 k = (m-1) 步，</span></div><div class="line"><span class="comment">因此一共有Combination(N, k) = n! / (k!(n - k)!)种组合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> N = n + m - <span class="number">2</span>;<span class="comment">// how much steps we need to do</span></div><div class="line">        <span class="keyword">int</span> k = m - <span class="number">1</span>; <span class="comment">// number of steps that need to go down</span></div><div class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</div><div class="line">        <span class="comment">// here we calculate the total possible path number </span></div><div class="line">        <span class="comment">// Combination(N, k) = n! / (k!(n - k)!)</span></div><div class="line">        <span class="comment">// reduce the numerator and denominator and get</span></div><div class="line">        <span class="comment">// C = ( (n - k + 1) * (n - k + 2) * ... * n ) / k!</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</div><div class="line">            res = res * (N - k + i) / i;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h3><p><a href="https://leetcode.com/problems/unique-paths-ii/description/" target="_blank" rel="external">Description</a>: Follow up for “Unique Paths”: Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid.<br>For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>The total number of unique paths is 2. Note: m and n will be at most 100.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">有障碍物的位置有效路径数为0，第一行第一列需特殊处理，只要某点存在障碍物，则该点及该点之后取值均为0</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rows = obstacleGrid.size(), cols = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; paths(rows, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols, <span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows &amp;&amp; obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>; i++)</div><div class="line">            paths[i][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols &amp;&amp; obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span>; j++)</div><div class="line">            paths[<span class="number">0</span>][j] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</div><div class="line">                    paths[i][j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    paths[i][j] = paths[i - <span class="number">1</span>][j] + paths[i][j - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> paths[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">每次考虑一行的dp取值，并累加更新</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(obstacleGrid.empty())</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path(n, <span class="number">0</span>);</div><div class="line">        path[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</div><div class="line">                    path[j] = <span class="number">0</span>;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</div><div class="line">                    path[j] += path[j - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> path[n - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">增加额外的第0行第0列，并使dp[0][1]取值为1，然后判断有无障碍物来更新dp值</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(obstacleGrid.empty())</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</div><div class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; m + <span class="number">1</span>; ++i)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; n + <span class="number">1</span>; ++j)</div><div class="line">                <span class="keyword">if</span>(!obstacleGrid[i - <span class="number">1</span>][j - <span class="number">1</span>])</div><div class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h3><p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="external">Description</a>: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time.<br>Example 1:<br>[[1,3,1],<br> [1,5,1],<br> [4,2,1]]<br>Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP方法：由于只能向右或向下移动，最短路径满足关系式path[i][j] = min(path[i - 1][j], path[i][j - 1]) + grid[i - 1][j - 1]</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(grid.size() == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> rows = grid.size(), cols = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(rows + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols + <span class="number">1</span>, INT_MAX));</div><div class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows + <span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols + <span class="number">1</span>; j++)</div><div class="line">            &#123;</div><div class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j] , dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[rows][cols];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">上述方法的空间简化版本，只需要O(m)的线性空间</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(grid.empty())    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur(m, grid[<span class="number">0</span>][<span class="number">0</span>]);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</div><div class="line">            cur[i] = cur[i - <span class="number">1</span>] + grid[i][<span class="number">0</span>]; </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</div><div class="line">            cur[<span class="number">0</span>] += grid[<span class="number">0</span>][j]; </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</div><div class="line">                cur[i] = min(cur[i - <span class="number">1</span>], cur[i]) + grid[i][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cur[m - <span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Largest-Rectangle-in-Histogram"><a href="#Largest-Rectangle-in-Histogram" class="headerlink" title="Largest Rectangle in Histogram"></a>Largest Rectangle in Histogram</h3><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/description/" target="_blank" rel="external">Description</a>: Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. For example, Given heights = [2,1,5,6,2,3], return 10.</p>
<p><img src="https://github.com/SenitCo/Algorithm/blob/master/images/84_histogram_area.png" align="center"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">定义一个存储索引的数组(stack)——index，如果原数组中高度依次递增，则将对应索引push到index中，否则从栈顶</span></div><div class="line"><span class="comment">依次取出元素计算面积</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> area = <span class="number">0</span>, maxArea = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</div><div class="line">        heights.push_back(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++)</div><div class="line">        &#123;   <span class="comment">//index中元素对应高度必定是递增的</span></div><div class="line">            <span class="keyword">while</span>(index.size() &gt; <span class="number">0</span> &amp;&amp; heights[index.back()] &gt;= heights[i])</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> h = heights[index.back()];  <span class="comment">//h必定是当前取出的高度最小值</span></div><div class="line">                index.pop_back();</div><div class="line">                <span class="comment">//begin表示计算面积区间的前一个索引，i是区间的后一个索引，整个区间范围为(i-begin-1)</span></div><div class="line">                <span class="keyword">int</span> begin = index.size() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;   </div><div class="line">                area = (i - begin - <span class="number">1</span>) * h;</div><div class="line">                <span class="keyword">if</span>(area &gt; maxArea)</div><div class="line">                    maxArea = area;</div><div class="line">            &#125;</div><div class="line">            index.push_back(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Maximal-Rectangle"><a href="#Maximal-Rectangle" class="headerlink" title="Maximal Rectangle"></a>Maximal Rectangle</h3><p><a href="https://leetcode.com/problems/maximal-rectangle/discuss/29054" target="_blank" rel="external">Description</a>: Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example, given the following matrix:</span></div><div class="line"><span class="comment">1 0 1 0 0</span></div><div class="line"><span class="comment">1 0 1 1 1</span></div><div class="line"><span class="comment">1 1 1 1 1</span></div><div class="line"><span class="comment">1 0 0 1 0</span></div><div class="line"><span class="comment">Return 6.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">See https://leetcode.com/problems/maximal-rectangle/discuss/29054</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.empty())  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.size();</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n, <span class="number">0</span>), right(n, n), height(n, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> curLeft = <span class="number">0</span>, curRight = n;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)</div><div class="line">                    height[j]++;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    height[j] = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)</div><div class="line">                    left[j] = max(left[j], curLeft);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    left[j] = <span class="number">0</span>;</div><div class="line">                    curLeft = j + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)</div><div class="line">                    right[j] = min(right[j], curRight);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    right[j] = n;</div><div class="line">                    curRight = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                maxArea = max(maxArea, (right[j] - left[j]) * height[j]);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">采用Largest Rectangle in Histogram中的方法：逐行遍历，计算每一行中元素的高度（纵向连续为'1'的个数），</span></div><div class="line"><span class="comment">然后将其视为一个计算直方图中最大矩形面积的问题求解</span></div><div class="line"><span class="comment">See https://leetcode.com/problems/maximal-rectangle/discuss/29064</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.empty())  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.size();</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> rectWidth = <span class="number">0</span>, rectHeight = <span class="number">0</span>, maxArea = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; index;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(j &lt; n)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)</div><div class="line">                        height[j]++;</div><div class="line">                    <span class="keyword">else</span></div><div class="line">                        height[j] = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="keyword">while</span>(!index.empty() &amp;&amp; height[index.top()] &gt;= height[j])   </div><div class="line">                &#123;</div><div class="line">                    rectHeight = height[index.top()];</div><div class="line">                    index.pop();</div><div class="line">                    rectWidth = index.empty() ? j : j - index.top() - <span class="number">1</span>;</div><div class="line">                    <span class="keyword">if</span>(rectWidth * rectHeight &gt; maxArea)</div><div class="line">                        maxArea = rectWidth * rectHeight;</div><div class="line">                &#125;</div><div class="line">                index.push(j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中数组（Array）问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
      <category term="stack" scheme="https://senitco.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>数组(Array)和排序</title>
    <link href="https://senitco.github.io/2018/03/25/data-structure-array-sort/"/>
    <id>https://senitco.github.io/2018/03/25/data-structure-array-sort/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.880Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中数组（Array）问题总结归纳。<br><a id="more"></a></p>
<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p>Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18].<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for an interval.</span></div><div class="line"><span class="comment"> * struct Interval &#123;</span></div><div class="line"><span class="comment"> *     int start;</span></div><div class="line"><span class="comment"> *     int end;</span></div><div class="line"><span class="comment"> *     Interval() : start(0), end(0) &#123;&#125;</span></div><div class="line"><span class="comment"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="comment">//先按元组第一个元素排序，然后判断相邻元组是否存在重叠区间</span></div><div class="line"><span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;Interval&gt; result;</div><div class="line">    <span class="keyword">int</span> size = intervals.size();</div><div class="line">    sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> Interval&amp; r1, <span class="keyword">const</span> Interval&amp; r2) &#123;<span class="keyword">return</span> r1.start &lt; r2.start; &#125;);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size;)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(; j &lt; size &amp;&amp; intervals[i].end &gt;= intervals[j].start; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(intervals[j].end &gt; intervals[i].end)</div><div class="line">                intervals[i].end = intervals[j].end;</div><div class="line">        &#125;</div><div class="line">        result.push_back(intervals[i]);</div><div class="line">        i = j;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Interval&gt; merge(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(intervals.size() &lt;= <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> intervals;</div><div class="line">    <span class="built_in">vector</span>&lt;Interval&gt; result;</div><div class="line">    sort(intervals.begin(), intervals.end(), [](<span class="keyword">const</span> Interval&amp; r1, <span class="keyword">const</span> Interval&amp; r2) &#123;<span class="keyword">return</span> r1.start &lt; r2.start; &#125;);</div><div class="line">    <span class="function">Interval <span class="title">tmp</span><span class="params">(intervals[<span class="number">0</span>])</span></span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(tmp.end &gt;= intervals[i].start)</div><div class="line">            tmp.end = max(tmp.end, intervals[i].end);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            result.push_back(tmp);</div><div class="line">            tmp = intervals[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    result.push_back(tmp);  <span class="comment">//添加最后一个元组</span></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times.<br>Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].<br>Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">先拷贝newInterval前的所有元素，然后比较新元素和数组中每一个元素的大小，start取较小值，end取较大值，</span></div><div class="line"><span class="comment">直到newInterval.end &lt; intervals[i].start，然后拷贝剩余元素，很直观的方法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="built_in">vector</span>&lt;Interval&gt; insert(<span class="built_in">vector</span>&lt;Interval&gt;&amp; intervals, Interval newInterval) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;Interval&gt; result;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(; i &lt; intervals.size() &amp;&amp; intervals[i].end &lt; newInterval.start; i++)</div><div class="line">        result.push_back(intervals[i]);</div><div class="line">    <span class="keyword">for</span>(; i &lt; intervals.size() &amp;&amp; intervals[i].start &lt;= newInterval.end; i++)</div><div class="line">    &#123;</div><div class="line">        newInterval.start = min(newInterval.start, intervals[i].start);</div><div class="line">        newInterval.end = max(newInterval.end, intervals[i].end);</div><div class="line">    &#125;</div><div class="line">    result.push_back(newInterval);</div><div class="line">    <span class="keyword">for</span>(; i &lt; intervals.size(); i++)</div><div class="line">        result.push_back(intervals[i]);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中数组（Array）问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
      <category term="sort" scheme="https://senitco.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>链表排序</title>
    <link href="https://senitco.github.io/2018/03/24/data-structure-sort-linkedlist/"/>
    <id>https://senitco.github.io/2018/03/24/data-structure-sort-linkedlist/</id>
    <published>2018-03-23T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.888Z</updated>
    
    <content type="html"><![CDATA[<p>链表排序问题总结归纳。<br><a id="more"></a></p>
<h3 id="Merge-Sorted-Array"><a href="#Merge-Sorted-Array" class="headerlink" title="Merge Sorted Array"></a>Merge Sorted Array</h3><p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="external">Description</a>: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">nums1空间足够，可从后往前比较两个数组，并从nums1(m+n-1)尾部开始填充较大值，如果nums1数组遍历结束，只剩下nums2数组，则逐个复制</span></div><div class="line"><span class="comment">nums2剩下元素，如果nums2数组遍历结束，只剩下nums1数组，则不需要额外处理，因为合并后的元素都是存在nums1中</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">    <span class="keyword">int</span> i </span>= m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</div><div class="line">        &#123;</div><div class="line">            nums1[k] = nums1[i];</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            nums1[k] = nums2[j];</div><div class="line">            j--;</div><div class="line">        &#125;          </div><div class="line">        k--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</div><div class="line">        nums1[k--] = nums2[j--];          </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">调用STL函数merge，注意合并后的元素不能直接填充到nums1中，需要另外定义一个数组存储空间</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(m + n);</div><div class="line">    <span class="built_in">std</span>::merge(nums1.begin(), nums1.begin() + m, nums2.begin(), nums2.begin() + n, result.begin());</div><div class="line">    nums1 = result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="external">Description</a>: Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.<br>Example:<br>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * struct ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode *next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></div><div class="line"><span class="comment"> * &#125;;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode *pNode = start;</div><div class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)</div><div class="line">            &#123;</div><div class="line">                pNode-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                pNode-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            pNode = pNode-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(l1)  </div><div class="line">            pNode-&gt;next = l1;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pNode-&gt;next = l2;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> start-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*递归解法*/</span></div><div class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</div><div class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) </div><div class="line">    &#123;</div><div class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</div><div class="line">        <span class="keyword">return</span> l1;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">    &#123;</div><div class="line">        l2-&gt;next = mergeTwoLists(l2-&gt;next, l1);</div><div class="line">        <span class="keyword">return</span> l2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><p><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="external">Description</a>: Sort a linked list in O(n log n) time using constant space complexity.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">归并排序的递归解法，不符合要求，空间复杂度为O(logn)，自顶向下执行</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        ListNode *prev = <span class="literal">NULL</span>, *slow, *fast;</div><div class="line">        slow = fast = head;</div><div class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</div><div class="line">        &#123;</div><div class="line">            prev = slow;</div><div class="line">            slow = slow-&gt;next;</div><div class="line">            fast = fast-&gt;next-&gt;next;    <span class="comment">//快指针每次走两步，最终慢指针指向链表中间</span></div><div class="line">        &#125;</div><div class="line">        prev-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        ListNode* l1 = sortList(head);</div><div class="line">        ListNode* l2 = sortList(slow);</div><div class="line">        <span class="keyword">return</span> mergeList(l1, l2);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        ListNode* node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* p = node;</div><div class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</div><div class="line">            &#123;</div><div class="line">                p-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                p-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            p = p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(l1)</div><div class="line">            p-&gt;next = l1;</div><div class="line">        <span class="keyword">if</span>(l2)</div><div class="line">            p-&gt;next = l2;</div><div class="line">        <span class="keyword">return</span> node-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">归并排序的迭代解法，空间复杂度为O(1)，自底向上执行</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> head;</div><div class="line">        ListNode *cur = head;</div><div class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(cur)</div><div class="line">        &#123;</div><div class="line">            length++;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ListNode *start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        start-&gt;next = head;</div><div class="line">        ListNode *left, *right, *tail;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; length; step &lt;&lt;= <span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            cur = start-&gt;next;</div><div class="line">            tail = start;</div><div class="line">            <span class="keyword">while</span>(cur)  <span class="comment">//每次两两归并，得到一个有序序列</span></div><div class="line">            &#123;</div><div class="line">                left = cur;</div><div class="line">                right = split(left, step);</div><div class="line">                cur = split(right, step);</div><div class="line">                tail = merge(left, right, tail);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> start-&gt;next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//将链表划分为两个链表，每个链表n个元素，并返回下一个链表的首部</span></div><div class="line">    <span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; head &amp;&amp; i &lt; n; i++)</div><div class="line">            head = head-&gt;next;</div><div class="line">        <span class="keyword">if</span>(!head)    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        ListNode* second = head-&gt;next;</div><div class="line">        head-&gt;next = <span class="literal">NULL</span>;  </div><div class="line">        <span class="keyword">return</span> second;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//合并两个链表，并返回合并后的链表的尾部，即下一个链表的首部</span></div><div class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2, ListNode* head)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        ListNode* cur = head;</div><div class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</div><div class="line">            &#123;</div><div class="line">                cur-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                cur-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;next;</div><div class="line">        &#125;</div><div class="line">        cur-&gt;next = l1 ? l1 : l2;</div><div class="line">        <span class="keyword">while</span>(cur-&gt;next)  cur = cur-&gt;next;</div><div class="line">        <span class="keyword">return</span> cur;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h3><p><a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="external">Description</a>: Sort a linked list using insertion sort.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    ListNode *start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode *cur = head, *pre = start, *next = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(cur)</div><div class="line">    &#123;</div><div class="line">        pre = start;</div><div class="line">        <span class="keyword">while</span>(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val)</div><div class="line">            pre = pre-&gt;next;</div><div class="line">        next = cur-&gt;next;</div><div class="line">        cur-&gt;next = pre-&gt;next;</div><div class="line">        pre-&gt;next = cur;</div><div class="line">        cur = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> start-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a>Merge k Sorted Lists</h3><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="external">Description</a>: Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//借助堆来实现，每个链表是有序的，堆中包含k个元素，分别是每个链表中最小的的元素，因此每次可以从堆中取出一个最小的元素</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* pNode = start;</div><div class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; minHeap;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter : lists)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(iter)</div><div class="line">                minHeap.push_back(iter);</div><div class="line">        &#125;</div><div class="line">        make_heap(minHeap.begin(), minHeap.end(), cmp());</div><div class="line">        <span class="keyword">while</span>(!minHeap.empty())</div><div class="line">        &#123;</div><div class="line">            pNode-&gt;next = minHeap.front();</div><div class="line">            pNode = pNode-&gt;next;</div><div class="line">            pop_heap(minHeap.begin(), minHeap.end(), cmp());</div><div class="line">            minHeap.pop_back();</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(pNode-&gt;next)</div><div class="line">                minHeap.push_back(pNode-&gt;next);</div><div class="line">            push_heap(minHeap.begin(), minHeap.end(), cmp());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> start-&gt;next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></div><div class="line"><span class="class">    &#123;</span></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//直接借助优先队列实现（优先队列通过堆来实现）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (lists.empty())</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;     </div><div class="line">        ListNode* start = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* pNode = start;</div><div class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pql;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists)</div><div class="line">            <span class="keyword">if</span>(node)            <span class="comment">//注意此处要判断节点(链表)是否为空</span></div><div class="line">                pql.push(node);</div><div class="line">        <span class="keyword">while</span>(!pql.empty())</div><div class="line">        &#123;</div><div class="line">            pNode-&gt;next = pql.top();</div><div class="line">            pql.pop();</div><div class="line">            pNode = pNode-&gt;next;</div><div class="line">            <span class="keyword">if</span>(pNode-&gt;next != <span class="literal">NULL</span>)</div><div class="line">                pql.push(pNode-&gt;next);</div><div class="line">        &#125;     </div><div class="line">        <span class="keyword">return</span> start-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></div><div class="line"><span class="class">    &#123;</span></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></div><div class="line"><span class="function">        </span>&#123;</div><div class="line">            <span class="keyword">return</span> l1-&gt;val &gt; l2-&gt;val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*递归解法，将有序列表两两合并*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(lists.empty())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(lists.size() &gt; <span class="number">1</span>)&#123;</div><div class="line">            lists.push_back(mergeTwoLists(lists[<span class="number">0</span>], lists[<span class="number">1</span>]));</div><div class="line">            lists.erase(lists.begin());</div><div class="line">            lists.erase(lists.begin());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lists.front();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>)&#123;</div><div class="line">            <span class="keyword">return</span> l2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>)&#123;</div><div class="line">            <span class="keyword">return</span> l1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)</div><div class="line">        &#123;</div><div class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</div><div class="line">            <span class="keyword">return</span> l1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</div><div class="line">            <span class="keyword">return</span> l2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="external">Description</a>: Given a linked list and a value x, partition it such that all nodes less than x come before nodes<br>greater than or equal to x. You should preserve the original relative order of the nodes in each<br>of the two partitions.<br>For example, Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3, return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">借助两个指针，less和greater，分别指向小于目标值的元素和大于等于目标值的元素，遍历一次，即可得到两个链表，</span></div><div class="line"><span class="comment">然后将其合并为一个</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        ListNode* less = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode* greater = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        ListNode *ptr1 = less, *ptr2 = greater, *pNode = head;</div><div class="line">        <span class="keyword">while</span>(pNode)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(pNode-&gt;val &lt; x)</div><div class="line">            &#123;</div><div class="line">                ptr1-&gt;next = pNode;</div><div class="line">                ptr1 = ptr1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                ptr2-&gt;next = pNode;</div><div class="line">                ptr2 = ptr2-&gt;next;</div><div class="line">            &#125;</div><div class="line">            pNode = pNode-&gt;next;</div><div class="line">        &#125;</div><div class="line">        ptr1-&gt;next = greater-&gt;next;</div><div class="line">        ptr2-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> less-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链表排序问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="two pointers" scheme="https://senitco.github.io/tags/two-pointers/"/>
    
      <category term="sort" scheme="https://senitco.github.io/tags/sort/"/>
    
      <category term="linked list" scheme="https://senitco.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>数组(Array)问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/03/22/data-structure-array-1/"/>
    <id>https://senitco.github.io/2018/03/22/data-structure-array-1/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.880Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中数组（Array）问题总结归纳。<br><a id="more"></a></p>
<h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="external">Description</a>: Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory.</p>
<blockquote>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">实现数组的下一个排列：先找到第一个降序的数字，nums[i+1] &gt; nums[i]，然后从后往前找到第一个大于nums[i]的数，记为nums[j]，</span></div><div class="line"><span class="comment">交换nums[i]与nums[j]的值，并翻转 i 后面的元素。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">if</span>(size &lt; <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i = size - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</div><div class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])   <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            reverse(nums.begin(), nums.end());</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(j = size - <span class="number">1</span>; j &gt;= i; j--)</div><div class="line">            <span class="keyword">if</span>(nums[j] &gt; nums[i - <span class="number">1</span>])   <span class="keyword">break</span>;</div><div class="line">        </div><div class="line">        swap(nums[i - <span class="number">1</span>], nums[j]);</div><div class="line">        reverse(nums.begin() + i, nums.end());       </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    next_permutation(begin(nums), end(nums));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Permutation-Sequence"><a href="#Permutation-Sequence" class="headerlink" title="Permutation Sequence"></a>Permutation Sequence</h3><p><a href="https://leetcode.com/problems/permutation-sequence/description/" target="_blank" rel="external">Description</a>: The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order.</p>
<blockquote>
<p>We get the following sequence (ie, for n = 3):<br>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.<br>Note: Given n will be between 1 and 9 inclusive.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">定义两个数组，一个nums存储原始序列&#123;1,2,...n&#125;，一个fact用于存储对应数的阶乘&#123;1!,2!,...n!&#125;，对于n个数组组成的排列，</span></div><div class="line"><span class="comment">共有fact[n]=n!种情况，每个数i为起始的情况共有batch=fact[n]/n=fact[n-1]=(n-1)!，利用(k-1)/batch可求得第一个元素</span></div><div class="line"><span class="comment">的索引为idx=(k-1)/batch+1，即result[0]=nums[(k-1)/batch+1]，将其赋值后，在数组nums中移除对应元素，然后更新相关值，</span></div><div class="line"><span class="comment">继续下一轮迭代</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fact(n + <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        <span class="built_in">string</span> result;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            nums[i] = i;</div><div class="line">            fact[i] = fact[i - <span class="number">1</span>] * i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> idx = k - <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> batch = fact[i] / n;</div><div class="line">            <span class="keyword">int</span> quo = idx / batch;</div><div class="line">            idx = idx % batch;</div><div class="line">            result.push_back(nums[quo + <span class="number">1</span>] + <span class="string">'0'</span>);</div><div class="line">            nums.erase(nums.begin() + quo + <span class="number">1</span>);</div><div class="line">            n--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fact(n + <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        <span class="built_in">string</span> result;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            nums[i] = i;</div><div class="line">            fact[i] = fact[i - <span class="number">1</span>] * i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> idx = k - <span class="number">1</span>, quo = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--)</div><div class="line">        &#123;</div><div class="line">            quo = idx / fact[i - <span class="number">1</span>];    <span class="comment">//将batch直接替换为fact[i-1]</span></div><div class="line">            idx = idx % fact[i - <span class="number">1</span>];</div><div class="line">            result.push_back(nums[quo + <span class="number">1</span>] + <span class="string">'0'</span>);</div><div class="line">            nums.erase(nums.begin() + quo + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Plus-One"><a href="#Plus-One" class="headerlink" title="Plus One"></a>Plus One</h3><p><a href="https://leetcode.com/problems/plus-one/description/" target="_blank" rel="external">Description</a>: Given a non-negative integer represented as a non-empty array of digits, plus one to the integer. You may assume the integer do not contain any leading zero, except the number 0 itself. The digits are stored such that the most significant digit is at the head of the list.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = digits.size();</div><div class="line">    <span class="keyword">int</span> step = <span class="number">1</span>, temp = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">    &#123;</div><div class="line">        temp = digits[i];</div><div class="line">        digits[i] = (temp + step) % <span class="number">10</span>;</div><div class="line">        step = (temp + step) / <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(step &gt; <span class="number">0</span>)</div><div class="line">        digits.insert(digits.begin(), <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> digits;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Spiral-Matrix"><a href="#Spiral-Matrix" class="headerlink" title="Spiral Matrix"></a>Spiral Matrix</h3><p><a href="https://leetcode.com/problems/spiral-matrix/description/" target="_blank" rel="external">Description</a>: Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.<br>For example, Given the following matrix:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>You should return [1,2,3,6,9,8,7,4,5].<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">向右遍历，向下遍历，向左遍历，向上遍历，循环往复，每次遍历结束，修改边界条件；在向左、向上遍历的时候</span></div><div class="line"><span class="comment">需要重新判断一次边界条件，因为在前两次遍历过程中，边界条件已被修改</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        <span class="keyword">if</span>(matrix.empty())</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">int</span> rowBegin = <span class="number">0</span>, rowEnd = matrix.size() - <span class="number">1</span>, colBegin = <span class="number">0</span>, colEnd = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(rowBegin &lt;= rowEnd &amp;&amp; colBegin &lt;= colEnd)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = colBegin; j &lt;= colEnd; j++)</div><div class="line">                result.push_back(matrix[rowBegin][j]);</div><div class="line">            rowBegin++;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rowBegin; i &lt;= rowEnd; i++)</div><div class="line">                result.push_back(matrix[i][colEnd]);</div><div class="line">            colEnd--;</div><div class="line">            <span class="keyword">if</span>(rowBegin &lt;= rowEnd)      <span class="comment">//重新判断条件</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = colEnd; j &gt;= colBegin; j--)</div><div class="line">                    result.push_back(matrix[rowEnd][j]);</div><div class="line">            &#125;</div><div class="line">            rowEnd--;</div><div class="line">            <span class="keyword">if</span>(colBegin &lt;= colEnd)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = rowEnd; i &gt;= rowBegin; i--)</div><div class="line">                    result.push_back(matrix[i][colBegin]);</div><div class="line">            &#125;</div><div class="line">            colBegin++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">When traversing the matrix in the spiral order, at any time we follow one out of the following four directions: </span></div><div class="line"><span class="comment">RIGHT DOWN LEFT UP. Suppose we are working on a 5 x 3 matrix as such:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">0 1 2 3 4 5</span></div><div class="line"><span class="comment">6 7 8 9 10</span></div><div class="line"><span class="comment">11 12 13 14 15</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Imagine a cursor starts off at (0, -1), i.e. the position at ‘0’, then we can achieve the spiral order by doing</span></div><div class="line"><span class="comment">the following:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Go right 5 times</span></div><div class="line"><span class="comment">Go down 2 times</span></div><div class="line"><span class="comment">Go left 4 times</span></div><div class="line"><span class="comment">Go up 1 times.</span></div><div class="line"><span class="comment">Go right 3 times</span></div><div class="line"><span class="comment">Go down 0 times -&gt; quit</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Notice that the directions we choose always follow the order ‘right-&gt;down-&gt;left-&gt;up’, and for horizontal movements, </span></div><div class="line"><span class="comment">the number of shifts follows:&#123;5, 4, 3&#125;, and vertical movements follows &#123;2, 1, 0&#125;. Thus, we can make use of a direction </span></div><div class="line"><span class="comment">matrix that records the offset for all directions, then an array of two elements that stores the number of shifts for </span></div><div class="line"><span class="comment">horizontal and vertical movements, respectively. This way, we really just need one for loop instead of four.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Another good thing about this implementation is that: If later we decided to do spiral traversal on a different direction </span></div><div class="line"><span class="comment">(e.g. Counterclockwise), then we only need to change the Direction matrix; the main loop does not need to be touched.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">通过定义四组方向参数，以及每次遍历时迭代的次数，将四次遍历统一起来（无需写四组循环）</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</div><div class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>)  <span class="keyword">return</span> &#123;&#125;;</div><div class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results(m * n, <span class="number">0</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs(&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; step(&#123;n, m - <span class="number">1</span>&#125;);</div><div class="line">        <span class="keyword">int</span> ir = <span class="number">0</span>, ic = <span class="number">-1</span>, index = <span class="number">0</span>, num = m * n;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; )</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; step[index % <span class="number">2</span>]; j++)</div><div class="line">            &#123;</div><div class="line">                ir += dirs[index % <span class="number">4</span>][<span class="number">0</span>];</div><div class="line">                ic += dirs[index % <span class="number">4</span>][<span class="number">1</span>];</div><div class="line">                results[i] = matrix[ir][ic];</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            step[index % <span class="number">2</span>]--;</div><div class="line">            index = (index + <span class="number">1</span>) % <span class="number">4</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> results;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Spiral-Matrix-II"><a href="#Spiral-Matrix-II" class="headerlink" title="Spiral Matrix II"></a>Spiral Matrix II</h3><p><a href="https://leetcode.com/problems/spiral-matrix-ii/description/" target="_blank" rel="external">Description</a>: Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.<br>For example, Given n = 3, You should return the following matrix:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs(&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;);   <span class="comment">//表示遍历方向</span></div><div class="line">        <span class="keyword">int</span> num = n * n + <span class="number">1</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; step(&#123;n, n - <span class="number">1</span>&#125;);   <span class="comment">//横纵方向遍历的步长（依次递减）</span></div><div class="line">        <span class="keyword">int</span> ir = <span class="number">0</span>, ic = <span class="number">-1</span>, idx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num;)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; step[idx % <span class="number">2</span>]; j++)</div><div class="line">            &#123;</div><div class="line">                ir += dirs[idx][<span class="number">0</span>];</div><div class="line">                ic += dirs[idx][<span class="number">1</span>];</div><div class="line">                result[ir][ic] = i;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            step[idx % <span class="number">2</span>]--;</div><div class="line">            idx = (idx + <span class="number">1</span>) % <span class="number">4</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowStart = <span class="number">0</span>, rowEnd = n - <span class="number">1</span>, colStart = <span class="number">0</span>, colEnd = n - <span class="number">1</span>, num = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//通过横纵边界作为循环条件</span></div><div class="line">        <span class="keyword">while</span> (rowStart &lt;= rowEnd &amp;&amp; colStart &lt;= colEnd) &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colStart; j &lt;= colEnd; j++) &#123;</div><div class="line">                matrix[rowStart][j] = num++; </div><div class="line">            &#125;</div><div class="line">            rowStart++;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt;= rowEnd; i++) &#123;</div><div class="line">                matrix[i][colEnd] = num++; </div><div class="line">            &#125;</div><div class="line">            colEnd--;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (rowStart &lt;= rowEnd) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = colEnd; j &gt;= colStart; j--) &#123;</div><div class="line">                        matrix[rowEnd][j] = num++; </div><div class="line">                &#125;</div><div class="line">                rowEnd--;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (colStart &lt;= colEnd) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = rowEnd; i &gt;= rowStart; i--) &#123;</div><div class="line">                        matrix[i][colStart] = num++; </div><div class="line">                &#125;</div><div class="line">                colStart ++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> matrix;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowStart = <span class="number">0</span>, rowEnd = n - <span class="number">1</span>, colStart = <span class="number">0</span>, colEnd = n - <span class="number">1</span>, num = <span class="number">1</span>;</div><div class="line">        <span class="comment">//元素总数作为循环条件</span></div><div class="line">        <span class="keyword">while</span> (num &lt; n * n + <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colStart; j &lt;= colEnd; j++) &#123;</div><div class="line">                matrix[rowStart][j] = num++; </div><div class="line">            &#125;</div><div class="line">            rowStart++;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt;= rowEnd; i++) &#123;</div><div class="line">                matrix[i][colEnd] = num++; </div><div class="line">            &#125;</div><div class="line">            colEnd--;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = colEnd; j &gt;= colStart; j--) &#123;</div><div class="line">                    matrix[rowEnd][j] = num++; </div><div class="line">            &#125;</div><div class="line">            rowEnd--;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowEnd; i &gt;= rowStart; i--) &#123;</div><div class="line">                    matrix[i][colStart] = num++; </div><div class="line">            &#125;</div><div class="line">            colStart++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> matrix;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Rotate-Image"><a href="#Rotate-Image" class="headerlink" title="Rotate Image"></a>Rotate Image</h3><p><a href="https://leetcode.com/problems/group-anagrams/description/" target="_blank" rel="external">Description</a>: You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).<br>Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<blockquote>
<p>Example 1:<br>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],<br>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:<br>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>],<br>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*****四个对应点坐标依次替换*****/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = matrix.size();</div><div class="line">        <span class="keyword">int</span> row = n / <span class="number">2</span> + n % <span class="number">2</span>, col = n / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</div><div class="line">            &#123;</div><div class="line">                temp = matrix[i][j];</div><div class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];</div><div class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];</div><div class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];</div><div class="line">                matrix[j][n - <span class="number">1</span> - i] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*****先上下翻转，然后矩阵转置*****/</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * clockwise rotate</span></div><div class="line"><span class="comment"> * first reverse up to down, then swap the symmetry </span></div><div class="line"><span class="comment"> * 1 2 3     7 8 9     7 4 1</span></div><div class="line"><span class="comment"> * 4 5 6  =&gt; 4 5 6  =&gt; 8 5 2</span></div><div class="line"><span class="comment"> * 7 8 9     1 2 3     9 6 3</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        reverse(matrix.begin(), matrix.end());</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); j++)</div><div class="line">                swap(matrix[i][j], matrix[j][i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*****对于逆时针旋转90°，先左右翻转，然后矩阵转置*****/</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * anticlockwise rotate</span></div><div class="line"><span class="comment"> * first reverse left to right, then swap the symmetry</span></div><div class="line"><span class="comment"> * 1 2 3     3 2 1     3 6 9</span></div><div class="line"><span class="comment"> * 4 5 6  =&gt; 6 5 4  =&gt; 2 5 8</span></div><div class="line"><span class="comment"> * 7 8 9     9 8 7     1 4 7</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">anti_rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vi : matrix) reverse(vi.begin(), vi.end());</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; matrix[i].size(); ++j)</div><div class="line">            swap(matrix[i][j], matrix[j][i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中数组（Array）问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>字符串(String)问题集锦</title>
    <link href="https://senitco.github.io/2018/03/20/data-structure-string-1/"/>
    <id>https://senitco.github.io/2018/03/20/data-structure-string-1/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.889Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中字符串问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h3><p><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="external">Description</a>: Implement wildcard pattern matching.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Implement wildcard pattern matching with support for '?' and '*'.</span></div><div class="line"><span class="comment">'?' Matches any single character.</span></div><div class="line"><span class="comment">'*' Matches any sequence of characters (including the empty sequence).</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">The matching should cover the entire input string (not partial).</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">The function prototype should be:</span></div><div class="line"><span class="comment">bool isMatch(const char *s, const char *p)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Some examples:</span></div><div class="line"><span class="comment">isMatch("aa","a") → false</span></div><div class="line"><span class="comment">isMatch("aa","aa") → true</span></div><div class="line"><span class="comment">isMatch("aaa","aa") → false</span></div><div class="line"><span class="comment">isMatch("aa", "*") → true</span></div><div class="line"><span class="comment">isMatch("aa", "a*") → true</span></div><div class="line"><span class="comment">isMatch("ab", "?*") → true</span></div><div class="line"><span class="comment">isMatch("aab", "c*a*b") → false</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">（1）若两字符串中的字符匹配则索引均前进；</span></div><div class="line"><span class="comment">（2）若模式串中出现'*'，则记录'*'号位置 starIdx=pIdx，以及原串的当前位置 match=sIdx；</span></div><div class="line"><span class="comment">（3）若当前字符不匹配，且模式串当前字符不为'*'，而上一个字符为'*'，则模式串中待比较字符为'*'号下一个，</span></div><div class="line"><span class="comment">    原串字符索引则相对match位置继续前进；</span></div><div class="line"><span class="comment">（4）若以上条件均不满足，则两字符串不匹配，返回false；</span></div><div class="line"><span class="comment">（5）原串字符遍历结束后，判断模式串是否结束或者剩余字符是否均为'*'</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sIdx = <span class="number">0</span>, pIdx = <span class="number">0</span>, starIdx = <span class="number">-1</span>, match = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(sIdx &lt; s.length())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(pIdx &lt; p.length() &amp;&amp; (s[sIdx] == p[pIdx] || p[pIdx] == <span class="string">'?'</span>))     <span class="comment">// (1)  </span></div><div class="line">            &#123;</div><div class="line">                sIdx++;</div><div class="line">                pIdx++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pIdx &lt; p.length() &amp;&amp; p[pIdx] == <span class="string">'*'</span>)    <span class="comment">// (2)</span></div><div class="line">            &#123;</div><div class="line">                starIdx = pIdx;</div><div class="line">                pIdx++;</div><div class="line">                match = sIdx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(starIdx != <span class="number">-1</span>)      <span class="comment">// (3)</span></div><div class="line">            &#123;</div><div class="line">                pIdx = starIdx + <span class="number">1</span>;</div><div class="line">                match++;</div><div class="line">                sIdx = match;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>                        <span class="comment">// (4)</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pIdx &lt; p.length() &amp;&amp; p[pIdx] == <span class="string">'*'</span>)      <span class="comment">// (5)</span></div><div class="line">            pIdx++;</div><div class="line">        <span class="keyword">return</span> pIdx == p.length();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP方法：如果s[0:i)匹配p[0:j)，DP[i][j]=true，否则DP[i][j]=false</span></div><div class="line"><span class="comment">(1) DP[i][j] = DP[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '?'), if p[j - 1] != '*';</span></div><div class="line"><span class="comment">(2) DP[i][j] = DP[i][j - 1] || DP[i - 1][j], if p[j - 1] == '*'.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenS = s.length(), lenP = p.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; match(lenS + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(lenP + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        match[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenP &amp;&amp; p[j] == <span class="string">'*'</span>; j++)    <span class="comment">//模式串中起始字符为连续的'*'</span></div><div class="line">        &#123;</div><div class="line">            match[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenP; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[i] == p[j] || p[j] == <span class="string">'?'</span>)             <span class="comment">// (1)</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = match[i][j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)                        <span class="comment">// (2)</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = match[i][j + <span class="number">1</span>] || match[i + <span class="number">1</span>][j];</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> match[lenS][lenP];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Restore-IP-Addresses"><a href="#Restore-IP-Addresses" class="headerlink" title="Restore IP Addresses"></a>Restore IP Addresses</h3><p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="external">Description</a>: Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given “25525511135”, return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代组合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> &amp;&amp; i &lt; len - <span class="number">2</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; i + <span class="number">4</span> &amp;&amp; j &lt; len - <span class="number">1</span>; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; j + <span class="number">4</span> &amp;&amp; k &lt; len; k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(len - k &gt; <span class="number">3</span>) <span class="keyword">continue</span>;   <span class="comment">//如不满足条件，提前终止</span></div><div class="line">                    <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, i);</div><div class="line">                    <span class="built_in">string</span> s2 = s.substr(i, j - i);</div><div class="line">                    <span class="built_in">string</span> s3 = s.substr(j, k - j);</div><div class="line">                    <span class="built_in">string</span> s4 = s.substr(k, len - k);</div><div class="line">                    <span class="keyword">if</span>(isValid(s1) &amp;&amp; isValid(s2) &amp;&amp; isValid(s3) &amp;&amp; isValid(s4))</div><div class="line">                        result.push_back(s1 + <span class="string">'.'</span> + s2 + <span class="string">'.'</span> + s3 + <span class="string">'.'</span> + s4);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">std</span>::stoi(s) &gt; <span class="number">255</span> || (s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.length() &gt; <span class="number">1</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; restoreIpAddresses(<span class="built_in">string</span> s) &#123;</div><div class="line">        <span class="keyword">int</span> len = s.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        <span class="built_in">string</span> restored;</div><div class="line">        restoreIP(s, result, <span class="number">0</span>, restored, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restoreIP</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result, <span class="keyword">int</span> index, <span class="built_in">string</span> restored, <span class="keyword">int</span> cnt)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cnt &gt; <span class="number">4</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (cnt == <span class="number">4</span> &amp;&amp; index == s.length())</div><div class="line">            result.push_back(restored);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (index + i &gt; s.length())  <span class="keyword">break</span>;</div><div class="line">            <span class="built_in">string</span> str = s.substr(index, i);</div><div class="line">            <span class="keyword">if</span> ((str[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; str.length() &gt; <span class="number">1</span>) || (i == <span class="number">3</span> &amp;&amp; stoi(str) &gt; <span class="number">255</span>))</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            restoreIP(s, result, index + i, restored + str + (cnt == <span class="number">3</span> ? <span class="string">""</span> : <span class="string">"."</span>), cnt + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Scramble-String"><a href="#Scramble-String" class="headerlink" title="Scramble String"></a>Scramble String</h3><p><a href="https://leetcode.com/problems/scramble-string/description/" target="_blank" rel="external">Description</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">Given a <span class="built_in">string</span> s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</div><div class="line">Below is one possible representation of s1 = <span class="string">"great"</span>:</div><div class="line">    great</div><div class="line">   /    \</div><div class="line">  gr    eat</div><div class="line"> / \    /  \</div><div class="line">g   r  e   at</div><div class="line">           / \</div><div class="line">          a   t</div><div class="line">To scramble the <span class="built_in">string</span>, we may choose any non-leaf node <span class="keyword">and</span> swap its two children.</div><div class="line">For example, <span class="keyword">if</span> we choose the node <span class="string">"gr"</span> <span class="keyword">and</span> swap its two children, it produces a scrambled <span class="built_in">string</span> <span class="string">"rgeat"</span>.</div><div class="line">    rgeat</div><div class="line">   /    \</div><div class="line">  rg    eat</div><div class="line"> / \    /  \</div><div class="line">r   g  e   at</div><div class="line">           / \</div><div class="line">          a   t</div><div class="line">We say that <span class="string">"rgeat"</span> is a scrambled <span class="built_in">string</span> of <span class="string">"great"</span>.</div><div class="line">Similarly, <span class="keyword">if</span> we <span class="keyword">continue</span> to swap the children of nodes <span class="string">"eat"</span> <span class="keyword">and</span> <span class="string">"at"</span>, it produces a scrambled <span class="built_in">string</span> <span class="string">"rgtae"</span>.</div><div class="line">    rgtae</div><div class="line">   /    \</div><div class="line">  rg    tae</div><div class="line"> / \    /  \</div><div class="line">r   g  ta  e</div><div class="line">       / \</div><div class="line">      t   a</div><div class="line">We say that <span class="string">"rgtae"</span> is a scrambled <span class="built_in">string</span> of <span class="string">"great"</span>.</div><div class="line">Given two strings s1 <span class="keyword">and</span> s2 of the same length, determine <span class="keyword">if</span> s2 is a scrambled <span class="built_in">string</span> of s1.</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归解法，并采用预处理方法。首先判断两个字符串是否相等，相等直接返回true；否则判断两个字符串中每个字符出现的次数是否相等，</span></div><div class="line"><span class="comment">若不相等，则直接返回false；否则将每个字符串依次划分为两个字串，递归比较子串，子串的比较包括两种：</span></div><div class="line"><span class="comment">（1）s1[0...i)和s2[0...i)，s1[i...len)和s2[i...len)两组子串是否相等；</span></div><div class="line"><span class="comment">（2）s1[0...i)和s2[len - i ... len)，s1[i...len)和s2[0... len - i)两组子串是否相等</span></div><div class="line"><span class="comment">满足以上两个条件之一就返回true，若均不满足则返回false</span></div><div class="line"><span class="comment">*/</span></div><div class="line">class Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">bool</span> isScramble(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2) &#123;</div><div class="line">        <span class="keyword">if</span>(s1 == s2)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">int</span> len = s1.size();</div><div class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); i++)</div><div class="line">        &#123;</div><div class="line">            count[s1[i] - <span class="string">'a'</span>]++;</div><div class="line">            count[s2[i] - <span class="string">'a'</span>]--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, i), s2.substr(<span class="number">0</span>, i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(i)))</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">if</span>(isScramble(s1.substr(<span class="number">0</span>, i), s2.substr(len - i)) &amp;&amp; isScramble(s1.substr(i), s2.substr(<span class="number">0</span>, len - i)))</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP算法：dp[len][i][j]表示s1[i... i + len - 1]和s2[j... j + len - 1]是否为Scramble String</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isScramble</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(s1 == s2)</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">int</span> size = s1.size();</div><div class="line">        <span class="keyword">bool</span> dp[size + <span class="number">1</span>][size][size];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)</div><div class="line">            &#123;</div><div class="line">                dp[<span class="number">1</span>][i][j] = s1[i] == s2[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; size + <span class="number">1</span>; len++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size - len; i++)   </div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size - len; j++)</div><div class="line">                &#123;</div><div class="line">                    dp[len][i][j] = <span class="literal">false</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len &amp;&amp; !dp[len][i][j]; k++)</div><div class="line">                    &#123;</div><div class="line">                        dp[len][i][j] = dp[len][i][j] || (dp[k][i][j] &amp;&amp; dp[len - k][i + k][j + k]);</div><div class="line">                        dp[len][i][j] = dp[len][i][j] || (dp[k][i + len - k][j] &amp;&amp; dp[len - k][i][j + k]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[size][<span class="number">0</span>][<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h3><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="external">Description</a>: Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.<br>Example 1: Input: “bbbab”. Output: 4. One possible longest palindromic subsequence is “bbbb”.<br>Example 2: Input: “cbbd”. Output: 2. One possible longest palindromic subsequence is “bb”.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***</span></div><div class="line"><span class="comment">dp[i][j]: 区间[i, j]的最长回文子序列</span></div><div class="line"><span class="comment">s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 </span></div><div class="line"><span class="comment">otherwise, dp[i][j] = max(dp[i+1][j], dp[i][j-1])</span></div><div class="line"><span class="comment">Initialization: dp[i][i] = 1</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = s.length();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</div><div class="line">    &#123;</div><div class="line">        dp[i][i] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(s[i] == s[j])</div><div class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = max(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][length<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="external">Description</a>: Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2.<br>(each operation is counted as 1 step.)<br>You have the following 3 operations permitted on a word:<br>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP算法：令dp[i][j]表示将word1[0...i-1]转换为word2[0...j-1]所需的最小转换次数</span></div><div class="line"><span class="comment">1. i = 0, dp[0][j] = j; j = 0, dp[i][0] = i</span></div><div class="line"><span class="comment">2. word1[i - 1] = word2[j - 1]: dp[i][j] = dp[i - 1][j - 1]</span></div><div class="line"><span class="comment">3. word1[i - 1] != word2[j - 1]，则考虑以下三种情况：</span></div><div class="line"><span class="comment">(1) word1[i - 1]替换为word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1</span></div><div class="line"><span class="comment">(2) 删除word1[i - 1], word1[0...i - 2] = word2[0...j - 1]: dp[i][j] = dp[i - 1][j] + 1</span></div><div class="line"><span class="comment">(3) 插入Word2[j - 1], word1[0...i - 1] + word2[j - 1] = word2[0...j - 1]: dp[i][j] = dp[i][j - 1] + 1</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</div><div class="line">        dp[i][<span class="number">0</span>] = i;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</div><div class="line">        dp[<span class="number">0</span>][j] = j;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</div><div class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[m][n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中字符串问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
      <category term="string" scheme="https://senitco.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://senitco.github.io/2018/03/18/data-structure-binary-search-tree/"/>
    <id>https://senitco.github.io/2018/03/18/data-structure-binary-search-tree/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.883Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二叉搜索树问题总结归纳。<br><a id="more"></a></p>
<h3 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h3><p><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="external">Description</a>: Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">For example, Given n = 3, there are a total of 5 unique BST's.</span></div><div class="line"><span class="comment">   1         3     3      2      1</span></div><div class="line"><span class="comment">    \       /     /      / \      \</span></div><div class="line"><span class="comment">     3     2     1      1   3      2</span></div><div class="line"><span class="comment">    /     /       \                 \</span></div><div class="line"><span class="comment">   2     1         2                 3</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/**DP方法</span></div><div class="line"><span class="comment">See https://leetcode.com/problems/unique-binary-search-trees/discuss/31666</span></div><div class="line"><span class="comment">令G(n)表示长度为n的序列的二叉搜索数的数量，F(i, n)表示在长度为 n 的序列中，以 i 为根结点的</span></div><div class="line"><span class="comment">二叉搜索数的数量，则有 G(n) = F(1, n) + F(2, n) + ... + F(n, n)，且 G(0) = G(1) = 1</span></div><div class="line"><span class="comment">对于F(i, n)，有 F(i, n) = G(i - 1) * G(n - i)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</div><div class="line">        &#123;</div><div class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a>Unique Binary Search Trees II</h3><p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/discuss/" target="_blank" rel="external">Description</a>: Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">For example, Given n = 3, your program should return all 5 unique BST's shown below.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   1         3     3      2      1</span></div><div class="line"><span class="comment">    \       /     /      / \      \</span></div><div class="line"><span class="comment">     3     2     1      1   3      2</span></div><div class="line"><span class="comment">    /     /       \                 \</span></div><div class="line"><span class="comment">   2     1         2                 3</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">//Definition for a binary tree node.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归解法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)  <span class="keyword">return</span> <span class="built_in">vector</span>&lt;TreeNode*&gt;();</div><div class="line">        <span class="keyword">return</span> generateBST(<span class="number">1</span>, n);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateBST(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; result;</div><div class="line">        <span class="keyword">if</span>(start &gt; end)</div><div class="line">            result.push_back(<span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; left, right;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)</div><div class="line">        &#123;</div><div class="line">            left = generateBST(start, i - <span class="number">1</span>);</div><div class="line">            right = generateBST(i + <span class="number">1</span>, end);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lnode : left)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> rnode: right)</div><div class="line">                &#123;</div><div class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</div><div class="line">                    root-&gt;left = lnode;</div><div class="line">                    root-&gt;right = rnode;</div><div class="line">                    result.push_back(root);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二叉搜索树问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
      <category term="binary search tree" scheme="https://senitco.github.io/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>二分查找（三）</title>
    <link href="https://senitco.github.io/2018/03/15/data-structure-binary-search-3/"/>
    <id>https://senitco.github.io/2018/03/15/data-structure-binary-search-3/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.883Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二分查找问题总结归纳。<br><a id="more"></a></p>
<h3 id="Divide-Two-Integers"><a href="#Divide-Two-Integers" class="headerlink" title="Divide Two Integers"></a>Divide Two Integers</h3><p>Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT.<a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">In this problem, we are asked to divide two integers. However, we are not allowed to use division, multiplication </span></div><div class="line"><span class="comment">and mod operations. So, what else can we use? Yeah, bit manipulations.</span></div><div class="line"><span class="comment">Let's do an example and see how bit manipulations work.</span></div><div class="line"><span class="comment">Suppose we want to divide 15 by 3, so 15 is dividend and 3 is divisor. Well, division simply requires us to find </span></div><div class="line"><span class="comment">how many times we can subtract the divisor from the the dividend without making the dividend negative.</span></div><div class="line"><span class="comment">Let's get started. We subtract 3 from 15 and we get 12, which is positive. Let's try to subtract more. Well, we </span></div><div class="line"><span class="comment">shift 3 to the left by 1 bit and we get 6. Subtracting 6 from 15 still gives a positive result. Well, we shift </span></div><div class="line"><span class="comment">again and get 12. We subtract 12 from 15 and it is still positive. We shift again, obtaining 24 and we know we </span></div><div class="line"><span class="comment">can at most subtract 12. Well, since 12 is obtained by shifting 3 to left twice, we know it is 4 times of 3. </span></div><div class="line"><span class="comment">How do we obtain this 4? Well, we start from 1 and shift it to left twice at the same time. We add 4 to an answer</span></div><div class="line"><span class="comment">(initialized to be 0). In fact, the above process is like 15 = 3 * 4 + 3. We now get part of the quotient (4), with </span></div><div class="line"><span class="comment">a remainder 3.</span></div><div class="line"><span class="comment">Then we repeat the above process again. We subtract divisor = 3 from the remaining dividend = 3 and obtain 0. We know</span></div><div class="line"><span class="comment">we are done. No shift happens, so we simply add 1 &lt;&lt; 0 to the answer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Now we have the full algorithm to perform division.</span></div><div class="line"><span class="comment">According to the problem statement, we need to handle some exceptions, such as overflow.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Well, two cases may cause overflow:</span></div><div class="line"><span class="comment">(1) divisor = 0;</span></div><div class="line"><span class="comment">(2) dividend = INT_MIN and divisor = -1 (because abs(INT_MIN) = INT_MAX + 1).</span></div><div class="line"><span class="comment">Of course, we also need to take the sign into considerations, which is relatively easy.</span></div><div class="line"><span class="comment">Putting all these together, we have the following code.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!divisor || (dividend == INT_MIN &amp;&amp; divisor == <span class="number">-1</span>))</div><div class="line">            <span class="keyword">return</span> INT_MAX;</div><div class="line">        <span class="keyword">int</span> sign = ((dividend &lt; <span class="number">0</span>) ^ (divisor &lt; <span class="number">0</span>)) ? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvd = <span class="built_in">labs</span>(dividend);</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dvs = <span class="built_in">labs</span>(divisor);</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = dvs, multiple = <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(dvd &gt;= dvs)</div><div class="line">        &#123;</div><div class="line">            temp = dvs;</div><div class="line">            multiple = <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span>(dvd &gt;= (temp &lt;&lt; <span class="number">1</span>))</div><div class="line">            &#123;</div><div class="line">                temp = temp &lt;&lt; <span class="number">1</span>;</div><div class="line">                multiple = multiple &lt;&lt; <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            dvd -= temp;</div><div class="line">            res += multiple;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sign == <span class="number">1</span> ? res : -res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h3><p>Implement pow(x, n).<a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="external">LeetCode</a><br>Example 1:<br>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:<br>Input: 2.10000, 3<br>Output: 9.26100</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归计算</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ln = n;</div><div class="line">    <span class="keyword">if</span>(ln == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(ln &lt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        ln = -ln;   <span class="comment">//如果不定义成长整型对于 n = -2147483648 会越界</span></div><div class="line">        x = <span class="number">1</span> / x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ln % <span class="number">2</span> == <span class="number">0</span> ? myPow(x * x, ln / <span class="number">2</span>) : x * myPow(x * x, ln / <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> / x * myPow(<span class="number">1</span> / x, -(n + <span class="number">1</span>));    <span class="comment">//解决最小负整数反号越界的问题</span></div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> x * x;</div><div class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> myPow(myPow(x, n / <span class="number">2</span>), <span class="number">2</span>);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> x * myPow(myPow(x, n / <span class="number">2</span>), <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//迭代计算</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ln = n;</div><div class="line">    <span class="keyword">if</span>(ln == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(ln &lt; <span class="number">0</span>) </div><div class="line">    &#123;</div><div class="line">        ln = -ln;</div><div class="line">        x = <span class="number">1</span> / x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> ans = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(ln &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(ln &amp; <span class="number">1</span>)  <span class="comment">//最低位为1</span></div><div class="line">            ans *= x;</div><div class="line">        x *= x;</div><div class="line">        ln &gt;&gt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ans;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Sqrt-x"><a href="#Sqrt-x" class="headerlink" title="Sqrt(x)"></a>Sqrt(x)</h3><p>Implement int sqrt(int x). Compute and return the square root of x.<br>x is guaranteed to be a non-negative integer.<br>Example 1:<br>Input: 4<br>Output: 2<br>Example 2:<br>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since we want to return an integer,<br>the decimal part will be truncated.<a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/************二分法查找*************/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = x;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(mid == x / mid)</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid &lt; x / mid)</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> right;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**********牛顿迭代法求解************/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> r = x;</div><div class="line">        <span class="keyword">while</span> (r * r &gt; x)</div><div class="line">            r = (r + x / r) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> r;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二分查找问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="binary search" scheme="https://senitco.github.io/tags/binary-search/"/>
    
      <category term="math" scheme="https://senitco.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>二分查找（二）</title>
    <link href="https://senitco.github.io/2018/03/13/data-structure-binary-search-2/"/>
    <id>https://senitco.github.io/2018/03/13/data-structure-binary-search-2/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.883Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二分查找问题总结归纳。<br><a id="more"></a></p>
<h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br>You may assume no duplicate exists in the array.<a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">二分查找的变体：由于序列存在旋转的情况，需要做进一步的判断</span></div><div class="line"><span class="comment">（1）如果 target == nums[mid]，返回mid</span></div><div class="line"><span class="comment">（2）如果 nums[mid] &lt; nums[right]，说明右边一定是有序的；然后判断是否有 nums[mid] &lt; target &lt;= nums[right]，</span></div><div class="line"><span class="comment">    若是则 left = mid + 1，否则 right = mid - 1</span></div><div class="line"><span class="comment">（3）如果 nums[mid] &gt;= nums[right]，说明左边一定是有序的；然后判断是否有 nums[left] &lt;= target &lt; nums[mid]，</span></div><div class="line"><span class="comment">    若是则 right = mid - 1，否则 left = mid + 1</span></div><div class="line"><span class="comment">时间复杂度为O(n)，空间复杂度为O(1)，前提条件是没有重复元素</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, mid = <span class="number">0</span>, right = size - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)</div><div class="line">                <span class="keyword">return</span> mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)</div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a>Search in Rotated Sorted Array II</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).<br>Write a function to determine if a given target is in the array.<br>The array may contain duplicates.<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">重复元素的存在可能导致中间和边缘相等的情况，这样就丢失了哪边有序的信息，因为哪边都有可能是有序的结果。</span></div><div class="line"><span class="comment">假设原数组是&#123;1,2,3,3,3,3,3&#125;，那么旋转之后有可能是&#123;3,3,3,3,3,1,2&#125;，或者&#123;3,1,2,3,3,3,3&#125;，这样判断左边缘</span></div><div class="line"><span class="comment">和中心的时候都是3，如果要寻找1或者2，并不知道应该跳向哪一半。解决的办法只能是对边缘移动一步，直到边缘</span></div><div class="line"><span class="comment">和中间不再相等或者相遇，这就导致了会有不能切去一半的可能。所以最坏情况（比如全部都是一个元素，或者只有</span></div><div class="line"><span class="comment">一个元素不同于其他元素，而且就在最后一个）就会出现每次移动一步，总共是n步，算法的时间复杂度变成O(n)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, mid = <span class="number">0</span>, right = size - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[left])     <span class="comment">//注意此处是和最左边元素(left)比较，对应的else就是left++</span></div><div class="line">            &#123;                                   <span class="comment">//如果是和right比较，那就应该是right--</span></div><div class="line">                <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target)</div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[left])</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target)</div><div class="line">                    left = mid + <span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    right = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                left++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a>Find Minimum in Rotated Sorted Array</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array.<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">如果 nums[mid] &lt; nums[right]，说明右边一定是有序的，令right = mid（不能为mid-1，因为mid可能为最小的数）</span></div><div class="line"><span class="comment">如果 nums[mid] &gt;= nums[right]，说明左边一定是有序的，令left = mid + 1（最小值一定在mid的右边）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>, mid = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt; right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])</div><div class="line">                right = mid;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[left];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a>Find Minimum in Rotated Sorted Array II</h3><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. The array may contain duplicates.<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">（1）如果 nums[mid] &lt; nums[right]，说明右边一定是有序的，令right = mid（不能为mid-1，因为mid可能为最小的数）</span></div><div class="line"><span class="comment">（2）如果 nums[mid] &gt; nums[right]，说明左边一定是有序的，令left = mid + 1（最小值一定在mid的右边）</span></div><div class="line"><span class="comment">（3）如果 nums[mid] == nums[right]，可能出现以下情况，唯一能确定的是最小值一定在right左边，因此right--</span></div><div class="line"><span class="comment">    [1, 3, 3]</span></div><div class="line"><span class="comment">    [3, 3, 3, 1, 3]</span></div><div class="line"><span class="comment">    [3, 1, 3, 3, 3]</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>, mid = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt; right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])</div><div class="line">                right = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[right])</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                right--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[left];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二分查找问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
      <category term="binary search" scheme="https://senitco.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>二分查找（一）</title>
    <link href="https://senitco.github.io/2018/03/12/data-structure-binary-search-1/"/>
    <id>https://senitco.github.io/2018/03/12/data-structure-binary-search-1/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.883Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二分查找问题总结归纳。<br><a id="more"></a></p>
<h3 id="Search-Insert-Position"><a href="#Search-Insert-Position" class="headerlink" title="Search Insert Position"></a>Search Insert Position</h3><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.<a href="https://leetcode.com/problems/search-insert-position/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example 1:</span></div><div class="line"><span class="comment">Input: [1,3,5,6], 5</span></div><div class="line"><span class="comment">Output: 2</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 2:</span></div><div class="line"><span class="comment">Input: [1,3,5,6], 2</span></div><div class="line"><span class="comment">Output: 1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 3:</span></div><div class="line"><span class="comment">Input: [1,3,5,6], 7</span></div><div class="line"><span class="comment">Output: 4</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 4:</span></div><div class="line"><span class="comment">Input: [1,3,5,6], 0</span></div><div class="line"><span class="comment">Output: 0</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> size = nums.size();</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, mid = <span class="number">0</span>, right = size - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(left &lt;= right)</div><div class="line">    &#123;</div><div class="line">        mid = (left + right) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(nums[mid] == target)</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</div><div class="line">            right = mid - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            left = mid + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left;        <span class="comment">//没找到的情况下插入位置应该为left</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Search-for-a-Range"><a href="#Search-for-a-Range" class="headerlink" title="Search for a Range"></a>Search for a Range</h3><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].<br>For example, Given [5, 7, 7, 8, 8, 10] and target value 8, return [3, 4]. <a href="https://leetcode.com/problems/search-for-a-range/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*********二分法查找，找到目标值后前后搜索边界**********/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="keyword">int</span> size = nums.size();</div><div class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span> || target &lt; nums[<span class="number">0</span>] || target &gt; nums[size - <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;);</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, mid = <span class="number">0</span>, right = size - <span class="number">1</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(nums[mid] == target)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> j = mid - <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] == target)    j--;</div><div class="line">                result.push_back(j + <span class="number">1</span>);</div><div class="line">                j = mid + <span class="number">1</span>;</div><div class="line">                <span class="keyword">while</span>(j &lt; size &amp;&amp; nums[j] == target)    j++;</div><div class="line">                result.push_back(j - <span class="number">1</span>);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</div><div class="line">            &#123;</div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> </div><div class="line">            &#123;</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Search-a-2D-Matrix"><a href="#Search-a-2D-Matrix" class="headerlink" title="Search a 2D Matrix"></a>Search a 2D Matrix</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example, Consider the following matrix:<br>[<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>Given target = 3, return true.<a href="https://leetcode.com/problems/search-a-2d-matrix/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">二分法查找，首先利用二分法定位目标值位于哪一行，然后在该行再次利用二分法查找</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty())</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m - <span class="number">1</span>, mid = <span class="number">0</span>, row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="comment">//如果目标值在上一行的尾值和当前行的首值之间，则无法确定位于哪一行</span></div><div class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[mid][n - <span class="number">1</span>] &gt;= target)</div><div class="line">            &#123;</div><div class="line">                row = mid;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &gt; target)</div><div class="line">            &#123;</div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            &#125;    </div><div class="line">        &#125;</div><div class="line">        <span class="comment">//目标值不在任一行之中，直接返回false；不要判断条件也能返回正确结果，但该条件更符合逻辑</span></div><div class="line">        <span class="keyword">if</span>(left &gt; right)    <span class="keyword">return</span> <span class="literal">false</span>;   </div><div class="line">        left = <span class="number">0</span>, right = n - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(matrix[row][mid] == target)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][mid] &lt; target)</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">矩阵和数组通过坐标对应，直接进行二分法查找</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(matrix.empty() || matrix[<span class="number">0</span>].empty())</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>, mid = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(left &lt;= right)</div><div class="line">        &#123;</div><div class="line">            mid = (left + right) / <span class="number">2</span>;</div><div class="line">            <span class="keyword">if</span>(matrix[mid / n][mid % n] == target)</div><div class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[mid / n][mid % n] &lt; target)</div><div class="line">                left = mid + <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                right = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = nums1.size() + nums2.size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">double</span> median = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span>(nums1.empty() &amp;&amp; nums2.empty())</div><div class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1.empty())</div><div class="line">            nums = nums2;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums2.empty())</div><div class="line">            nums = nums1;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size())</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(nums1[i] &gt; nums2[j])</div><div class="line">                &#123;</div><div class="line">                    nums.push_back(nums2[j]);</div><div class="line">                    j++;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    nums.push_back(nums1[i]);</div><div class="line">                    i++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span>(i &lt; nums1.size())</div><div class="line">                nums.push_back(nums1[i++]);</div><div class="line">            <span class="keyword">while</span>(j &lt; nums2.size())</div><div class="line">                nums.push_back(nums2[j++]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(length % <span class="number">2</span> == <span class="number">1</span>)</div><div class="line">            median = nums[length / <span class="number">2</span>];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            median = (nums[length / <span class="number">2</span> - <span class="number">1</span>] + nums[length / <span class="number">2</span>]) / <span class="number">2.0</span>;</div><div class="line">        <span class="keyword">return</span> median;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*利用STL函数merge()合并两个已排序的向量，也可将两个向量首尾拼接，然后调用sort()函数*/</span></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> length = nums1.size() + nums2.size();</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(length);</div><div class="line">    <span class="keyword">double</span> median = <span class="number">0.0</span>;       </div><div class="line">    merge(nums1.begin(), nums1.end(), nums2.begin(), nums2.end(), nums.begin());</div><div class="line">    <span class="keyword">if</span>(length % <span class="number">2</span> == <span class="number">1</span>)</div><div class="line">        median = nums[length / <span class="number">2</span>];</div><div class="line">    <span class="keyword">else</span></div><div class="line">        median = (nums[length / <span class="number">2</span> - <span class="number">1</span>] + nums[length / <span class="number">2</span>]) / <span class="number">2.0</span>;</div><div class="line">    <span class="keyword">return</span> median;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二分查找问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="array" scheme="https://senitco.github.io/tags/array/"/>
    
      <category term="binary search" scheme="https://senitco.github.io/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>回溯(Backtracking)问题集锦（三）</title>
    <link href="https://senitco.github.io/2018/03/11/data-structure-backtracking-3/"/>
    <id>https://senitco.github.io/2018/03/11/data-structure-backtracking-3/</id>
    <published>2018-03-10T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.882Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中回溯(Backtracking)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h3><p><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="external">Description</a>: Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<blockquote>
<p>For example, given n = 3, a solution set is:<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">递归解法：left,right分别表示已插入字符串中左右括号的数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        backtrack(result, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, n);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec, <span class="built_in">string</span> str, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(str.length() == n * <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            vec.push_back(str);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(left &lt; n)</div><div class="line">            backtrack(vec, str + <span class="string">'('</span>, left + <span class="number">1</span>, right, n);</div><div class="line">        <span class="keyword">if</span>(right &lt; left)</div><div class="line">            backtrack(vec, str + <span class="string">')'</span>, left, right + <span class="number">1</span>, n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">递归解法：n,m分别表示可以插入字符串中的左右括号的剩余数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; generateParenthesis(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        addPar(result, <span class="string">""</span>, n, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPar</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; vec, <span class="built_in">string</span> str, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            vec.push_back(str);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(m &gt; <span class="number">0</span>)   </div><div class="line">            addPar(vec, str + <span class="string">')'</span>, n, m - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</div><div class="line">            addPar(vec, str + <span class="string">'('</span>, n - <span class="number">1</span>, m + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Sudoku-Solver"><a href="#Sudoku-Solver" class="headerlink" title="Sudoku Solver"></a>Sudoku Solver</h3><p><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="external">Description</a>: Write a program to solve a Sudoku puzzle by filling the empty cells. Empty cells are indicated by the character ‘.’. You may assume that there will be only one unique solution.</p>
<blockquote>
<p>A sudoku solution must satisfy all of the following rules:<br>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">对于每个需要填数字的格子带入1到9，每代入一个数字都判定其是否合法，如果合法就继续下一次递归，结束时把数字设回'.'，</span></div><div class="line"><span class="comment">判断新加入的数字是否合法时，只需要判定当前数字是否合法，不需要判定这个数组是否为数独数组，因为之前加进的数字都是</span></div><div class="line"><span class="comment">合法的，这样可以使程序更加高效一些</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(board.empty() || board.size() != <span class="number">9</span> || board[<span class="number">0</span>].size() != <span class="number">9</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        search(board, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(i == <span class="number">9</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">9</span>)  <span class="keyword">return</span> search(board, i + <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; k++)</div><div class="line">            &#123;</div><div class="line">                board[i][j] = (<span class="keyword">char</span>)(k + <span class="string">'1'</span>);</div><div class="line">                <span class="keyword">if</span>(isValid(board, i, j))        <span class="comment">//如果新加数字合法，则继续递归      </span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(search(board, i, j + <span class="number">1</span>)) </div><div class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                board[i][j] = <span class="string">'.'</span>;  <span class="comment">//新加数字不合法或回溯至此时，将数字设为空</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> search(board, i, j + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//判断新加的数字是否合法，只需判断该数字所在行、列以及块，不需遍历整个数盘</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>     </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i != row &amp;&amp; board[i][j] == board[row][j])</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(j != col &amp;&amp; board[i][j] == board[i][col])</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; row++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; col++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>((row != i || col != j) &amp;&amp; board[i][j] == board[row][col])</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(board.empty() || board.size() != <span class="number">9</span> || board[<span class="number">0</span>].size() != <span class="number">9</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        search(board);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span> </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; ++row) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; ++col) </div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span>) </div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i)</div><div class="line">                    &#123;</div><div class="line">                        board[row][col] = <span class="string">'0'</span> + i;</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (isValid(board, row, col)) </div><div class="line">                            <span class="keyword">if</span> (search(board)) </div><div class="line">                                <span class="keyword">return</span> <span class="literal">true</span>;                    </div><div class="line">                        board[row][col] = <span class="string">'.'</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span>     </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i != row &amp;&amp; board[i][j] == board[row][j])</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(j != col &amp;&amp; board[i][j] == board[i][col])</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = i / <span class="number">3</span> * <span class="number">3</span>; row &lt; i / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; row++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = j / <span class="number">3</span> * <span class="number">3</span>; col &lt; j / <span class="number">3</span> * <span class="number">3</span> + <span class="number">3</span>; col++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>((row != i || col != j) &amp;&amp; board[i][j] == board[row][col])</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h3><p><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="external">Description</a>: Implement regular expression matching with support for ‘.’ and ‘<em>‘.<br>‘.’ Matches any single character.<br>‘</em>‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).<br>The function prototype should be: bool isMatch(const char <em>s, const char </em>p)</p>
<blockquote>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “a<em>“) → true<br>isMatch(“aa”, “.</em>“) → true<br>isMatch(“ab”, “.<em>“) → true<br>isMatch(“aab”, “c</em>a*b”) → true</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*递归解法一</span></div><div class="line"><span class="comment">- 若p为空，若s也为空，返回true，反之返回false</span></div><div class="line"><span class="comment">- 若p的长度为1，若s长度也为1，且相同或是p为'.'则返回true，反之返回false</span></div><div class="line"><span class="comment">- 若p的第二个字符不为*，若此时s为空返回false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配</span></div><div class="line"><span class="comment">- 若p的第二个字符为*，若s不为空且字符匹配，调用递归函数匹配s和去掉前两个字符的p，若匹配返回true，否则s去掉首字母</span></div><div class="line"><span class="comment">- 返回调用递归函数匹配s和去掉前两个字符的p的结果</span></div><div class="line"><span class="comment">@reference:</span></div><div class="line"><span class="comment">http://www.cnblogs.com/grandyang/p/4461713.html</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (p.empty()) <span class="keyword">return</span> s.empty();</div><div class="line">        <span class="keyword">if</span> (p.size() == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (s.size() == <span class="number">1</span> &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (p[<span class="number">1</span>] != <span class="string">'*'</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">return</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>)) &#123;</div><div class="line">            <span class="keyword">if</span> (isMatch(s, p.substr(<span class="number">2</span>))) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            s = s.substr(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*递归解法二</span></div><div class="line"><span class="comment">- 先判断p是否为空，若为空则根据s的为空的情况返回结果。</span></div><div class="line"><span class="comment">- 当p的第二个字符为*号时，由于*号前面的字符的个数可以任意，可以为0，</span></div><div class="line"><span class="comment">    - 那么先用递归来调用为0的情况，就是直接把这两个字符去掉再比较</span></div><div class="line"><span class="comment">    - 或者当s不为空，且第一个字符和p的第一个字符相同时，再对去掉首字符的s和p调用递归，注意p不能去掉首字符，</span></div><div class="line"><span class="comment">        因为*号前面的字符可以有无限个；</span></div><div class="line"><span class="comment">- 如果第二个字符不为*号，那么就比较第一个字符，然后对后面的字符串调用递归</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (p.empty()) </div><div class="line">            <span class="keyword">return</span> s.empty();</div><div class="line">        <span class="keyword">if</span> (p.size() &gt; <span class="number">1</span> &amp;&amp; p[<span class="number">1</span>] == <span class="string">'*'</span>) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> isMatch(s, p.substr(<span class="number">2</span>)) || (!s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p));</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> !s.empty() &amp;&amp; (s[<span class="number">0</span>] == p[<span class="number">0</span>] || p[<span class="number">0</span>] == <span class="string">'.'</span>) &amp;&amp; isMatch(s.substr(<span class="number">1</span>), p.substr(<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*动态规划法</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">dp[i][j]表示s[0:i-1]是否能和p[0:j-1]匹配。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">递推公式：由于只有p中会含有regular expression，所以以p[j-1]来进行分类。</span></div><div class="line"><span class="comment">p[j-1] != '.' &amp;&amp; p[j-1] != '*'：dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1])</span></div><div class="line"><span class="comment">p[j-1] == '.'：dp[i][j] = dp[i-1][j-1]</span></div><div class="line"><span class="comment">p[j-1] == '*':</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">而关键的难点在于 p[j-1] = '*'。由于星号可以匹配0、1、乃至多个p[j-2]。</span></div><div class="line"><span class="comment">1. 匹配0个元素，即消去p[j-2]，此时p[0: j-1] = p[0: j-3]</span></div><div class="line"><span class="comment">dp[i][j] = dp[i][j-2]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">2. 匹配1个元素，此时p[0: j-1] = p[0: j-2]</span></div><div class="line"><span class="comment">dp[i][j] = dp[i][j-1]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">3. 匹配多个元素，此时p[0: j-1] = &#123; p[0: j-2], p[j-2], ... , p[j-2] &#125;</span></div><div class="line"><span class="comment">dp[i][j] = dp[i-1][j] &amp;&amp; (p[j-2]=='.' || s[i-2]==p[j-2])</span></div><div class="line"><span class="comment">由于p[j-1]为'*'，而且匹配数目不确定，因此递推式中j值不能减小，而是通过递减i，使得最后匹配的数目为 0 或 1 来进行处理。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">@reference:</span></div><div class="line"><span class="comment">http://bangbingsyb.blogspot.com/2014/11/leetcode-regular-expression-matching.html</span></div><div class="line"><span class="comment">http://xiaohuiliucuriosity.blogspot.com/2014/12/regular-expression-matching.html</span></div><div class="line"><span class="comment">https://discuss.leetcode.com/topic/6183/my-concise-recursive-and-dp-solutions-with-full-explanation-in-c</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = s.size(), n = p.size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>,<span class="literal">false</span>));</div><div class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">'.'</span> &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'*'</span>) </div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</div><div class="line">                        dp[i][j] = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">'.'</span>) </div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>])</div><div class="line">                        dp[i][j] = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">1</span>)</div><div class="line">                &#123;  <span class="comment">//'*' cannot be the 1st element</span></div><div class="line">                    <span class="keyword">if</span>(dp[i][j - <span class="number">1</span>] || dp[i][j - <span class="number">2</span>])  <span class="comment">// match 0 or 1 preceding element</span></div><div class="line">                        dp[i][j] = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (p[j - <span class="number">2</span>] == s[i - <span class="number">1</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]) <span class="comment">// match multiple preceding elements</span></div><div class="line">                        dp[i][j] = <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Wildcard-Matching"><a href="#Wildcard-Matching" class="headerlink" title="Wildcard Matching"></a>Wildcard Matching</h3><p><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="external">Description</a>: Implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<blockquote>
<p>‘?’ Matches any single character.<br>‘<em>‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).<br>The function prototype should be: bool isMatch(const char </em>s, const char <em>p)<br>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “</em>“) → true<br>isMatch(“aa”, “a<em>“) → true<br>isMatch(“ab”, “?</em>“) → true<br>isMatch(“aab”, “c<em>a</em>b”) → false</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">（1）若两字符串中的字符匹配则索引均前进；</span></div><div class="line"><span class="comment">（2）若模式串中出现'*'，则记录'*'号位置 starIdx=pIdx，以及原串的当前位置 match=sIdx；</span></div><div class="line"><span class="comment">（3）若当前字符不匹配，且模式串当前字符不为'*'，而上一个字符为'*'，则模式串中待比较字符为'*'号下一个，</span></div><div class="line"><span class="comment">    原串字符索引则相对match位置继续前进；</span></div><div class="line"><span class="comment">（4）若以上条件均不满足，则两字符串不匹配，返回false；</span></div><div class="line"><span class="comment">（5）原串字符遍历结束后，判断模式串是否结束或者剩余字符是否均为'*'</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sIdx = <span class="number">0</span>, pIdx = <span class="number">0</span>, starIdx = <span class="number">-1</span>, match = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(sIdx &lt; s.length())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(pIdx &lt; p.length() &amp;&amp; (s[sIdx] == p[pIdx] || p[pIdx] == <span class="string">'?'</span>))     <span class="comment">// (1)  </span></div><div class="line">            &#123;</div><div class="line">                sIdx++;</div><div class="line">                pIdx++;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pIdx &lt; p.length() &amp;&amp; p[pIdx] == <span class="string">'*'</span>)    <span class="comment">// (2)</span></div><div class="line">            &#123;</div><div class="line">                starIdx = pIdx;</div><div class="line">                pIdx++;</div><div class="line">                match = sIdx;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(starIdx != <span class="number">-1</span>)      <span class="comment">// (3)</span></div><div class="line">            &#123;</div><div class="line">                pIdx = starIdx + <span class="number">1</span>;</div><div class="line">                match++;</div><div class="line">                sIdx = match;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>                        <span class="comment">// (4)</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span>(pIdx &lt; p.length() &amp;&amp; p[pIdx] == <span class="string">'*'</span>)      <span class="comment">// (5)</span></div><div class="line">            pIdx++;</div><div class="line">        <span class="keyword">return</span> pIdx == p.length();</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">DP方法：如果s[0:i)匹配p[0:j)，DP[i][j]=true，否则DP[i][j]=false</span></div><div class="line"><span class="comment">(1) DP[i][j] = DP[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '?'), if p[j - 1] != '*';</span></div><div class="line"><span class="comment">(2) DP[i][j] = DP[i][j - 1] || DP[i - 1][j], if p[j - 1] == '*'.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenS = s.length(), lenP = p.length();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; match(lenS + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(lenP + <span class="number">1</span>, <span class="literal">false</span>));</div><div class="line">        match[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenP &amp;&amp; p[j] == <span class="string">'*'</span>; j++)    <span class="comment">//模式串中起始字符为连续的'*'</span></div><div class="line">        &#123;</div><div class="line">            match[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lenP; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s[i] == p[j] || p[j] == <span class="string">'?'</span>)             <span class="comment">// (1)</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = match[i][j];</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p[j] == <span class="string">'*'</span>)                        <span class="comment">// (2)</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = match[i][j + <span class="number">1</span>] || match[i + <span class="number">1</span>][j];</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    match[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> match[lenS][lenP];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中回溯(Backtracking)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="backtracking" scheme="https://senitco.github.io/tags/backtracking/"/>
    
      <category term="dp" scheme="https://senitco.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>二叉树问题集锦（三）</title>
    <link href="https://senitco.github.io/2018/03/10/data-structure-binary-tree-3/"/>
    <id>https://senitco.github.io/2018/03/10/data-structure-binary-tree-3/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.884Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二叉树问题的总结归纳。<br><a id="more"></a></p>
<p>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example 1:</span></div><div class="line"><span class="comment">    2</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  1   3</span></div><div class="line"><span class="comment">Binary tree [2,1,3], return true.</span></div><div class="line"><span class="comment">Example 2:</span></div><div class="line"><span class="comment">    1</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  2   3</span></div><div class="line"><span class="comment">Binary tree [1,2,3], return false.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法中序遍历，对于合法二叉搜索树，中序遍历的结果为递增关系</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        TreeNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(root);</div><div class="line">                root = root-&gt;left;</div><div class="line">            &#125;</div><div class="line">            root = toVisit.top();</div><div class="line">            toVisit.pop();</div><div class="line">            <span class="keyword">if</span>(prev != <span class="literal">NULL</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            prev = root;</div><div class="line">            root = root-&gt;right;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归法中序遍历</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        TreeNode* prev = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> isValid(root, prev);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(TreeNode* node, TreeNode* &amp;prev)</span>   <span class="comment">//注意此处传的为指针的引用</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(!isValid(node-&gt;left, prev))   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(prev != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= node-&gt;val)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        prev = node;</div><div class="line">        <span class="keyword">return</span> isValid(node-&gt;right, prev);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Recover-Binary-Search-Tree"><a href="#Recover-Binary-Search-Tree" class="headerlink" title="Recover Binary Search Tree"></a>Recover Binary Search Tree</h3><p>Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.<br>Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?<a href="https://leetcode.com/problems/recover-binary-search-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归法中序遍历，对于异常点，存在前一个元素大于后一个元素，但两个异常点略有差异（第一个异常点，</span></div><div class="line"><span class="comment">其值大于后一个元素；第二个异常点，其值小于前一个元素）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        inorderTraverse(root);</div><div class="line">        <span class="keyword">int</span> temp = first-&gt;val;</div><div class="line">        first-&gt;val = second-&gt;val;</div><div class="line">        second-&gt;val = temp;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    TreeNode *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>; <span class="comment">//如果不定义为成员变量，而是作为形参，则应该传指针变量的引用</span></div><div class="line">    TreeNode *prev = <span class="keyword">new</span> TreeNode(INT_MIN);</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraverse</span><span class="params">(TreeNode* root)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span>;</div><div class="line">        inorderTraverse(root-&gt;left);</div><div class="line">        <span class="keyword">if</span>(first == <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">            first = prev;</div><div class="line">        <span class="keyword">if</span>(first != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">            second = root;</div><div class="line">        prev = root;</div><div class="line">        inorderTraverse(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法中序遍历</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        TreeNode *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>;</div><div class="line">        TreeNode *prev = <span class="keyword">new</span> TreeNode(INT_MIN);</div><div class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">while</span>(root)</div><div class="line">            &#123;</div><div class="line">                toVisit.push(root);</div><div class="line">                root = root-&gt;left;</div><div class="line">            &#125;</div><div class="line">            root = toVisit.top();</div><div class="line">            toVisit.pop();</div><div class="line">            <span class="keyword">if</span>(first == <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">                first = prev;</div><div class="line">            <span class="keyword">if</span>(first != <span class="literal">NULL</span> &amp;&amp; prev-&gt;val &gt;= root-&gt;val)</div><div class="line">                second = root;</div><div class="line">            prev = root;</div><div class="line">            root = root-&gt;right;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> temp = first-&gt;val;</div><div class="line">        first-&gt;val = second-&gt;val;</div><div class="line">        second-&gt;val = temp;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Same-Tree"><a href="#Same-Tree" class="headerlink" title="Same Tree"></a>Same Tree</h3><p>Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example 1:</span></div><div class="line"><span class="comment">Input:     1         1</span></div><div class="line"><span class="comment">          / \       / \</span></div><div class="line"><span class="comment">         2   3     2   3</span></div><div class="line"><span class="comment">        [1,2,3],   [1,2,3]</span></div><div class="line"><span class="comment">Output: true</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 2:</span></div><div class="line"><span class="comment">Input:     1         1</span></div><div class="line"><span class="comment">          /           \</span></div><div class="line"><span class="comment">         2             2</span></div><div class="line"><span class="comment">        [1,2],     [1,null,2]</span></div><div class="line"><span class="comment">Output: false</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 3:</span></div><div class="line"><span class="comment">Input:     1         1</span></div><div class="line"><span class="comment">          / \       / \</span></div><div class="line"><span class="comment">         2   1     1   2</span></div><div class="line"><span class="comment">        [1,2,1],   [1,1,2]</span></div><div class="line"><span class="comment">Output: false</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归法中序遍历，对于这种判断真假的递归，与一般的递归遍历相比有些特殊，因为在遍历过程中，</span></div><div class="line"><span class="comment">如果不符合条件，则终止递归直接返回false，而最终的结果若要返回true，则需完整遍历一次，且</span></div><div class="line"><span class="comment">遍历过程中所有判断条件都要为真</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> traverse(p, q);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(TreeNode* p, TreeNode* q)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((p &amp;&amp; !q) || (!p &amp;&amp; q)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(!traverse(p-&gt;left, q-&gt;left)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> traverse(p-&gt;right, q-&gt;right);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">递归法先序遍历</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">if</span>(p-&gt;val == q-&gt;val)</div><div class="line">            <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Symmetric-Tree"><a href="#Symmetric-Tree" class="headerlink" title="Symmetric Tree"></a>Symmetric Tree</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</span></div><div class="line"><span class="comment">    1</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  2   2</span></div><div class="line"><span class="comment"> / \ / \</span></div><div class="line"><span class="comment">3  4 4  3</span></div><div class="line"><span class="comment">But the following [1,2,2,null,3,null,3] is not:</span></div><div class="line"><span class="comment">    1</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  2   2</span></div><div class="line"><span class="comment">   \   \</span></div><div class="line"><span class="comment">   3    3</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">借助队列实现层序遍历（广度优先遍历），使用一个layer数组存储每一层的数据，对于左子结点或右子结点为空的情况，往数组中对应位置存0</span></div><div class="line"><span class="comment">（其实略有不妥，应该存一个不会出现的数据）。访问完上一层的结点后，下一层的结点全部进入队列，同时下一层的数据（包括部分空结点）也</span></div><div class="line"><span class="comment">全部存入数组，这时数组应该是前后对称的。至于要处理子结点为空的情况，是为了避免将上述第二个二叉树那样的结构认为是对称的。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        toVisit.push(root);</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</div><div class="line">            <span class="keyword">int</span> size = toVisit.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            &#123;</div><div class="line">                TreeNode* curr = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                <span class="keyword">if</span>(curr-&gt;left)  </div><div class="line">                &#123;</div><div class="line">                    toVisit.push(curr-&gt;left);</div><div class="line">                    layer.push_back(curr-&gt;left-&gt;val);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>    </div><div class="line">                    layer.push_back(<span class="number">0</span>);</div><div class="line">                <span class="keyword">if</span>(curr-&gt;right)</div><div class="line">                &#123;</div><div class="line">                    toVisit.push(curr-&gt;right);</div><div class="line">                    layer.push_back(curr-&gt;right-&gt;val);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    layer.push_back(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = layer.size() - <span class="number">1</span>; i &lt; j; i++, j--)</div><div class="line">                <span class="keyword">if</span>(layer[i] != layer[j])</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归解法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> recursive(root-&gt;left, root-&gt;right);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursive</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span> left == right;</div><div class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> recursive(left-&gt;left, right-&gt;right) &amp;&amp; recursive(left-&gt;right, right-&gt;left);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代解法，借助两个队列实现（栈也可以）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q1, q2;</div><div class="line">        q1.push(root-&gt;left);</div><div class="line">        q2.push(root-&gt;right);</div><div class="line">        <span class="keyword">while</span>(!q1.empty() &amp;&amp; !q2.empty())</div><div class="line">        &#123;</div><div class="line">            TreeNode* left = q1.front();</div><div class="line">            TreeNode* right = q2.front();</div><div class="line">            q1.pop();</div><div class="line">            q2.pop();</div><div class="line">            <span class="keyword">if</span>(left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(left == <span class="literal">NULL</span> || right == <span class="literal">NULL</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            q1.push(left-&gt;left);    <span class="comment">//入队列的顺序为左右</span></div><div class="line">            q1.push(left-&gt;right);</div><div class="line">            q2.push(right-&gt;right);  <span class="comment">//入队列的顺序为右左</span></div><div class="line">            q2.push(right-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二叉树问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>回溯(Backtracking)问题集锦（二）</title>
    <link href="https://senitco.github.io/2018/03/09/data-structure-backtracking-2/"/>
    <id>https://senitco.github.io/2018/03/09/data-structure-backtracking-2/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.881Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中回溯(Backtracking)问题总结归纳。<br><a id="more"></a></p>
<h3 id="N-Queens"><a href="#N-Queens" class="headerlink" title="N-Queens"></a>N-Queens</h3><p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="external">Description</a>: The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p><img src="https://github.com/SenitCo/Algorithm/blob/master/images/51_n-queens.png"></p>
<blockquote>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:<br>[<br> [“.Q..”,  // Solution 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],<br> [“..Q.”,  // Solution 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">利用数组tmp记录旗子在棋盘中的位置，例如tmp[i]=j表示第i行第j列放置棋子，得到所有可能的布棋组合后，</span></div><div class="line"><span class="comment">再逐一生成对应的棋盘（字符串），利用tmp[i]=j表示棋子位置而不是二维数组board[i][j]='Q'这种方式，</span></div><div class="line"><span class="comment">可避免在多方向（列、斜对角）搜索确认是否存在冲突情况，而只需要考虑是否满足一定的数学条件</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pos;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n, <span class="number">0</span>);</div><div class="line">        backtrack(pos, tmp, n, <span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pos[i].size(); j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">int</span> index = pos[i][j];</div><div class="line">                board[j][index] = <span class="string">'Q'</span>;</div><div class="line">            &#125;</div><div class="line">            result.push_back(board);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> n, <span class="keyword">int</span> t)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(t == n)</div><div class="line">            pos.push_back(tmp);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">bool</span> flag = <span class="literal">false</span>;</div><div class="line">                tmp[t] = i;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++)</div><div class="line">                &#123;</div><div class="line">                    <span class="comment">// (*)利用这个关系式判断是否冲突，而不需要多方向搜索</span></div><div class="line">                    <span class="keyword">if</span> (tmp[t] == tmp[k] || <span class="built_in">abs</span>(t - k) == <span class="built_in">abs</span>(tmp[t] - tmp[k]))     </div><div class="line">                    &#123;</div><div class="line">                        flag = <span class="literal">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;                    </div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!flag)  <span class="comment">//如果t = 0或者不存在冲突的情况，则继续递归</span></div><div class="line">                    backtrack(pos, tmp, n, t + <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="N-Queens-II"><a href="#N-Queens-II" class="headerlink" title="N-Queens II"></a>N-Queens II</h3><p><a href="https://leetcode.com/problems/n-queens-ii/description/" target="_blank" rel="external">Description</a>： The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无需得到每一种棋盘布局情况，只需统计有效的组合数</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(n, <span class="number">0</span>);</div><div class="line">        backtrack(tmp, n, <span class="number">0</span>, sum);</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> n, <span class="keyword">int</span> t, <span class="keyword">int</span>&amp; sum)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(t == n)</div><div class="line">            sum++;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">            &#123;</div><div class="line">                tmp[t] = i;</div><div class="line">                <span class="keyword">if</span> (isValid(tmp, t))</div><div class="line">                    backtrack(tmp, n, t + <span class="number">1</span>, sum);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tmp, <span class="keyword">int</span> t)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (tmp[t] == tmp[k] || <span class="built_in">abs</span>(t - k) == <span class="built_in">abs</span>(tmp[t] - tmp[k]))</div><div class="line">            &#123;</div><div class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;                    </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols(n, <span class="number">1</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dia1(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dia2(<span class="number">2</span> * n - <span class="number">1</span>, <span class="number">1</span>);</div><div class="line">        backtrack(<span class="number">0</span>, cols, dia1, dia2, n, cnt);</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cols, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dia1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dia2, <span class="keyword">int</span> n, <span class="keyword">int</span>&amp; cnt)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(row == n)</div><div class="line">        &#123;</div><div class="line">            cnt++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> id1 = row + col, id2 = n - <span class="number">1</span> + col - row;</div><div class="line">            <span class="keyword">if</span>(cols[col] &amp;&amp; dia1[id1] &amp;&amp; dia2[id2])</div><div class="line">            &#123;</div><div class="line">                cols[col] = dia1[id1] = dia2[id2] = <span class="number">0</span>;</div><div class="line">                backtrack(row + <span class="number">1</span>, cols, dia1, dia2, n, cnt);</div><div class="line">                cols[col] = dia1[id1] = dia2[id2] = <span class="number">1</span>;</div><div class="line">            &#125;   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><p><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="external">Description</a>: Given a string s, partition s such that every substring of the partition is a palindrome.<br>Return all possible palindrome partitioning of s.<br>For example, given s = “aab”, return<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; partition(<span class="built_in">string</span> s) </div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cut;</div><div class="line">    backtrack(result, cut, s, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cut, <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(begin == s.length())</div><div class="line">    &#123;</div><div class="line">        result.push_back(cut);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; s.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(isPalindrome(s, begin, i))</div><div class="line">        &#123;</div><div class="line">            cut.push_back(s.substr(begin, i - begin + <span class="number">1</span>));</div><div class="line">            backtrack(result, cut, s, i + <span class="number">1</span>);</div><div class="line">            cut.pop_back();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">while</span>(start &lt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(s[start++] != s[end--])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Word-Break-II"><a href="#Word-Break-II" class="headerlink" title="Word Break II"></a>Word Break II</h3><p><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="external">Description</a>: Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words. Return all such possible sentences.</p>
<blockquote>
<p>For example, given s = “catsanddog”, dict = [“cat”, “cats”, “and”, “sand”, “dog”].<br>A solution is [“cats and dog”, “cat sand dog”].</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归回溯</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreak(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict) &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mp;</div><div class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : wordDict)</div><div class="line">            dict.insert(word);</div><div class="line">        <span class="keyword">return</span> wordBreakRecur(s, dict, mp);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordBreakRecur(<span class="built_in">string</span> s, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; dict, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; mp)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(mp.count(s)) <span class="keyword">return</span> mp[s];</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</div><div class="line">        <span class="keyword">if</span>(dict.count(s))</div><div class="line">            result.push_back(s);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">string</span> word = s.substr(i);</div><div class="line">            <span class="keyword">if</span>(dict.count(word))</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">string</span> remain = s.substr(<span class="number">0</span>, i);</div><div class="line">                <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; prev = wordBreakRecur(remain, dict, mp);</div><div class="line">                combine(word, prev);</div><div class="line">                result.insert(result.end(), prev.begin(), prev.end());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mp[s] = result;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="built_in">string</span> word, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prev)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prev.size(); i++)</div><div class="line">            prev[i] += <span class="string">" "</span> + word;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Word-Search"><a href="#Word-Search" class="headerlink" title="Word Search"></a>Word Search</h3><p><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="external">Description</a>: Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<blockquote>
<p>For example,<br>Given board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">定义一个标志数组visited，如果位置(i, j)被访问过，则令visited[i][j] = 0</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> m = board.size(), n = board[<span class="number">0</span>].size();</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++)</div><div class="line">            &#123;   <span class="comment">//第一个判断条件可不要</span></div><div class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>] &amp;&amp; backtrack(board, word, i, j, visited, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> count)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count == word.size())</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="comment">//将所有判断条件集中处理</span></div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; board.size() - <span class="number">1</span> || j &gt; board[i].size() - <span class="number">1</span> || visited[i][j] || board[i][j] != word[count])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        visited[i][j] = <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (backtrack(board, word, i - <span class="number">1</span>, j, visited, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i, j - <span class="number">1</span>, visited, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i + <span class="number">1</span>, j, visited, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i, j + <span class="number">1</span>, visited, count + <span class="number">1</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        visited[i][j] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">无需额外的存储空间表示元素是否访问过，若访问某元素，直接将其赋值为一个特殊字符，并在回溯时将其复原</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (backtrack(board, word, i, j, <span class="number">0</span>))</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span>&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> count)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (count == word.size())</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt; board.size() - <span class="number">1</span> || j &gt; board[i].size() - <span class="number">1</span> || board[i][j] != word[count])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        board[i][j] = <span class="string">'?'</span>;</div><div class="line">        <span class="keyword">if</span> (backtrack(board, word, i - <span class="number">1</span>, j, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i, j - <span class="number">1</span>, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i + <span class="number">1</span>, j, count + <span class="number">1</span>)</div><div class="line">            || backtrack(board, word, i, j + <span class="number">1</span>, count + <span class="number">1</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        board[i][j] = word[count];</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中回溯(Backtracking)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="backtracking" scheme="https://senitco.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>回溯(Backtracking)问题集锦（一）</title>
    <link href="https://senitco.github.io/2018/03/08/data-structure-backtracking-1/"/>
    <id>https://senitco.github.io/2018/03/08/data-structure-backtracking-1/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.881Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中回溯(Backtracking)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="external">Description</a>: Given a collection of distinct numbers, return all possible permutations.<br>For example, [1,2,3] have the following permutations:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//回溯法(深度优先遍历DFS)，无重复元素，无需排序</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="comment">//sort(nums.begin(), nums.end());</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; permutation;</div><div class="line">        backtrack(nums, result, permutation);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; permutation)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(permutation.size() == nums.size())</div><div class="line">        &#123;</div><div class="line">            result.push_back(permutation);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> iter = find(permutation.begin(), permutation.end(), nums[i]);  </div><div class="line">            <span class="keyword">if</span>(iter == permutation.end())   <span class="comment">//新元素不在已有序列中，则添加进来</span></div><div class="line">            &#123;</div><div class="line">                permutation.push_back(nums[i]);</div><div class="line">                backtrack(nums, result, permutation);</div><div class="line">                permutation.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//ref: http://xiaohuiliucuriosity.blogspot.com/2014/12/permutations.html</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;        </div><div class="line">        permuteRecursive(nums, <span class="number">0</span>, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;   </div><div class="line">    <span class="comment">// permute num[begin..end], invariant: num[0..begin-1] have been fixed/permuted</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (begin &gt;= nums.size()) &#123;</div><div class="line">            result.push_back(nums); <span class="comment">// one permutation instance</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; nums.size(); i++) &#123;</div><div class="line">            swap(nums[begin], nums[i]);</div><div class="line">            permuteRecursive(nums, begin + <span class="number">1</span>, result);</div><div class="line">            swap(nums[begin], nums[i]);     <span class="comment">// reset</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">对于nums = &#123; 1, 2, 3 &#125;，首先将第一个元素 1 插入序列中，然后插入第二个元素 2 ，2 可以在 1 的前面，</span></div><div class="line"><span class="comment">也可以在 1 的后面，因此得到结果&#123;&#123;1, 2&#125;, &#123;2, 1&#125;&#125;，同样地，第三个元素 3 插入到已有的排列中时，可以</span></div><div class="line"><span class="comment">在索引 0、1、2；依次类推，即可得到全排列。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        result.push_back(&#123; nums[<span class="number">0</span>] &#125;);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; newRes;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> perm : result)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newPerm = perm;</div><div class="line">                    newPerm.insert(newPerm.begin() + j, nums[i]);</div><div class="line">                    newRes.push_back(newPerm);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            result = newRes;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a>Permutations II</h3><p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="external">Description</a>: Given a collection of numbers that might contain duplicates, return all possible unique permutations.<br>For example, [1,1,2] have the following unique permutations:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">回溯法，增加一个flag数组标志相应元素是否在已有排列中，并排除重复元素的影响</span></div><div class="line"><span class="comment">在判断条件(*)中，flag[i]为true则考虑下一个元素；如果是相邻重复元素，则只进行一次纵深排列，而跳过横向迭代；</span></div><div class="line"><span class="comment">也就是说对于连续的重复元素&#123;a1, a2, ... ak&#125;，在同一层循环中，只需考虑第一个元素。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; permutation;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag(nums.size(), <span class="literal">false</span>);</div><div class="line">        backtrack(nums, result, permutation, flag);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; permutation, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; flag)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(permutation.size() == nums.size())</div><div class="line">        &#123;</div><div class="line">            result.push_back(permutation);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;         </div><div class="line">            <span class="keyword">if</span>(flag[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !flag[i - <span class="number">1</span>]))    <span class="comment">// (*)</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            flag[i] = <span class="literal">true</span>;</div><div class="line">            permutation.push_back(nums[i]);</div><div class="line">            backtrack(nums, result, permutation, flag);</div><div class="line">            permutation.pop_back();</div><div class="line">            flag[i] = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        recursion(nums, result, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//注意第一个参数不是引用，后面的swap操作只对本层以及后续递归有影响</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> i)</span>    </span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(i == nums.size() - <span class="number">1</span>)    <span class="comment">//只需递归到倒数第二个元素</span></div><div class="line">        &#123;</div><div class="line">            result.push_back(nums);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.size(); j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(j != i &amp;&amp; nums[j] == nums[i])</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            swap(nums[i], nums[j]);</div><div class="line">            recursion(nums, result, i + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="external">Description</a>: Given two integers n and k, return all possible combinations of k numbers out of 1 … n.<br>For example, If n = 4 and k = 2, a solution is:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</div><div class="line">        backtrack(result, combination, n, k, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, <span class="keyword">int</span> num)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(num == k)</div><div class="line">        &#123;</div><div class="line">            result.push_back(combination);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            combination.push_back(i + <span class="number">1</span>);</div><div class="line">            backtrack(result, combination, n, k, i + <span class="number">1</span>, num + <span class="number">1</span>);</div><div class="line">            combination.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;   </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 简化版本，无需另外定义一个计数变量 num ，并将循环条件换为 i &lt; n - k + 1，因为一个组合中必须有 k 个值</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</div><div class="line">        backtrack(result, combination, n, k, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            result.push_back(combination);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; n - k + <span class="number">1</span>; i++)</div><div class="line">        &#123;</div><div class="line">            combination.push_back(i + <span class="number">1</span>);</div><div class="line">            backtrack(result, combination, n, k - <span class="number">1</span>, i + <span class="number">1</span>);</div><div class="line">            combination.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 组合迭代公式：C(n, k) = C(n - 1, k - 1) + C(n - 1, k)，n被选中和n没被选中两种情况</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res,res1;      </div><div class="line">        <span class="keyword">if</span>(k==n || k==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res2;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</div><div class="line">                curr.push_back(i);</div><div class="line">            res2.push_back(curr);</div><div class="line">            <span class="keyword">return</span> res2;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res = combine(n<span class="number">-1</span>,k<span class="number">-1</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> itr=res.begin();itr!=res.end();itr++)</div><div class="line">        &#123;</div><div class="line">            itr-&gt;push_back(n);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        res1 = combine(n<span class="number">-1</span>,k);</div><div class="line">        </div><div class="line">        res.insert(res.end(),res1.begin(),res1.end());</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;   </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//See https://leetcode.com/problems/combinations/discuss/26992</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(k, <span class="number">0</span>);</div><div class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</div><div class="line">            p[i]++;</div><div class="line">            <span class="keyword">if</span> (p[i] &gt; n) --i;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == k - <span class="number">1</span>) result.push_back(p);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                ++i;</div><div class="line">                p[i] = p[i - <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="external">escription</a>: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations<br>in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [2, 3, 6, 7] and target 7,<br>A solution set is:<br>[<br>  [7],<br>  [2, 2, 3]<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</div><div class="line">        search(candidates, combination, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            result.push_back(combination);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; candidates.size() &amp;&amp; target &gt;= candidates[i]; i++)</div><div class="line">        &#123;</div><div class="line">            combination.push_back(candidates[i]);</div><div class="line">            search(candidates, combination, result, target - candidates[i], i);     <span class="comment">//不是 i + 1 ,可重复利用同一元素</span></div><div class="line">            combination.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="external">Description</a>: Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where<br>the candidate numbers sums to T. Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,<br>A solution set is:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</div><div class="line">        sort(candidates.begin(), candidates.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; combination;</div><div class="line">        search(candidates, combination, result, target, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; combination, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="keyword">int</span> target, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            result.push_back(combination);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; candidates.size() &amp;&amp; target &gt;= candidates[i]; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i == begin || candidates[i] != candidates[i - <span class="number">1</span>])            <span class="comment">//跳过重复元素</span></div><div class="line">            &#123;</div><div class="line">                combination.push_back(candidates[i]);</div><div class="line">                search(candidates, combination, result, target - candidates[i], i + <span class="number">1</span>);     <span class="comment">//每个元素只可用一次</span></div><div class="line">                combination.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="external">Description</a>: Given a set of distinct integers, nums, return all possible subsets (the power set).<br>Note: The solution set must not contain duplicate subsets.<br>For example, If nums = [1,2,3], a solution is:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/********回溯法*******/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subset;</div><div class="line">        backtrack(result, subset, nums, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; subset, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        result.push_back(subset);   <span class="comment">//无需判断条件，每次递归都是一个子集</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            subset.push_back(nums[i]);</div><div class="line">            backtrack(result, subset, nums, i + <span class="number">1</span>);</div><div class="line">            subset.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 位操作法（Bit manipulation），一共2^n种情况，正好对应n位二进制数的所有0、1组合情况</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="keyword">int</span> elemNum = nums.size(), setNum = <span class="built_in">pow</span>(<span class="number">2</span>, elemNum);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(setNum);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elemNum; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; setNum; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>((j &gt;&gt; i) &amp; <span class="number">1</span>)</div><div class="line">                    result[j].push_back(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法</span></div><div class="line"><span class="comment">This problem can also be solved iteratively. Take [1, 2, 3] in the problem statement as an example. </span></div><div class="line"><span class="comment">The process of generating all the subsets is like:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Initially: [[]]</span></div><div class="line"><span class="comment">Adding the first number to all the existed subsets: [[], [1]];</span></div><div class="line"><span class="comment">Adding the second number to all the existed subsets: [[], [1], [2], [1, 2]];</span></div><div class="line"><span class="comment">Adding the third number to all the existed subsets: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]].</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> n = result.size();  <span class="comment">//注意size()在下面循环中是变化的，不能直接放到终止条件中</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</div><div class="line">            &#123;</div><div class="line">                result.push_back(result[j]);</div><div class="line">                result.back().push_back(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a>Subsets II</h3><p><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="external">Description</a>: Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).<br>Note: The solution set must not contain duplicate subsets.<br>For example,If nums = [1,2,2], a solution is:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/****************回溯法***************/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subset;</div><div class="line">        backtrack(result, subset, nums, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; subset, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        result.push_back(subset);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i != begin &amp;&amp; nums[i - <span class="number">1</span>] == nums[i])    <span class="comment">//跳过重复元素</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            subset.push_back(nums[i]);</div><div class="line">            backtrack(result, subset, nums, i + <span class="number">1</span>);</div><div class="line">            subset.pop_back();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法，对于连续k个重复元素，加入子集中的数量可以为[0, 1, ..., k]</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i + count &lt; nums.size() &amp;&amp; nums[i] == nums[i + count])</div><div class="line">                count++;</div><div class="line">            <span class="keyword">int</span> previousN = result.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; previousN; j++)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; instance = result[j];</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count; k++)</div><div class="line">                &#123;</div><div class="line">                    instance.push_back(nums[i]);</div><div class="line">                    result.push_back(instance);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            i += count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">迭代法，如果存在重复元素，则从上一次的size处开始复制子集，添加新元素，直至这一次的size处</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</div><div class="line">                start = size;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                start = <span class="number">0</span>;</div><div class="line">            size = result.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j &lt; size; j++)</div><div class="line">            &#123;</div><div class="line">                result.push_back(result[j]);</div><div class="line">                result.back().push_back(nums[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中回溯(Backtracking)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="recursive" scheme="https://senitco.github.io/tags/recursive/"/>
    
      <category term="backtracking" scheme="https://senitco.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>位操作(Bit Manipulation)问题集锦</title>
    <link href="https://senitco.github.io/2018/03/05/data-structure-bit-manipulation/"/>
    <id>https://senitco.github.io/2018/03/05/data-structure-bit-manipulation/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.884Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中位操作(Bit Manipulation)问题总结归纳。<br><a id="more"></a></p>
<h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><p>题目描述：<a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="external">LeetCode</a><br>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br>分析：最大次数为两次，使用1位即可表示，即采用一个int型变量存储数组的元素和，在累加过程中除以2取余，每一位的变化过程为0-&gt;1-&gt;0(2/0)，利用异或操作实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        ones = ones ^ nums[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Single-Number-II"><a href="#Single-Number-II" class="headerlink" title="Single Number II"></a>Single Number II</h3><p>题目描述：<a href="https://leetcode.com/problems/single-number-ii/description/" target="_blank" rel="external">LeetCode</a><br>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.<br>Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//hash表，用到了额外的存储空间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        cnt[nums[i]]++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t : cnt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(t.second == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> t.first;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//位操作，对int型数据（32位）分别进行求和除以3取余，所得数字即为所求</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; digit(<span class="number">32</span>, <span class="number">0</span>);   <span class="comment">//固定数组仍为常量存储空间</span></div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)</div><div class="line">        &#123;</div><div class="line">            digit[j] += (nums[i] &gt;&gt; j) &amp; <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</div><div class="line">    &#123;</div><div class="line">        result += (digit[i] % <span class="number">3</span>) &lt;&lt; i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">位操作：用两个int数据分别存储数组和的低位和高位，最大次数为3，因此使用两位即可表示，</span></div><div class="line"><span class="comment">所以采用两个int型数据，在累加过程中需要对3取余，因此每一位的变化过程为00(0)-&gt;01(1)</span></div><div class="line"><span class="comment">-&gt;10(2)-&gt;00(3/0)。代码中的表达式可由数字逻辑的真值表求得</span></div><div class="line"><span class="comment">See [here](http://blog.csdn.net/yutianzuijin/article/details/50597413)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">    &#123;</div><div class="line">        low = (low ^ nums[i]) &amp; ~high;</div><div class="line">        high = (high ^ nums[i]) &amp; ~low;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Gray-Code"><a href="#Gray-Code" class="headerlink" title="Gray Code"></a>Gray Code</h3><p><a href="https://leetcode.com/problems/gray-code/description/" target="_blank" rel="external">Description</a>: The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<blockquote>
<p>Given a non-negative integer n representing the total number of bits in the code, print the<br>sequence of gray code. A gray code sequence must begin with 0.<br>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br>For a given n, a gray code sequence is not uniquely defined.<br>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Adding one to a number results in flipping all the bits from the rightmost zero bit to the end, e.g. </span></div><div class="line"><span class="comment">110011 + 1 = 110100. In the general form, i = ...?01...1, i+1 = ...?10...0, ? represents the left bit </span></div><div class="line"><span class="comment">of the rightmost zero bit, the length of tailing one bits of i is the same as the length of tailing </span></div><div class="line"><span class="comment">0 bits of i+1, and the bits from the beginning to the ? are the same.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Then i^(i&gt;&gt;1) = xxx(?^0)10...0, (i+1)^((i+1)&gt;&gt;1) = xxx(?^1)10...0. Since the bits from the beginning </span></div><div class="line"><span class="comment">to the ? are the same, xxx part of both results must be same, it's obvious the tailing parts of 10...0 </span></div><div class="line"><span class="comment">must be same, and its length is the same as the length of tailing one bits of i, so there is only one </span></div><div class="line"><span class="comment">bit difference comes from (?^0) and (?^1).</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">See https://discuss.leetcode.com/topic/8557/an-accepted-three-line-solution-in-java</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">简单翻译一下：对于i和i+1，i的二进制形式(i = ...?01...1)的最右边的连续为1和数量，和i+1的二进制形式(i+1 = ...?10...0)</span></div><div class="line"><span class="comment">的最右边连续为0的数量是一样的，？表示i的二进制形式的最右边的0比特和左边一个比特，同样的，i的起始比特位到？处与i+1的起始比特</span></div><div class="line"><span class="comment">位到？处是一致的。</span></div><div class="line"><span class="comment">考虑 i^(i&gt;&gt;1) = xxx(?^0)10...0，以及 (i+1)^((i+1)&gt;&gt;1) = xxx(?^1)10...0，由于起始比特位到？处是一致的，因此两个二进</span></div><div class="line"><span class="comment">制序列xxx部分是一致的，也就是说上述两个表达式只有 (?^0) 和 (?^1) 对应的比特位不一样</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> num = <span class="number">1</span> &lt;&lt; n;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</div><div class="line">        &#123;</div><div class="line">            result.push_back(i ^ (i &gt;&gt; <span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Generate the sequence iteratively. For example, when n=3, we can get the result based on n=2.</span></div><div class="line"><span class="comment">00,01,11,10 -&gt; (000,001,011,010 ) (110,111,101,100). The middle two numbers only differ at </span></div><div class="line"><span class="comment">their highest bit, while the rest numbers of part two are exactly symmetric of part one. It </span></div><div class="line"><span class="comment">is easy to see its correctness.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        result.push_back(<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> size = result.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</div><div class="line">            &#123;</div><div class="line">                result.push_back(result[j] | <span class="number">1</span> &lt;&lt; i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中位操作(Bit Manipulation)问题总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="bit manipulation" scheme="https://senitco.github.io/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>贪心(Greedy)问题集锦</title>
    <link href="https://senitco.github.io/2018/03/02/data-structure-greedy/"/>
    <id>https://senitco.github.io/2018/03/02/data-structure-greedy/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-08-03T04:22:11.885Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法中贪心问题的总结归纳。<br><a id="more"></a></p>
<h3 id="Gas-Station"><a href="#Gas-Station" class="headerlink" title="Gas Station"></a>Gas Station</h3><p>题目描述：<a href="https://leetcode.com/problems/gas-station/description/" target="_blank" rel="external">LeetCode</a><br>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.<br>Note: The solution is guaranteed to be unique.<br>分析：（1）如果gas总储存量不小于总消耗量，那么一定存在一条循环路线<br>（2）如果某一点的累积存储量小于累积消耗量，那么将下一点作为起始点（如果A点不能到达B点，那么A、B之间的任一点都无法到B点，因此直接选取B的下一点作为起始点）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> size = gas.size();</div><div class="line">    <span class="keyword">int</span> sumGas = <span class="number">0</span>, sumCost = <span class="number">0</span>, tank = <span class="number">0</span>, start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">    &#123;</div><div class="line">        sumGas += gas[i];</div><div class="line">        sumCost += cost[i];</div><div class="line">        tank += gas[i] - cost[i];</div><div class="line">        <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)  </div><div class="line">        &#123;</div><div class="line">            start = i + <span class="number">1</span>;</div><div class="line">            tank = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(sumGas &lt; sumCost)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> start;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h3><p><a href="https://leetcode.com/problems/jump-game/description/" target="_blank" rel="external">Description</a>: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.<br>A = [3,2,1,0,4], return false.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">1. 能跳到位置i的条件：i&lt;=maxIndex。</span></div><div class="line"><span class="comment">2. 一旦跳到i，则maxIndex = max(maxIndex, i+nums[i])。</span></div><div class="line"><span class="comment">3. 能跳到最后一个位置n-1的条件是：maxIndex &gt;= n-1</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>, size = nums.size();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; maxIndex || maxIndex &gt;= size - <span class="number">1</span>)</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            maxIndex = max(maxIndex, nums[i] + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxIndex &gt;= size - <span class="number">1</span>; </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = nums.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> reach = <span class="number">0</span>; i &lt; n &amp;&amp; i &lt;= reach; ++i)</div><div class="line">            reach = max(i + nums[i], reach);</div><div class="line">        <span class="keyword">return</span> i == n;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h3><p><a href="https://leetcode.com/problems/jump-game-ii/description/" target="_blank" rel="external">Description</a>: Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.<br>For example: Given array A = [2,3,1,1,4]<br>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)<br>Note: You can assume that you can always reach the last index.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">currentMax表示当前能够到达的最大长度，nextMax表示下一步可以到达的最大长度，在currentMax范围内遍历，</span></div><div class="line"><span class="comment">确定下一步的最长范围nextMax，超过currentMax则跳数递增，并让 currentMax = nextMax，继续下一轮遍历，</span></div><div class="line"><span class="comment">时间复杂度为O(N)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> currentMax = <span class="number">0</span>, nextMax = <span class="number">0</span>, i = <span class="number">0</span>, step = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(currentMax &gt;= i)</div><div class="line">        &#123;</div><div class="line">            step++;</div><div class="line">            <span class="keyword">for</span>(; i &lt;= currentMax; i++)</div><div class="line">            &#123;</div><div class="line">                nextMax = max(nextMax, i + nums[i]);</div><div class="line">                <span class="keyword">if</span>(nextMax &gt;= nums.size() - <span class="number">1</span>)</div><div class="line">                    <span class="keyword">return</span> step;</div><div class="line">            &#125;</div><div class="line">            currentMax = nextMax;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, currentMax = <span class="number">0</span>, nextMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(i &gt; currentMax)</div><div class="line">            &#123;</div><div class="line">                currentMax = nextMax;</div><div class="line">                cnt++;</div><div class="line">            &#125;</div><div class="line">            nextMax = max(nextMax, nums[i] + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cnt;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构与算法中贪心问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="greedy" scheme="https://senitco.github.io/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>二叉树问题集锦（二）</title>
    <link href="https://senitco.github.io/2018/02/27/data-structure-binary-tree-2/"/>
    <id>https://senitco.github.io/2018/02/27/data-structure-binary-tree-2/</id>
    <published>2018-02-26T16:00:00.000Z</published>
    <updated>2018-03-20T04:43:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构中二叉树问题的总结归纳。<br><a id="more"></a></p>
<p>二叉树结点定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left;</div><div class="line">    TreeNode *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Minimum-Depth-of-Binary-Tree"><a href="#Minimum-Depth-of-Binary-Tree" class="headerlink" title="Minimum Depth of Binary Tree"></a>Minimum Depth of Binary Tree</h3><p>题目描述：Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, minDepth = INT_MAX;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        traverse(root, depth, minDepth);</div><div class="line">        <span class="keyword">return</span> minDepth;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="keyword">int</span>&amp; minDepth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(depth &lt; minDepth)</div><div class="line">                minDepth = depth;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;   </div><div class="line">        traverse(node-&gt;left, depth + <span class="number">1</span>, minDepth);</div><div class="line">        traverse(node-&gt;right, depth + <span class="number">1</span>, minDepth);  </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> l = minDepth(root-&gt;left);</div><div class="line">        <span class="keyword">int</span> r = minDepth(root-&gt;right);</div><div class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span> + l + r;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + min(l, r);    </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">广度优先遍历（层序遍历），找到的第一个叶节点的深度即是最浅，不需要遍历所有结点</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</div><div class="line">        TreeNode *last, *now;</div><div class="line">        <span class="keyword">int</span> level, size;</div><div class="line">        last = now = root;</div><div class="line">        level = <span class="number">1</span>;</div><div class="line">        qu.push(root);</div><div class="line">        <span class="keyword">while</span>(qu.size())</div><div class="line">        &#123;</div><div class="line">            now = qu.front();</div><div class="line">            qu.pop();</div><div class="line">            size = qu.size();</div><div class="line">            <span class="keyword">if</span>(now-&gt;left)   qu.push(now-&gt;left);</div><div class="line">            <span class="keyword">if</span>(now-&gt;right)  qu.push(now-&gt;right);</div><div class="line">            <span class="keyword">if</span>(qu.size() == size)   <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">if</span>(last == now)</div><div class="line">            &#123;</div><div class="line">                level++;</div><div class="line">                <span class="keyword">if</span>(qu.size())</div><div class="line">                    last = qu.back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> level;      </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><p>题目描述：Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">For example: Given binary tree [3,9,20,null,null,15,7],</span></div><div class="line"><span class="comment">    3</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  9  20</span></div><div class="line"><span class="comment">    /  \</span></div><div class="line"><span class="comment">   15   7</span></div><div class="line"><span class="comment">return its depth = 3.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">//队列实现层序遍历（广度优先遍历）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; toVisit;</div><div class="line">        toVisit.push(root);</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(!toVisit.empty())</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> size = toVisit.size();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">            &#123;</div><div class="line">                TreeNode* curr = toVisit.front();</div><div class="line">                toVisit.pop();</div><div class="line">                <span class="keyword">if</span>(curr-&gt;left)  toVisit.push(curr-&gt;left);</div><div class="line">                <span class="keyword">if</span>(curr-&gt;right) toVisit.push(curr-&gt;right);</div><div class="line">            &#125;</div><div class="line">            depth++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> depth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//中序遍历</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!root)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>, maxDepth = <span class="number">0</span>;</div><div class="line">        traverse(root, depth, maxDepth);</div><div class="line">        <span class="keyword">return</span> maxDepth;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="keyword">int</span>&amp; maxDepth)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(depth &gt; maxDepth)</div><div class="line">                maxDepth = depth;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;   </div><div class="line">        traverse(node-&gt;left, depth + <span class="number">1</span>, maxDepth);</div><div class="line">        traverse(node-&gt;right, depth + <span class="number">1</span>, maxDepth);  </div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//递归遍历（深度优先遍历）</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><p>题目描述：Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="external">LeetCode</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">Example 1: Given the following tree [3,9,20,null,null,15,7]:</span></div><div class="line"><span class="comment">    3</span></div><div class="line"><span class="comment">   / \</span></div><div class="line"><span class="comment">  9  20</span></div><div class="line"><span class="comment">    /  \</span></div><div class="line"><span class="comment">   15   7</span></div><div class="line"><span class="comment">Return true.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]:</span></div><div class="line"><span class="comment">       1</span></div><div class="line"><span class="comment">      / \</span></div><div class="line"><span class="comment">     2   2</span></div><div class="line"><span class="comment">    / \</span></div><div class="line"><span class="comment">   3   3</span></div><div class="line"><span class="comment">  / \</span></div><div class="line"><span class="comment"> 4   4</span></div><div class="line"><span class="comment">Return false.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">自顶向下：判断每个结点左右子树的深度，如果深度差大于1，则返回false，否则继续考察其子结点是否为平衡树</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">int</span> left = depth(root-&gt;left);</div><div class="line">        <span class="keyword">int</span> right = depth(root-&gt;right);</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> max(depth(node-&gt;left), depth(node-&gt;right)) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">自底向上，后序遍历（左-右-中），从叶子结点开始计算每个结点的高度，并判断左右子树的高度差是否大于1，</span></div><div class="line"><span class="comment">若大于1则递归返回1，否则进一步判断其他结点是否为平衡树。（相比于自顶向下，该方法更高效）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">return</span> dfsHeight(root) != <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* node)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> left = dfsHeight(node-&gt;left);</div><div class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">int</span> right = dfsHeight(node-&gt;right);</div><div class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构中二叉树问题的总结归纳。&lt;br&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="https://senitco.github.io/categories/Data-Structure/"/>
    
    
      <category term="code" scheme="https://senitco.github.io/tags/code/"/>
    
      <category term="dfs" scheme="https://senitco.github.io/tags/dfs/"/>
    
      <category term="binary tree" scheme="https://senitco.github.io/tags/binary-tree/"/>
    
      <category term="bfs" scheme="https://senitco.github.io/tags/bfs/"/>
    
  </entry>
  
</feed>
