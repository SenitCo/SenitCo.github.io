<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Image," />





  <link rel="alternate" href="/atom.xml" title="Senit_Co" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="&amp;emsp;&amp;emsp;局部二值模式(Local Binary Patter, LBP)是一种用来描述图像局部纹理特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点，它将图像中的各个像素与其邻域像素值进行比较，将结果保存为二进制数，并将得到的二进制比特串作为中心像素的编码值，也就是LBP特征值。LBP提供了一种衡量像素间邻域关系的特征模式，因此可以有效地提取图像的局部特征，而且由于其计算简">
<meta property="og:type" content="article">
<meta property="og:title" content="图像特征提取之LBP特征">
<meta property="og:url" content="https://senitco.github.io/2017/06/12/image-feature-lbp/index.html">
<meta property="og:site_name" content="Senit_Co">
<meta property="og:description" content="&amp;emsp;&amp;emsp;局部二值模式(Local Binary Patter, LBP)是一种用来描述图像局部纹理特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点，它将图像中的各个像素与其邻域像素值进行比较，将结果保存为二进制数，并将得到的二进制比特串作为中心像素的编码值，也就是LBP特征值。LBP提供了一种衡量像素间邻域关系的特征模式，因此可以有效地提取图像的局部特征，而且由于其计算简">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/12/593e3dae121e4.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/12/593e49563d486.png">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/13/593f6abf457df.jpg">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/13/593f48869b16f.png">
<meta property="og:image" content="https://ooo.0o0.ooo/2017/06/13/593f4e9ec38c4.jpg">
<meta property="og:updated_time" content="2017-06-13T04:35:51.262Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="图像特征提取之LBP特征">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;局部二值模式(Local Binary Patter, LBP)是一种用来描述图像局部纹理特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点，它将图像中的各个像素与其邻域像素值进行比较，将结果保存为二进制数，并将得到的二进制比特串作为中心像素的编码值，也就是LBP特征值。LBP提供了一种衡量像素间邻域关系的特征模式，因此可以有效地提取图像的局部特征，而且由于其计算简">
<meta name="twitter:image" content="https://ooo.0o0.ooo/2017/06/12/593e3dae121e4.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6392863219974669000,
      author: 'Author'
    }
  };
</script>

  <title> 图像特征提取之LBP特征 | Senit_Co </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Senit_Co</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                图像特征提取之LBP特征
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-06-12T14:16:51+08:00" content="2017-06-12">
              2017-06-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/12/image-feature-lbp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/12/image-feature-lbp/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>&emsp;&emsp;局部二值模式(Local Binary Patter, LBP)是一种用来描述图像局部纹理特征的算子，LBP特征具有灰度不变性和旋转不变性等显著优点，它将图像中的各个像素与其邻域像素值进行比较，将结果保存为二进制数，并将得到的二进制比特串作为中心像素的编码值，也就是LBP特征值。LBP提供了一种衡量像素间邻域关系的特征模式，因此可以有效地提取图像的局部特征，而且由于其计算简单，可用于基于纹理分类的实时应用场景，例如目标检测、人脸识别等。<br><a id="more"></a></p>
<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    messageStyle: "none",
    "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<h3 id="原始LBP特征"><a href="#原始LBP特征" class="headerlink" title="原始LBP特征"></a>原始LBP特征</h3><p>&emsp;&emsp;原始的LBP算子定义于图像中$3 \times 3$的邻域窗口，取窗口内中心像素的灰度值作为阈值，将8邻域像素的灰度值与其进行比较，若邻域像素值大于中心像素值，则比较结果取值为1，否则为0。这样邻域内的8个像素点经过比较后可得到8位二进制数，将其按顺序依次排列即可得到中心像素的LBP值。LBP特征值反映了中心像素和其邻域的纹理信息。LBP的取值一共有$2^8 = 256$种，和一幅普通的灰度图像类似，因此可将LBP特征以灰度图的形式表达出来。由于LBP特征考虑的是纹理信息，而不包含颜色信息，因此彩色图需转换为灰度图。原始LBP特征的提取过程如下图所示：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/12/593e3dae121e4.jpg" alt="origin-LBP.jpg" title="LBP特征提取"></p>
<p>公式定义如下：<br>$$LBP(x_c,y_c)=\Sigma_{p=0}^{P-1} 2^p s(i_p-i_c)$$<br>其中$(x_c,y_c)$代表邻域窗口内的中心像素，其像素值为$i_c$，$i_p为邻域内其他像素值$，s(x)是符号函数。<br>原始LBP特征的实现代码(OpenCV)如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">template &lt;typename _tp&gt;</div><div class="line">void getOriginLBPFeature(InputArray _src,OutputArray _dst)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    _dst.create(src.rows-2,src.cols-2,CV_8UC1);</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    dst.setTo(0);</div><div class="line">    for(int i=1;i&lt;src.rows-1;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=1;j&lt;src.cols-1;j++)</div><div class="line">        &#123;</div><div class="line">            _tp center = src.at&lt;_tp&gt;(i,j);</div><div class="line">            unsigned char lbpCode = 0;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i-1,j-1) &gt; center) &lt;&lt; 7;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i-1,j  ) &gt; center) &lt;&lt; 6;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i-1,j+1) &gt; center) &lt;&lt; 5;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i  ,j+1) &gt; center) &lt;&lt; 4;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i+1,j+1) &gt; center) &lt;&lt; 3;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i+1,j  ) &gt; center) &lt;&lt; 2;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i+1,j-1) &gt; center) &lt;&lt; 1;</div><div class="line">            lbpCode |= (src.at&lt;_tp&gt;(i  ,j-1) &gt; center) &lt;&lt; 0;</div><div class="line">            dst.at&lt;uchar&gt;(i-1,j-1) = lbpCode;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="圆形LBP特征-Circular-LBP-or-Extended-LBP"><a href="#圆形LBP特征-Circular-LBP-or-Extended-LBP" class="headerlink" title="圆形LBP特征(Circular LBP or Extended LBP)"></a>圆形LBP特征(Circular LBP or Extended LBP)</h3><p>&emsp;&emsp;原始LBP特征考虑的是固定半径范围内的邻域像素，不能满足不同尺寸和频率纹理的需求，当图像的尺寸发生变化时，LBP特征将不能正确编码局部邻域的纹理信息。为了适应不同尺寸的纹理特征，Ojala等人对LBP算子<br>进行了改进，将$3 \times 3$邻域窗口扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的LBP算子允许在半径为R的邻域内有任意多个像素点，从而得到在半径为R的区域内含有P个采样点的LBP算子。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/12/593e49563d486.png" alt="circular-lbp.png" title="不同尺寸的圆形LBP算子"></p>
<p>采样点的坐标可通过以下公式计算：<br>$$x_p=x_c+R cos(2\pi p / P)$$<br>$$y_p=y_c+R sin(2\pi p / P)$$<br>其中$(x_c,y_c)$为中心像素点，$(x_p,y_p),p\in P$为邻域内某个采样点，通过上次可以计算任意个采样点的坐标，但是得到的坐标值未必为整数，因此可通过双线性插值的方法来得到该采样点的像素值：<br>$$f(x, y) = \left[ \begin{matrix} 1-x&amp; x\end{matrix} \right] \left[ \begin{matrix} f(0,0)&amp; f(0,1)\\ f(1,0)&amp; f(1,1)\end{matrix} \right] \left[ \begin{matrix} 1-y\\ y\end{matrix} \right]$$</p>
<p>圆形LBP特征的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">//圆形LBP特征计算，这种方法适于理解，但在效率上存在问题，声明时默认neighbors=8</div><div class="line">template &lt;typename _tp&gt;</div><div class="line">void getCircularLBPFeature(InputArray _src,OutputArray _dst,int radius,int neighbors)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    //LBP特征图像的行数和列数的计算要准确</div><div class="line">    _dst.create(src.rows-2*radius,src.cols-2*radius,CV_8UC1);</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    dst.setTo(0);</div><div class="line">    //循环处理每个像素</div><div class="line">    for(int i=radius;i&lt;src.rows-radius;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=radius;j&lt;src.cols-radius;j++)</div><div class="line">        &#123;</div><div class="line">            //获得中心像素点的灰度值</div><div class="line">            _tp center = src.at&lt;_tp&gt;(i,j);</div><div class="line">            unsigned char lbpCode = 0;</div><div class="line">            for(int k=0;k&lt;neighbors;k++)</div><div class="line">            &#123;</div><div class="line">                //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin</div><div class="line">                float x = i + static_cast&lt;float&gt;(radius * \</div><div class="line">                    cos(2.0 * CV_PI * k / neighbors));</div><div class="line">                float y = j - static_cast&lt;float&gt;(radius * \</div><div class="line">                    sin(2.0 * CV_PI * k / neighbors));</div><div class="line">                //根据取整结果进行双线性插值，得到第k个采样点的灰度值</div><div class="line"></div><div class="line">                //1.分别对x，y进行上下取整</div><div class="line">                int x1 = static_cast&lt;int&gt;(floor(x));</div><div class="line">                int x2 = static_cast&lt;int&gt;(ceil(x));</div><div class="line">                int y1 = static_cast&lt;int&gt;(floor(y));</div><div class="line">                int y2 = static_cast&lt;int&gt;(ceil(y));</div><div class="line"></div><div class="line">                //2.计算四个点(x1,y1),(x1,y2),(x2,y1),(x2,y2)的权重</div><div class="line">                //下面的权重计算方式有个问题，如果四个点都相等，则权重全为0，计算出来的插值为0</div><div class="line">                //float w1 = (x2-x)*(y2-y); //(x1,y1)</div><div class="line">                //float w2 = (x2-x)*(y-y1); //(x1,y2)</div><div class="line">                //float w3 = (x-x1)*(y2-y); //(x2,y1)</div><div class="line">                //float w4 = (x-x1)*(y-y1); //(x2,y2)</div><div class="line"></div><div class="line">                //将坐标映射到0-1之间</div><div class="line">                float tx = x - x1;</div><div class="line">                float ty = y - y1;</div><div class="line">                //根据0-1之间的x，y的权重计算公式计算权重</div><div class="line">                float w1 = (1-tx) * (1-ty);</div><div class="line">                float w2 =    tx  * (1-ty);</div><div class="line">                float w3 = (1-tx) *    ty;</div><div class="line">                float w4 =    tx  *    ty;</div><div class="line">                //3.根据双线性插值公式计算第k个采样点的灰度值</div><div class="line">                float neighbor = src.at&lt;_tp&gt;(x1,y1) * w1 + src.at&lt;_tp&gt;(x1,y2) *w2 \</div><div class="line">                    + src.at&lt;_tp&gt;(x2,y1) * w3 +src.at&lt;_tp&gt;(x2,y2) *w4;</div><div class="line">                //通过比较获得LBP值，并按顺序排列起来</div><div class="line">                lbpCode |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);</div><div class="line">            &#125;</div><div class="line">            dst.at&lt;uchar&gt;(i-radius,j-radius) = lbpCode;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>圆形LBP特征的效率优化版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//圆形LBP特征计算，效率优化版本，声明时默认neighbors=8</div><div class="line">template &lt;typename _tp&gt;</div><div class="line">void getCircularLBPFeatureOptimization(InputArray _src,OutputArray _dst,int radius,int neighbors)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    //LBP特征图像的行数和列数的计算要准确</div><div class="line">    _dst.create(src.rows-2*radius,src.cols-2*radius,CV_8UC1);</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    dst.setTo(0);</div><div class="line">    for(int k=0;k&lt;neighbors;k++)</div><div class="line">    &#123;</div><div class="line">        //计算采样点对于中心点坐标的偏移量rx，ry</div><div class="line">        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));</div><div class="line">        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));</div><div class="line">        //为双线性插值做准备</div><div class="line">        //对采样点偏移量分别进行上下取整</div><div class="line">        int x1 = static_cast&lt;int&gt;(floor(rx));</div><div class="line">        int x2 = static_cast&lt;int&gt;(ceil(rx));</div><div class="line">        int y1 = static_cast&lt;int&gt;(floor(ry));</div><div class="line">        int y2 = static_cast&lt;int&gt;(ceil(ry));</div><div class="line">        //将坐标偏移量映射到0-1之间</div><div class="line">        float tx = rx - x1;</div><div class="line">        float ty = ry - y1;</div><div class="line">        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关</div><div class="line">        float w1 = (1-tx) * (1-ty);</div><div class="line">        float w2 =    tx  * (1-ty);</div><div class="line">        float w3 = (1-tx) *    ty;</div><div class="line">        float w4 =    tx  *    ty;</div><div class="line">        //循环处理每个像素</div><div class="line">        for(int i=radius;i&lt;src.rows-radius;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=radius;j&lt;src.cols-radius;j++)</div><div class="line">            &#123;</div><div class="line">                //获得中心像素点的灰度值</div><div class="line">                _tp center = src.at&lt;_tp&gt;(i,j);</div><div class="line">                //根据双线性插值公式计算第k个采样点的灰度值</div><div class="line">                float neighbor = src.at&lt;_tp&gt;(i+x1,j+y1) * w1 + src.at&lt;_tp&gt;(i+x1,j+y2) *w2 \</div><div class="line">                    + src.at&lt;_tp&gt;(i+x2,j+y1) * w3 +src.at&lt;_tp&gt;(i+x2,j+y2) *w4;</div><div class="line">                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得</div><div class="line">                dst.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="旋转不变LBP特征-Rotation-Invariant-LBP"><a href="#旋转不变LBP特征-Rotation-Invariant-LBP" class="headerlink" title="旋转不变LBP特征(Rotation Invariant LBP)"></a>旋转不变LBP特征(Rotation Invariant LBP)</h3><p>&emsp;&emsp;无论是原始LBP算子还是圆形LBP算子，都只是灰度不变的，而不是旋转不变的，旋转图像会得到不同的LBP特征值。相关研究人员又提出了一种具有旋转不变性的LBP算子，即不断旋转圆形邻域的采样点，或者以不同的邻域像素作为起始点，顺时针遍历所有采样点，得到一系列编码值(P个)，取其中最小的作为该邻域中心像素的LBP值。旋转不变LBP算子的示意图如下：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/13/593f6abf457df.jpg" alt="Rota-inv-lbp.jpg" title="旋转不变LBP算子"></p>
<p>旋转不变LBP特征的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">//旋转不变圆形LBP特征计算，声明时默认neighbors=8</div><div class="line">template &lt;typename _tp&gt;</div><div class="line">void getRotationInvariantLBPFeature(InputArray _src,OutputArray _dst,int radius,int neighbors)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    //LBP特征图像的行数和列数的计算要准确</div><div class="line">    _dst.create(src.rows-2*radius,src.cols-2*radius,CV_8UC1);</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    dst.setTo(0);</div><div class="line">    for(int k=0;k&lt;neighbors;k++)</div><div class="line">    &#123;</div><div class="line">        //计算采样点对于中心点坐标的偏移量rx，ry</div><div class="line">        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));</div><div class="line">        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));</div><div class="line">        //为双线性插值做准备</div><div class="line">        //对采样点偏移量分别进行上下取整</div><div class="line">        int x1 = static_cast&lt;int&gt;(floor(rx));</div><div class="line">        int x2 = static_cast&lt;int&gt;(ceil(rx));</div><div class="line">        int y1 = static_cast&lt;int&gt;(floor(ry));</div><div class="line">        int y2 = static_cast&lt;int&gt;(ceil(ry));</div><div class="line">        //将坐标偏移量映射到0-1之间</div><div class="line">        float tx = rx - x1;</div><div class="line">        float ty = ry - y1;</div><div class="line">        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关</div><div class="line">        float w1 = (1-tx) * (1-ty);</div><div class="line">        float w2 =    tx  * (1-ty);</div><div class="line">        float w3 = (1-tx) *    ty;</div><div class="line">        float w4 =    tx  *    ty;</div><div class="line">        //循环处理每个像素</div><div class="line">        for(int i=radius;i&lt;src.rows-radius;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=radius;j&lt;src.cols-radius;j++)</div><div class="line">            &#123;</div><div class="line">                //获得中心像素点的灰度值</div><div class="line">                _tp center = src.at&lt;_tp&gt;(i,j);</div><div class="line">                //根据双线性插值公式计算第k个采样点的灰度值</div><div class="line">                float neighbor = src.at&lt;_tp&gt;(i+x1,j+y1) * w1 + src.at&lt;_tp&gt;(i+x1,j+y2) *w2 \</div><div class="line">                    + src.at&lt;_tp&gt;(i+x2,j+y1) * w3 +src.at&lt;_tp&gt;(i+x2,j+y2) *w4;</div><div class="line">                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得</div><div class="line">                dst.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //进行旋转不变处理</div><div class="line">    for(int i=0;i&lt;dst.rows;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=0;j&lt;dst.cols;j++)</div><div class="line">        &#123;</div><div class="line">            unsigned char currentValue = dst.at&lt;uchar&gt;(i,j);</div><div class="line">            unsigned char minValue = currentValue;</div><div class="line">            for(int k=1;k&lt;neighbors;k++)		//循环左移</div><div class="line">            &#123;</div><div class="line">                unsigned char temp = (currentValue&gt;&gt;(neighbors-k)) | (currentValue&lt;&lt;k);</div><div class="line">                if(temp &lt; minValue)</div><div class="line">                &#123;</div><div class="line">                    minValue = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            dst.at&lt;uchar&gt;(i,j) = minValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="LBP等价模式-Uniform-LBP"><a href="#LBP等价模式-Uniform-LBP" class="headerlink" title="LBP等价模式(Uniform LBP)"></a>LBP等价模式(Uniform LBP)</h3><p>&emsp;&emsp;对于一个半径为R的圆形区域，包含有P个邻域采样点，则LBP算子可能产生$2^P$种模式。随着邻域内采样点数的增加，LBP值的取值数量呈指数级增长。例如$5 \times 5$邻域内20个采样点，则对应有$2^{20}$中模式，过多的二进制模式不利于纹理信息的提取、分类、识别。例如，将LBP特征用于纹理分类或人脸识别时，一般采用LBP特征的统计直方图来表达图像的信息，而较多的模式种类将使得数据量过大，且直方图过于稀疏。因此，需要对原始的LBP特征进行降维，使得数据量减少的情况下能最好地表达图像的信息。<br>&emsp;&emsp;为了解决二进制模式过多的问题，提高统计性，Ojala提出了一种“等价模式”(Uniform Pattern)来对LBP特征的模式种类进行降维。Ojala认为，在实际图像中，绝大数LBP模式最多只包含两次从0到1或者从1到0的跳变，“等价模式”定义为：当某个LBP所对应的循环二进制数从0到1或者从1到0最多有两次跳变时，该LBP所对应的二进制就是一个等价模式类。如00000000(0次跳变)，11000011(2次跳变)都是等价模式类。除等价模式类以外的模式都归为另一类，称为混合模式类，例如10010111(共4次跳变)。通过改进，二进制模式的种类大大减少，由原来的$2^P$中降为$P(P-1)+2+1$种，其中$P(P-1)$为2次跳变的模式数，2为0次跳变(全”0”或全”1”)的模式数，1为混合模式的数量，由于是循环二进制数，因此’0’、’1’跳变次数不可能为奇数次。对于$3 \times 3$邻域内8个采样点来说，二进制模式由原始的256种变为59种。这使得特征向量的维数大大减少，并且可以减少高频噪声带来的影响。实验表明，一般情况下，等价模式的数目占全部模式的90%以上，可以有效对数据进行降维。下图为58种等价模式类：</p>
<p><img src="https://ooo.0o0.ooo/2017/06/13/593f48869b16f.png" alt="uniform LBP.png" title="LBP等价模式"></p>
<p>在具体实现中，等价模式类按值递增从1开始编码，混合模式类编码为0，因此得到的LBP特征图整体偏暗。LBP等价模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">//等价模式LBP特征计算</div><div class="line">template &lt;typename _tp&gt;</div><div class="line">void getUniformPatternLBPFeature(InputArray _src,OutputArray _dst,int radius,int neighbors)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    //LBP特征图像的行数和列数的计算要准确</div><div class="line">    _dst.create(src.rows-2*radius,src.cols-2*radius,CV_8UC1);</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    dst.setTo(0);</div><div class="line">    //LBP特征值对应图像灰度编码表，直接默认采样点为8位</div><div class="line">    uchar temp = 1;</div><div class="line">    uchar table[256] = &#123;0&#125;;</div><div class="line">    for(int i=0;i&lt;256;i++)</div><div class="line">    &#123;</div><div class="line">        if(getHopTimes(i)&lt;3)</div><div class="line">        &#123;</div><div class="line">            table[i] = temp;</div><div class="line">            temp++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //是否进行UniformPattern编码的标志</div><div class="line">    bool flag = false;</div><div class="line">    //计算LBP特征图</div><div class="line">    for(int k=0;k&lt;neighbors;k++)</div><div class="line">    &#123;</div><div class="line">        if(k==neighbors-1)</div><div class="line">        &#123;</div><div class="line">            flag = true;</div><div class="line">        &#125;</div><div class="line">        //计算采样点对于中心点坐标的偏移量rx，ry</div><div class="line">        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));</div><div class="line">        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));</div><div class="line">        //为双线性插值做准备</div><div class="line">        //对采样点偏移量分别进行上下取整</div><div class="line">        int x1 = static_cast&lt;int&gt;(floor(rx));</div><div class="line">        int x2 = static_cast&lt;int&gt;(ceil(rx));</div><div class="line">        int y1 = static_cast&lt;int&gt;(floor(ry));</div><div class="line">        int y2 = static_cast&lt;int&gt;(ceil(ry));</div><div class="line">        //将坐标偏移量映射到0-1之间</div><div class="line">        float tx = rx - x1;</div><div class="line">        float ty = ry - y1;</div><div class="line">        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关</div><div class="line">        float w1 = (1-tx) * (1-ty);</div><div class="line">        float w2 =    tx  * (1-ty);</div><div class="line">        float w3 = (1-tx) *    ty;</div><div class="line">        float w4 =    tx  *    ty;</div><div class="line">        //循环处理每个像素</div><div class="line">        for(int i=radius;i&lt;src.rows-radius;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=radius;j&lt;src.cols-radius;j++)</div><div class="line">            &#123;</div><div class="line">                //获得中心像素点的灰度值</div><div class="line">                _tp center = src.at&lt;_tp&gt;(i,j);</div><div class="line">                //根据双线性插值公式计算第k个采样点的灰度值</div><div class="line">                float neighbor = src.at&lt;_tp&gt;(i+x1,j+y1) * w1 + src.at&lt;_tp&gt;(i+x1,j+y2) *w2 \</div><div class="line">                    + src.at&lt;_tp&gt;(i+x2,j+y1) * w3 +src.at&lt;_tp&gt;(i+x2,j+y2) *w4;</div><div class="line">                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得</div><div class="line">                dst.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);</div><div class="line">                //进行LBP特征的UniformPattern编码</div><div class="line">                if(flag)</div><div class="line">                &#123;</div><div class="line">                    dst.at&lt;uchar&gt;(i-radius,j-radius) = table[dst.at&lt;uchar&gt;(i-radius,j-radius)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//计算跳变次数</div><div class="line">int getHopTimes(int n)</div><div class="line">&#123;</div><div class="line">    int count = 0;</div><div class="line">    bitset&lt;8&gt; binaryCode = n;</div><div class="line">    for(int i=0;i&lt;8;i++)</div><div class="line">    &#123;</div><div class="line">        if(binaryCode[i] != binaryCode[(i+1)%8])</div><div class="line">        &#123;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，旋转不变的Uniform LBP算子的等价模式类的数目为P+1个，对于8个采样点，基于等价模式的旋转不变LBP模式只有9个输出，该模式对于上图的Uniform LBP，每一行都是旋转不变的，对应同一个编码值。</p>
<h3 id="多尺度LBP-Multiscale-Block-LBP"><a href="#多尺度LBP-Multiscale-Block-LBP" class="headerlink" title="多尺度LBP(Multiscale Block LBP)"></a>多尺度LBP(Multiscale Block LBP)</h3><p>&emsp;&emsp;基本LBP算子获取的是单个像素和其邻域像素间的纹理信息，属于微观特征。中科院的研究人员针对此提出了一种多尺度的LBP算子，将图像分为一个个块(block)，再将每个块分为一个个的小连通区域(cell)，类似于HOG特征，cell内的灰度平均值或者和值作为当前cell的灰度阈值，与邻域cell进行比较得到LBP值，生成的特征即为MB-LBP，block大小为$3 \times 3$，cell大小为1，就是原始的LBP特征。下图所示block为$9 \times 9$，cell为$3 \times 3$。</p>
<p><img src="https://ooo.0o0.ooo/2017/06/13/593f4e9ec38c4.jpg" alt="MB-LBP.jpg" title="MB-LBP特征"></p>
<p>MB-LBP特征的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//MB-LBP特征的计算</div><div class="line">void getMultiScaleBlockLBPFeature(InputArray _src,OutputArray _dst,int scale)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    Mat dst = _dst.getMat();</div><div class="line">    //定义并计算积分图像</div><div class="line">    int cellSize = scale / 3;</div><div class="line">    int offset = cellSize / 2;</div><div class="line">    Mat cellImage(src.rows-2*offset,src.cols-2*offset,CV_8UC1);</div><div class="line">    for(int i=offset;i&lt;src.rows-offset;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=offset;j&lt;src.cols-offset;j++)</div><div class="line">        &#123;</div><div class="line">            int temp = 0;</div><div class="line">            for(int m=-offset;m&lt;offset+1;m++)</div><div class="line">            &#123;</div><div class="line">                for(int n=-offset;n&lt;offset+1;n++)</div><div class="line">                &#123;</div><div class="line">                    temp += src.at&lt;uchar&gt;(i+n,j+m);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            temp /= (cellSize*cellSize);</div><div class="line">            cellImage.at&lt;uchar&gt;(i-cellSize/2,j-cellSize/2) = uchar(temp); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    getOriginLBPFeature&lt;uchar&gt;(cellImage,dst);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>多尺度模式下同样用到了降维，论文中是直接采样统计的方法对不同尺度的LBP算子的模式进行统计，选取占比例较高的模式，而不是利用跳变规则。具体来说，就是将得到的MB-LBP特征计算统计直方图，通过对bin中的数值进行排序以及权衡，将排序在前N(63)位的特征值看作是等价模式类，其余的为混合模式类，总共为N+1类，论文中称之为(SEMB-LBP, Statistically Effective MB-LBP)。<br>SEMB-LBP的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//求SEMB-LBP</div><div class="line">void SEMB_LBPFeature(InputArray _src,OutputArray _dst,int scale)</div><div class="line">&#123;</div><div class="line">    Mat dst=_dst.getMat();</div><div class="line">    Mat MB_LBPImage;</div><div class="line">    getMultiScaleBlockLBPFeature(_src,MB_LBPImage,scale);</div><div class="line">    //imshow(&quot;dst&quot;,dst);</div><div class="line">    Mat histMat;</div><div class="line">    int histSize = 256;</div><div class="line">    float range[] = &#123;float(0),float(255)&#125;;</div><div class="line">    const float* ranges = &#123;range&#125;;</div><div class="line">    //计算LBP特征值0-255的直方图</div><div class="line">    calcHist(&amp;MB_LBPImage,1,0,Mat(),histMat,1,&amp;histSize,&amp;ranges,true,false);</div><div class="line">    histMat.reshape(1,1);</div><div class="line">    vector&lt;float&gt; histVector(histMat.rows*histMat.cols);</div><div class="line">    uchar table[256];</div><div class="line">    memset(table,64,256);</div><div class="line">    if(histMat.isContinuous())</div><div class="line">    &#123;</div><div class="line">        //histVector = (int *)(histMat.data);</div><div class="line">        //将直方图histMat变为vector向量histVector</div><div class="line">        histVector.assign((float*)histMat.datastart,(float*)histMat.dataend);</div><div class="line">        vector&lt;float&gt; histVectorCopy(histVector);</div><div class="line">        //对histVector进行排序，即对LBP特征值的数量进行排序，降序排列</div><div class="line">        sort(histVector.begin(),histVector.end(),greater&lt;float&gt;());</div><div class="line">        for(int i=0;i&lt;63;i++)</div><div class="line">        &#123;</div><div class="line">            for(int j=0;j&lt;histVectorCopy.size();j++)</div><div class="line">            &#123;</div><div class="line">                if(histVectorCopy[j]==histVector[i])</div><div class="line">                &#123;</div><div class="line">                    //得到类似于Uniform的编码表</div><div class="line">                    table[j]=i;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    dst = MB_LBPImage;</div><div class="line">    //根据编码表得到SEMB-LBP</div><div class="line">    for(int i=0;i&lt;dst.rows;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=0;j&lt;dst.cols;j++)</div><div class="line">        &#123;</div><div class="line">            dst.at&lt;uchar&gt;(i,j) = table[dst.at&lt;uchar&gt;(i,j)];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="图像的LBP特征向量-Local-Binary-Patterns-Histograms"><a href="#图像的LBP特征向量-Local-Binary-Patterns-Histograms" class="headerlink" title="图像的LBP特征向量(Local Binary Patterns Histograms)"></a>图像的LBP特征向量(Local Binary Patterns Histograms)</h3><p>&emsp;&emsp;对图像中的每个像素求取LBP特征值可得到图像的LBP特征图谱，但一般不直接将LBP图谱作为特征向量用于分类识别，而是类似于HOG特征，采用LBP特征的统计直方图作为特征向量。将LBP特征图谱划分为若干个子连通区域，并提取每个局部块的直方图，然后将这些直方图一次连接在一起形成LBP特征的统计直方图(LBPH)，即可用于分类识别的LBP特征向量。<br>LBP特征向量的具体计算过程如下：</p>
<ul>
<li>按照上述算法计算图像的LBP特征图谱</li>
<li>将LBP特征图谱分块，例如分成$8 \times 8 = 64$个区域</li>
<li>计算每个子区域中LBP特征值的统计直方图，并进行归一化，直方图大小为$1 \times numPatterns$</li>
<li>将所有区域的统计直方图按空间顺序依次连接，得到整幅图像的LBP特征向量，大小为$1 \times (numPatterns \times 64)$</li>
<li>从足够数量的样本中提取LBP特征，并利用机器学习的方法进行训练得到模型，用于分类和识别等领域。  </li>
</ul>
<p>&emsp;&emsp;对于LBP特征向量的维度，邻域采样点为8个，如果是原始的LBP特征，其模式数量为256，特征维数为$64 \times 256 = 16384$；如果是Uniform LBP特征，其模式数量为59，特征维数为$64 \times 59 = 3776$，使用等价模式特征，可以有效进行数据降维，而对模型性能却无较大影响。<br>LBP特征向量的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">//计算LBP特征图像的直方图LBPH</div><div class="line">Mat getLBPH(InputArray _src,int numPatterns,int grid_x,int grid_y,bool normed)</div><div class="line">&#123;</div><div class="line">    Mat src = _src.getMat();</div><div class="line">    int width = src.cols / grid_x;</div><div class="line">    int height = src.rows / grid_y;</div><div class="line">    //定义LBPH的行和列，grid_x*grid_y表示将图像分割成这么些块，numPatterns表示LBP值的模式种类</div><div class="line">    Mat result = Mat::zeros(grid_x * grid_y,numPatterns,CV_32FC1);</div><div class="line">    if(src.empty())</div><div class="line">    &#123;</div><div class="line">        return result.reshape(1,1);</div><div class="line">    &#125;</div><div class="line">    int resultRowIndex = 0;</div><div class="line">    //对图像进行分割，分割成grid_x*grid_y块，grid_x，grid_y默认为8</div><div class="line">    for(int i=0;i&lt;grid_x;i++)</div><div class="line">    &#123;</div><div class="line">        for(int j=0;j&lt;grid_y;j++)</div><div class="line">        &#123;</div><div class="line">            //图像分块</div><div class="line">            Mat src_cell = Mat(src,Range(i*height,(i+1)*height),Range(j*width,(j+1)*width));</div><div class="line">            //计算直方图</div><div class="line">            Mat hist_cell = getLocalRegionLBPH(src_cell,0,(numPattern-1),true);</div><div class="line">            //将直方图放到result中</div><div class="line">            Mat rowResult = result.row(resultRowIndex);</div><div class="line">            hist_cell.reshape(1,1).convertTo(rowResult,CV_32FC1);</div><div class="line">            resultRowIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return result.reshape(1,1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//计算一个LBP特征图像块的直方图</div><div class="line">Mat getLocalRegionLBPH(const Mat&amp; src,int minValue,int maxValue,bool normed)</div><div class="line">&#123;</div><div class="line">    //定义存储直方图的矩阵</div><div class="line">    Mat result;</div><div class="line">    //计算得到直方图bin的数目，直方图数组的大小</div><div class="line">    int histSize = maxValue - minValue + 1;</div><div class="line">    //定义直方图每一维的bin的变化范围</div><div class="line">    float range[] = &#123; static_cast&lt;float&gt;(minValue),static_cast&lt;float&gt;(maxValue + 1) &#125;;</div><div class="line">    //定义直方图所有bin的变化范围</div><div class="line">    const float* ranges = &#123; range &#125;;</div><div class="line">    //计算直方图，src是要计算直方图的图像，1是要计算直方图的图像数目，0是计算直方图所用的图像的通道序号，从0索引</div><div class="line">    //Mat()是要用的掩模，result为输出的直方图，1为输出的直方图的维度，histSize直方图在每一维的变化范围</div><div class="line">    //ranges，所有直方图的变化范围（起点和终点）</div><div class="line">    calcHist(&amp;src,1,0,Mat(),result,1,&amp;histSize,&amp;ranges,true,false);</div><div class="line">    //归一化</div><div class="line">    if(normed)</div><div class="line">    &#123;</div><div class="line">        result /= (int)src.total();</div><div class="line">    &#125;</div><div class="line">    //结果表示成只有1行的矩阵</div><div class="line">    return result.reshape(1,1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;除了以上几种比较经典的LBP特征外，还有诸多变种，如TLBP(中心像素与周围所有像素比较，而不是根据采样点的数目)，DLBP(编码4邻域的灰度变化，每个方向上用两个比特编码)，MLBP(将中心像素值替换为采样点像素的平均值)，VLBP，RGB-LBP等。</p>
<h3 id="LBP特征的应用"><a href="#LBP特征的应用" class="headerlink" title="LBP特征的应用"></a>LBP特征的应用</h3><h4 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h4><p>&emsp;&emsp;人脸检测中比较典型的模型是Haar特征 + AdaBoost分类器，目前OpenCV也支持LBP + AdaBoost和HOG + AdaBoost的方法进行目标检测，而且LBP特征的训练速度较快，适用于实时检测场景。</p>
<h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h4><p>&emsp;&emsp;人脸识别中LBP特征向量主要是用于直方图的比较，通过距离度量的方式(例如方差)找到训练数据中与输入图像距离最小的特征向量，将其对应的类别作为识别结果输出。</p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="https://pdfs.semanticscholar.org/8e01/f162182365c7a275fb6b7ecaafe7b9719673.pdf" target="_blank" rel="external">Paper: Gray Scale and Rotation Invariant Texture Classification with Local Binary Patterns</a></li>
<li><a href="https://pdfs.semanticscholar.org/33fa/d977a6b317cfd6ecd43d978687e0df8a7338.pdf" target="_blank" rel="external">Paper: Multiresolution Gray Scale and Rotation Invariant Texture Classification with Local Binary Patterns</a></li>
<li><a href="http://www.ee.oulu.fi/mvg/files/pdf/pdf_494.pdf" target="_blank" rel="external">Paper: Face Recognition with Local Binary Patterns</a></li>
<li><a href="http://www.cbsr.ia.ac.cn/users/lzhang/papers/ICB07/ICB07_Liao.pdf" target="_blank" rel="external">Paper: Learning Multi-scale Block Local Binary Patterns for Face Recognition</a></li>
<li><a href="http://www.voidcn.com/blog/quincuntial/article/p-4988349.html" target="_blank" rel="external">http://www.voidcn.com/blog/quincuntial/article/p-4988349.html</a></li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="external">http://blog.csdn.net/zouxy09/article/details/7929531</a></li>
<li><a href="http://blog.jasonding.top/2014/11/04/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91LBP%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/" target="_blank" rel="external">http://blog.jasonding.top/2014/11/04/Machine%20Learning/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E3%80%91LBP%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/</a></li>
<li><a href="http://blog.csdn.net/liulina603/article/details/8291105" target="_blank" rel="external">http://blog.csdn.net/liulina603/article/details/8291105</a></li>
</ul>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Image/" rel="tag">#Image</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/08/image-feature-hog/" rel="next" title="图像特征提取之HOG特征">
                <i class="fa fa-chevron-left"></i> 图像特征提取之HOG特征
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/25/image-feature-haar/" rel="prev" title="图像特征提取之Haar特征">
                图像特征提取之Haar特征 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/my.jpg"
               alt="Senit_Co" />
          <p class="site-author-name" itemprop="name">Senit_Co</p>
          <p class="site-description motion-element" itemprop="description">Senit_Co's Blogs</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/senitco" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/hustershen/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/hustershen/activities" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Zhihu
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#原始LBP特征"><span class="nav-number">1.</span> <span class="nav-text">原始LBP特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆形LBP特征-Circular-LBP-or-Extended-LBP"><span class="nav-number">2.</span> <span class="nav-text">圆形LBP特征(Circular LBP or Extended LBP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转不变LBP特征-Rotation-Invariant-LBP"><span class="nav-number">3.</span> <span class="nav-text">旋转不变LBP特征(Rotation Invariant LBP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LBP等价模式-Uniform-LBP"><span class="nav-number">4.</span> <span class="nav-text">LBP等价模式(Uniform LBP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多尺度LBP-Multiscale-Block-LBP"><span class="nav-number">5.</span> <span class="nav-text">多尺度LBP(Multiscale Block LBP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图像的LBP特征向量-Local-Binary-Patterns-Histograms"><span class="nav-number">6.</span> <span class="nav-text">图像的LBP特征向量(Local Binary Patterns Histograms)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LBP特征的应用"><span class="nav-number">7.</span> <span class="nav-text">LBP特征的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#目标检测"><span class="nav-number">7.1.</span> <span class="nav-text">目标检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#人脸识别"><span class="nav-number">7.2.</span> <span class="nav-text">人脸识别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reference"><span class="nav-number">8.</span> <span class="nav-text">reference</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Senit_Co</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'SenitCo';
      var disqus_identifier = '2017/06/12/image-feature-lbp/';
      var disqus_title = '图像特征提取之LBP特征';
      var disqus_url = 'https://senitco.github.io/2017/06/12/image-feature-lbp/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  



  
  
  

  

  

</body>
</html>
